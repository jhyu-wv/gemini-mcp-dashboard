import {
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize,
  capitalize,
  extend,
  generateCodeFrame,
  init_runtime_dom_esm_bundler,
  init_shared_esm_bundler,
  isArray,
  isBuiltInDirective,
  isHTMLTag,
  isMathMLTag,
  isObject,
  isOn,
  isReservedProp,
  isSVGTag,
  isString,
  isSymbol,
  isVoidTag,
  makeMap,
  parseStringStyle,
  runtime_dom_esm_bundler_exports,
  shared_esm_bundler_exports,
  slotFlagsText,
  toHandlerKey
} from "./chunk-5AJAZJHO.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-Y2SQFAFT.js";

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {
  return {
    type: 20,
    index,
    value,
    needPauseTracking,
    inVOnce,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
}
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : `https://vuejs.org/error-reference/#compiler-${code}`;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p = parentStack[i];
    if (p.type === "NewExpression") {
      return true;
    } else if (p.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  const body = block.type === "SwitchCase" ? block.consequent : block.body;
  for (const stmt of body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    } else if (isForStatement(stmt)) {
      walkForStatement(stmt, true, onIdent);
    } else if (stmt.type === "SwitchStatement") {
      walkSwitchStatement(stmt, true, onIdent);
    }
  }
}
function isForStatement(stmt) {
  return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
}
function walkForStatement(stmt, isVar, onIdent) {
  const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
  if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : !isVar)) {
    for (const decl of variable.declarations) {
      for (const id of extractIdentifiers(decl.id)) {
        onIdent(id);
      }
    }
  }
}
function walkSwitchStatement(stmt, isVar, onIdent) {
  for (const cs of stmt.cases) {
    for (const stmt2 of cs.consequent) {
      if (stmt2.type === "VariableDeclaration" && (stmt2.kind === "var" ? isVar : !isVar)) {
        for (const decl of stmt2.declarations) {
          for (const id of extractIdentifiers(decl.id)) {
            onIdent(id);
          }
        }
      }
    }
    walkBlockDeclarations(cs, onIdent);
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element) extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVPre(p) {
  return p.type === 7 && p.name === "pre";
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
    case 20:
      return false;
    default:
      if (true) ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function isWhitespaceText(node) {
  return node.type === 2 && isAllWhitespace(node.content) || node.type === 12 && isWhitespaceText(node.content);
}
function isCommentOrWhitespace(node) {
  return node.type === 3 || isWhitespaceText(node);
}
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 : 0
      /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  {
    const tag = stack[0] && stack[0].tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (isCompatEnabled(
      "COMPILER_V_IF_V_FOR_PRECEDENCE",
      currentOptions
    )) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 7) {
          if (p.name === "if") {
            hasIf = true;
          } else if (p.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation(
            "COMPILER_V_IF_V_FOR_PRECEDENCE",
            currentOptions,
            el.loc
          );
          break;
        }
      }
    }
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
      warnDeprecation(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions,
        el.loc
      );
      const parent = stack[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
  return i;
}
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
    } else if (
      // :is on plain element - only treat as component in compat mode
      p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        currentOptions,
        p.loc
      )
    ) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
function condenseWhitespace(nodes) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function cloneLoc(loc) {
  return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  if (true) {
    if (!currentOptions.decodeEntities) {
      throw new Error(
        `[@vue/compiler-core] decodeEntities option is required in browser builds.`
      );
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}
function cacheStatic(root, context) {
  walk(
    root,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    !!getSingleElementRoot(root)
  );
}
function getSingleElementRoot(root) {
  const children = root.children.filter((x) => x.type !== 3);
  return children.length === 1 && children[0].type === 1 && !isSlotOutlet(children[0]) ? children[0] : null;
}
function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        if (child.codegenNode.type === 14 && child.codegenNode.arguments.length > 0) {
          child.codegenNode.arguments.push(
            -1 + (true ? ` /* ${PatchFlagNames[-1]} */` : ``)
          );
        }
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, node, context, false, inFor);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, node, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          node,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  if (toCache.length === children.length && node.type === 1) {
    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
      node.codegenNode.children = getCacheExpression(
        createArrayExpression(node.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
      const slot = getSlotNode(node.codegenNode, "default");
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir(node, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  function getCacheExpression(value) {
    const exp = context.cache(value);
    exp.needArraySpread = true;
    return exp;
  }
  function getSlotNode(node2, name) {
    if (node2.children && !isArray(node2.children) && node2.children.type === 15) {
      const slot = node2.children.properties.find(
        (p) => p.key === name || p.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      if (true) ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false, inVOnce = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode,
        inVOnce
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    cacheStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const singleElementRootChild = getSingleElementRoot(root);
    if (singleElementRootChild && singleElementRootChild.codegenNode) {
      const codegenNode = singleElementRootChild.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = children[0];
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
    }
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child)) continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push(
      "\n" + `  `.repeat(n),
      0
      /* Start */
    );
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1
        /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(
      `
`,
      0
      /* Start */
    );
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(
        `const _Vue = ${VueBinding}
`,
        -1
        /* End */
      );
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(
          `const { ${staticHelpers} } = _Vue
`,
          -1
          /* End */
        );
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(
        node,
        -3
        /* Unknown */
      );
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(
      node,
      -3
      /* Unknown */
    );
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(
        node.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(
        child,
        -3
        /* Unknown */
      );
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2, node);
  } else {
    push(`[${node.content}]`, -3, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  let patchFlagString;
  if (patchFlag) {
    if (true) {
      if (patchFlag < 0) {
        patchFlagString = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
      } else {
        const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
        patchFlagString = patchFlag + ` /* ${flagNames} */`;
      }
    } else {
      patchFlagString = String(patchFlag);
    }
  }
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, -2, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node;
  if (needArraySpread) {
    push(`[...(`);
  }
  push(`_cache[${node.index}] || (`);
  if (needPauseTracking) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1`);
    if (node.inVOnce) push(`, true`);
    push(`),`);
    newline();
    push(`(`);
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (needPauseTracking) {
    push(`).cacheIndex = ${node.index},`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
  if (needArraySpread) {
    push(`)]`);
  }
}
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(
      createCompilerError(
        45,
        node.loc,
        void 0,
        message
      )
    );
  }
}
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: cloneLoc(node.loc),
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && isCommentOrWhitespace(sibling)) {
        context.removeNode(sibling);
        if (sibling.type === 3) {
          comments.unshift(sibling);
        }
        continue;
      }
      if (sibling && sibling.type === 9) {
        if ((dir.name === "else-if" || dir.name === "else") && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        true ? '"v-if"' : '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
      }
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized) return;
  if (true) {
    validateBrowserExpression(result.source, context);
    if (result.key) {
      validateBrowserExpression(
        result.key,
        context,
        true
      );
    }
    if (result.index) {
      validateBrowserExpression(
        result.index,
        context,
        true
      );
    }
    if (result.value) {
      validateBrowserExpression(
        result.value,
        context,
        true
      );
    }
  }
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(?:-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (!isCommentOrWhitespace(prev)) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, /^(?:else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    !implicitDefaultChildren.every(isWhitespaceText)) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            {
              pushMergeArg();
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context,
                    loc
                  );
                }
              }
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            pushRefVForMarker();
            pushMergeArg();
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = camelize(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ") break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation(
      "COMPILER_FILTERS",
      context,
      node.loc
    );
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
    node.ast = void 0;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformVBindShorthand,
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}
var FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, Namespaces, NodeTypes, ElementTypes, ConstantTypes, locStub, defaultDelimitersOpen, defaultDelimitersClose, Sequences, Tokenizer, CompilerDeprecationTypes, deprecationData, ErrorCodes, errorMessages, isFunctionType, isStaticProperty, isStaticPropertyKey, TS_NODE_TYPES, isStaticExp, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, getExpSource, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, fnExpRE, isFnExpressionBrowser, isFnExpressionNode, isFnExpression, propsHelperSet, forAliasRE, defaultParserOptions, currentOptions, currentRoot, currentInput, currentOpenTag, currentProp, currentAttrValue, currentAttrStartIndex, currentAttrEndIndex, inPre, inVPre, currentVPreBoundary, stack, tokenizer, forIteratorRE, stripParensRE, specialTemplateDir, windowsNewlineRE, allowHoistedHelperSet, PURE_ANNOTATION, aliasHelper, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformFor, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, transformSlotOutlet, transformOn, transformBind, injectPrefix, transformText, seen$1, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen, transformMemo, transformVBindShorthand, BindingTypes, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(
      true ? `BaseTransition` : ``
    );
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(
      true ? `createElementBlock` : ``
    );
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(
      true ? `createElementVNode` : ``
    );
    CREATE_COMMENT = Symbol(
      true ? `createCommentVNode` : ``
    );
    CREATE_TEXT = Symbol(
      true ? `createTextVNode` : ``
    );
    CREATE_STATIC = Symbol(
      true ? `createStaticVNode` : ``
    );
    RESOLVE_COMPONENT = Symbol(
      true ? `resolveComponent` : ``
    );
    RESOLVE_DYNAMIC_COMPONENT = Symbol(
      true ? `resolveDynamicComponent` : ``
    );
    RESOLVE_DIRECTIVE = Symbol(
      true ? `resolveDirective` : ``
    );
    RESOLVE_FILTER = Symbol(
      true ? `resolveFilter` : ``
    );
    WITH_DIRECTIVES = Symbol(
      true ? `withDirectives` : ``
    );
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(
      true ? `toDisplayString` : ``
    );
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(
      true ? `normalizeClass` : ``
    );
    NORMALIZE_STYLE = Symbol(
      true ? `normalizeStyle` : ``
    );
    NORMALIZE_PROPS = Symbol(
      true ? `normalizeProps` : ``
    );
    GUARD_REACTIVE_PROPS = Symbol(
      true ? `guardReactiveProps` : ``
    );
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(
      true ? `toHandlerKey` : ``
    );
    SET_BLOCK_TRACKING = Symbol(
      true ? `setBlockTracking` : ``
    );
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    Namespaces = {
      "HTML": 0,
      "0": "HTML",
      "SVG": 1,
      "1": "SVG",
      "MATH_ML": 2,
      "2": "MATH_ML"
    };
    NodeTypes = {
      "ROOT": 0,
      "0": "ROOT",
      "ELEMENT": 1,
      "1": "ELEMENT",
      "TEXT": 2,
      "2": "TEXT",
      "COMMENT": 3,
      "3": "COMMENT",
      "SIMPLE_EXPRESSION": 4,
      "4": "SIMPLE_EXPRESSION",
      "INTERPOLATION": 5,
      "5": "INTERPOLATION",
      "ATTRIBUTE": 6,
      "6": "ATTRIBUTE",
      "DIRECTIVE": 7,
      "7": "DIRECTIVE",
      "COMPOUND_EXPRESSION": 8,
      "8": "COMPOUND_EXPRESSION",
      "IF": 9,
      "9": "IF",
      "IF_BRANCH": 10,
      "10": "IF_BRANCH",
      "FOR": 11,
      "11": "FOR",
      "TEXT_CALL": 12,
      "12": "TEXT_CALL",
      "VNODE_CALL": 13,
      "13": "VNODE_CALL",
      "JS_CALL_EXPRESSION": 14,
      "14": "JS_CALL_EXPRESSION",
      "JS_OBJECT_EXPRESSION": 15,
      "15": "JS_OBJECT_EXPRESSION",
      "JS_PROPERTY": 16,
      "16": "JS_PROPERTY",
      "JS_ARRAY_EXPRESSION": 17,
      "17": "JS_ARRAY_EXPRESSION",
      "JS_FUNCTION_EXPRESSION": 18,
      "18": "JS_FUNCTION_EXPRESSION",
      "JS_CONDITIONAL_EXPRESSION": 19,
      "19": "JS_CONDITIONAL_EXPRESSION",
      "JS_CACHE_EXPRESSION": 20,
      "20": "JS_CACHE_EXPRESSION",
      "JS_BLOCK_STATEMENT": 21,
      "21": "JS_BLOCK_STATEMENT",
      "JS_TEMPLATE_LITERAL": 22,
      "22": "JS_TEMPLATE_LITERAL",
      "JS_IF_STATEMENT": 23,
      "23": "JS_IF_STATEMENT",
      "JS_ASSIGNMENT_EXPRESSION": 24,
      "24": "JS_ASSIGNMENT_EXPRESSION",
      "JS_SEQUENCE_EXPRESSION": 25,
      "25": "JS_SEQUENCE_EXPRESSION",
      "JS_RETURN_STATEMENT": 26,
      "26": "JS_RETURN_STATEMENT"
    };
    ElementTypes = {
      "ELEMENT": 0,
      "0": "ELEMENT",
      "COMPONENT": 1,
      "1": "COMPONENT",
      "SLOT": 2,
      "2": "SLOT",
      "TEMPLATE": 3,
      "3": "TEMPLATE"
    };
    ConstantTypes = {
      "NOT_CONSTANT": 0,
      "0": "NOT_CONSTANT",
      "CAN_SKIP_PATCH": 1,
      "1": "CAN_SKIP_PATCH",
      "CAN_CACHE": 2,
      "2": "CAN_CACHE",
      "CAN_STRINGIFY": 3,
      "3": "CAN_STRINGIFY"
    };
    locStub = {
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 },
      source: ""
    };
    defaultDelimitersOpen = new Uint8Array([123, 123]);
    defaultDelimitersClose = new Uint8Array([125, 125]);
    Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      // CDATA[
      CdataEnd: new Uint8Array([93, 93, 62]),
      // ]]>
      CommentEnd: new Uint8Array([45, 45, 62]),
      // `-->`
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      // `<\/script`
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      // `</style`
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
      // `</title`
      TextareaEnd: new Uint8Array([
        60,
        47,
        116,
        101,
        120,
        116,
        97,
        114,
        101,
        97
      ])
      // `</textarea
    };
    Tokenizer = class {
      constructor(stack2, cbs) {
        this.stack = stack2;
        this.cbs = cbs;
        this.state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.entityStart = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.inXML = false;
        this.inVPre = false;
        this.newlines = [];
        this.mode = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
        this.delimiterIndex = -1;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
      }
      get inSFCRoot() {
        return this.mode === 2 && this.stack.length === 0;
      }
      reset() {
        this.state = 1;
        this.mode = 0;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.currentSequence = void 0;
        this.newlines.length = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
      }
      /**
       * Generate Position object with line / column information using recorded
       * newline positions. We know the index is always going to be an already
       * processed index, so all the newlines up to this index should have been
       * recorded.
       */
      getPos(index) {
        let line = 1;
        let column = index + 1;
        for (let i = this.newlines.length - 1; i >= 0; i--) {
          const newlineIndex = this.newlines[i];
          if (index > newlineIndex) {
            line = i + 2;
            column = index - newlineIndex;
            break;
          }
        }
        return {
          column,
          line,
          offset: index
        };
      }
      peek() {
        return this.buffer.charCodeAt(this.index + 1);
      }
      stateText(c) {
        if (c === 60) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      }
      stateInterpolationOpen(c) {
        if (c === this.delimiterOpen[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterOpen.length - 1) {
            const start = this.index + 1 - this.delimiterOpen.length;
            if (start > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, start);
            }
            this.state = 3;
            this.sectionStart = start;
          } else {
            this.delimiterIndex++;
          }
        } else if (this.inRCDATA) {
          this.state = 32;
          this.stateInRCDATA(c);
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInterpolation(c) {
        if (c === this.delimiterClose[0]) {
          this.state = 4;
          this.delimiterIndex = 0;
          this.stateInterpolationClose(c);
        }
      }
      stateInterpolationClose(c) {
        if (c === this.delimiterClose[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterClose.length - 1) {
            this.cbs.oninterpolation(this.sectionStart, this.index + 1);
            if (this.inRCDATA) {
              this.state = 32;
            } else {
              this.state = 1;
            }
            this.sectionStart = this.index + 1;
          } else {
            this.delimiterIndex++;
          }
        } else {
          this.state = 3;
          this.stateInterpolation(c);
        }
      }
      stateSpecialStartSequence(c) {
        const isEnd = this.sequenceIndex === this.currentSequence.length;
        const isMatch = isEnd ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          isEndOfTagSection(c)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (c | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!isMatch) {
          this.inRCDATA = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = 6;
        this.stateInTagName(c);
      }
      /** Look for an end tag. For <title> and <textarea>, also decode entities. */
      stateInRCDATA(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === 62 || isWhitespace(c)) {
            const endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              const actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            this.inRCDATA = false;
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
            if (!this.inVPre && c === this.delimiterOpen[0]) {
              this.state = 2;
              this.delimiterIndex = 0;
              this.stateInterpolationOpen(c);
            }
          } else if (this.fastForwardTo(60)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === 60);
        }
      }
      stateCDATASequence(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = 28;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = 23;
          this.stateInDeclaration(c);
        }
      }
      /**
       * When we wait for one specific character, we can speed things up
       * by skipping through the buffer until we find it.
       *
       * @returns Whether the character was found.
       */
      fastForwardTo(c) {
        while (++this.index < this.buffer.length) {
          const cc = this.buffer.charCodeAt(this.index);
          if (cc === 10) {
            this.newlines.push(this.index);
          }
          if (cc === c) {
            return true;
          }
        }
        this.index = this.buffer.length - 1;
        return false;
      }
      /**
       * Comments and CDATA end with `-->` and `]]>`.
       *
       * Their common qualities are:
       * - Their end sequences have a distinct character they start with.
       * - That character is then repeated, so we have to check multiple repeats.
       * - All characters but the start character of the sequence can be skipped.
       */
      stateInCommentLike(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index - 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index - 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = 1;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      }
      startSpecial(sequence, offset) {
        this.enterRCDATA(sequence, offset);
        this.state = 31;
      }
      enterRCDATA(sequence, offset) {
        this.inRCDATA = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
      }
      stateBeforeTagName(c) {
        if (c === 33) {
          this.state = 22;
          this.sectionStart = this.index + 1;
        } else if (c === 63) {
          this.state = 24;
          this.sectionStart = this.index + 1;
        } else if (isTagStartChar(c)) {
          this.sectionStart = this.index;
          if (this.mode === 0) {
            this.state = 6;
          } else if (this.inSFCRoot) {
            this.state = 34;
          } else if (!this.inXML) {
            if (c === 116) {
              this.state = 30;
            } else {
              this.state = c === 115 ? 29 : 6;
            }
          } else {
            this.state = 6;
          }
        } else if (c === 47) {
          this.state = 8;
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInTagName(c) {
        if (isEndOfTagSection(c)) {
          this.handleTagName(c);
        }
      }
      stateInSFCRootTagName(c) {
        if (isEndOfTagSection(c)) {
          const tag = this.buffer.slice(this.sectionStart, this.index);
          if (tag !== "template") {
            this.enterRCDATA(toCharCodes(`</` + tag), 0);
          }
          this.handleTagName(c);
        }
      }
      handleTagName(c) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c);
      }
      stateBeforeClosingTagName(c) {
        if (isWhitespace(c)) ;
        else if (c === 62) {
          if (true) {
            this.cbs.onerr(14, this.index);
          }
          this.state = 1;
          this.sectionStart = this.index + 1;
        } else {
          this.state = isTagStartChar(c) ? 9 : 27;
          this.sectionStart = this.index;
        }
      }
      stateInClosingTagName(c) {
        if (c === 62 || isWhitespace(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = 10;
          this.stateAfterClosingTagName(c);
        }
      }
      stateAfterClosingTagName(c) {
        if (c === 62) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeAttrName(c) {
        if (c === 62) {
          this.cbs.onopentagend(this.index);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else if (c === 47) {
          this.state = 7;
          if (this.peek() !== 62) {
            this.cbs.onerr(22, this.index);
          }
        } else if (c === 60 && this.peek() === 47) {
          this.cbs.onopentagend(this.index);
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!isWhitespace(c)) {
          if (c === 61) {
            this.cbs.onerr(
              19,
              this.index
            );
          }
          this.handleAttrStart(c);
        }
      }
      handleAttrStart(c) {
        if (c === 118 && this.peek() === 45) {
          this.state = 13;
          this.sectionStart = this.index;
        } else if (c === 46 || c === 58 || c === 64 || c === 35) {
          this.cbs.ondirname(this.index, this.index + 1);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 12;
          this.sectionStart = this.index;
        }
      }
      stateInSelfClosingTag(c) {
        if (c === 62) {
          this.cbs.onselfclosingtag(this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
          this.inRCDATA = false;
        } else if (!isWhitespace(c)) {
          this.state = 11;
          this.stateBeforeAttrName(c);
        }
      }
      stateInAttrName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 34 || c === 39 || c === 60) {
          this.cbs.onerr(
            17,
            this.index
          );
        }
      }
      stateInDirName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 58) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else if (c === 46) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDirArg(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 91) {
          this.state = 15;
        } else if (c === 46) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDynamicDirArg(c) {
        if (c === 93) {
          this.state = 14;
        } else if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index + 1);
          this.handleAttrNameEnd(c);
          if (true) {
            this.cbs.onerr(
              27,
              this.index
            );
          }
        }
      }
      stateInDirModifier(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 46) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.sectionStart = this.index + 1;
        }
      }
      handleAttrNameEnd(c) {
        this.sectionStart = this.index;
        this.state = 17;
        this.cbs.onattribnameend(this.index);
        this.stateAfterAttrName(c);
      }
      stateAfterAttrName(c) {
        if (c === 61) {
          this.state = 18;
        } else if (c === 47 || c === 62) {
          this.cbs.onattribend(0, this.sectionStart);
          this.sectionStart = -1;
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (!isWhitespace(c)) {
          this.cbs.onattribend(0, this.sectionStart);
          this.handleAttrStart(c);
        }
      }
      stateBeforeAttrValue(c) {
        if (c === 34) {
          this.state = 19;
          this.sectionStart = this.index + 1;
        } else if (c === 39) {
          this.state = 20;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
          this.sectionStart = this.index;
          this.state = 21;
          this.stateInAttrValueNoQuotes(c);
        }
      }
      handleInAttrValue(c, quote) {
        if (c === quote || this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(
            quote === 34 ? 3 : 2,
            this.index + 1
          );
          this.state = 11;
        }
      }
      stateInAttrValueDoubleQuotes(c) {
        this.handleInAttrValue(c, 34);
      }
      stateInAttrValueSingleQuotes(c) {
        this.handleInAttrValue(c, 39);
      }
      stateInAttrValueNoQuotes(c) {
        if (isWhitespace(c) || c === 62) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(1, this.index);
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
          this.cbs.onerr(
            18,
            this.index
          );
        } else ;
      }
      stateBeforeDeclaration(c) {
        if (c === 91) {
          this.state = 26;
          this.sequenceIndex = 0;
        } else {
          this.state = c === 45 ? 25 : 23;
        }
      }
      stateInDeclaration(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateInProcessingInstruction(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeComment(c) {
        if (c === 45) {
          this.state = 28;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 23;
        }
      }
      stateInSpecialComment(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.oncomment(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeSpecialS(c) {
        if (c === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (c === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      stateBeforeSpecialT(c) {
        if (c === Sequences.TitleEnd[3]) {
          this.startSpecial(Sequences.TitleEnd, 4);
        } else if (c === Sequences.TextareaEnd[3]) {
          this.startSpecial(Sequences.TextareaEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      startEntity() {
      }
      stateInEntity() {
      }
      /**
       * Iterates through the buffer, calling the function corresponding to the current state.
       *
       * States that are more likely to be hit are higher up, as a performance improvement.
       */
      parse(input) {
        this.buffer = input;
        while (this.index < this.buffer.length) {
          const c = this.buffer.charCodeAt(this.index);
          if (c === 10 && this.state !== 33) {
            this.newlines.push(this.index);
          }
          switch (this.state) {
            case 1: {
              this.stateText(c);
              break;
            }
            case 2: {
              this.stateInterpolationOpen(c);
              break;
            }
            case 3: {
              this.stateInterpolation(c);
              break;
            }
            case 4: {
              this.stateInterpolationClose(c);
              break;
            }
            case 31: {
              this.stateSpecialStartSequence(c);
              break;
            }
            case 32: {
              this.stateInRCDATA(c);
              break;
            }
            case 26: {
              this.stateCDATASequence(c);
              break;
            }
            case 19: {
              this.stateInAttrValueDoubleQuotes(c);
              break;
            }
            case 12: {
              this.stateInAttrName(c);
              break;
            }
            case 13: {
              this.stateInDirName(c);
              break;
            }
            case 14: {
              this.stateInDirArg(c);
              break;
            }
            case 15: {
              this.stateInDynamicDirArg(c);
              break;
            }
            case 16: {
              this.stateInDirModifier(c);
              break;
            }
            case 28: {
              this.stateInCommentLike(c);
              break;
            }
            case 27: {
              this.stateInSpecialComment(c);
              break;
            }
            case 11: {
              this.stateBeforeAttrName(c);
              break;
            }
            case 6: {
              this.stateInTagName(c);
              break;
            }
            case 34: {
              this.stateInSFCRootTagName(c);
              break;
            }
            case 9: {
              this.stateInClosingTagName(c);
              break;
            }
            case 5: {
              this.stateBeforeTagName(c);
              break;
            }
            case 17: {
              this.stateAfterAttrName(c);
              break;
            }
            case 20: {
              this.stateInAttrValueSingleQuotes(c);
              break;
            }
            case 18: {
              this.stateBeforeAttrValue(c);
              break;
            }
            case 8: {
              this.stateBeforeClosingTagName(c);
              break;
            }
            case 10: {
              this.stateAfterClosingTagName(c);
              break;
            }
            case 29: {
              this.stateBeforeSpecialS(c);
              break;
            }
            case 30: {
              this.stateBeforeSpecialT(c);
              break;
            }
            case 21: {
              this.stateInAttrValueNoQuotes(c);
              break;
            }
            case 7: {
              this.stateInSelfClosingTag(c);
              break;
            }
            case 23: {
              this.stateInDeclaration(c);
              break;
            }
            case 22: {
              this.stateBeforeDeclaration(c);
              break;
            }
            case 25: {
              this.stateBeforeComment(c);
              break;
            }
            case 24: {
              this.stateInProcessingInstruction(c);
              break;
            }
            case 33: {
              this.stateInEntity();
              break;
            }
          }
          this.index++;
        }
        this.cleanup();
        this.finish();
      }
      /**
       * Remove data that has already been consumed from the buffer.
       */
      cleanup() {
        if (this.sectionStart !== this.index) {
          if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === 19 || this.state === 20 || this.state === 21) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      }
      finish() {
        this.handleTrailingData();
        this.cbs.onend();
      }
      /** Handle any trailing data. */
      handleTrailingData() {
        const endIndex = this.buffer.length;
        if (this.sectionStart >= endIndex) {
          return;
        }
        if (this.state === 28) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex);
          }
        } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      }
      emitCodePoint(cp, consumed) {
      }
    };
    CompilerDeprecationTypes = {
      "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
      "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
      "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
      "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
      "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
      "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
      "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
      "COMPILER_FILTERS": "COMPILER_FILTERS"
    };
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTERS"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    ErrorCodes = {
      "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
      "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
      "CDATA_IN_HTML_CONTENT": 1,
      "1": "CDATA_IN_HTML_CONTENT",
      "DUPLICATE_ATTRIBUTE": 2,
      "2": "DUPLICATE_ATTRIBUTE",
      "END_TAG_WITH_ATTRIBUTES": 3,
      "3": "END_TAG_WITH_ATTRIBUTES",
      "END_TAG_WITH_TRAILING_SOLIDUS": 4,
      "4": "END_TAG_WITH_TRAILING_SOLIDUS",
      "EOF_BEFORE_TAG_NAME": 5,
      "5": "EOF_BEFORE_TAG_NAME",
      "EOF_IN_CDATA": 6,
      "6": "EOF_IN_CDATA",
      "EOF_IN_COMMENT": 7,
      "7": "EOF_IN_COMMENT",
      "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
      "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
      "EOF_IN_TAG": 9,
      "9": "EOF_IN_TAG",
      "INCORRECTLY_CLOSED_COMMENT": 10,
      "10": "INCORRECTLY_CLOSED_COMMENT",
      "INCORRECTLY_OPENED_COMMENT": 11,
      "11": "INCORRECTLY_OPENED_COMMENT",
      "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
      "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
      "MISSING_ATTRIBUTE_VALUE": 13,
      "13": "MISSING_ATTRIBUTE_VALUE",
      "MISSING_END_TAG_NAME": 14,
      "14": "MISSING_END_TAG_NAME",
      "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
      "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
      "NESTED_COMMENT": 16,
      "16": "NESTED_COMMENT",
      "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
      "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
      "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
      "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
      "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
      "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
      "UNEXPECTED_NULL_CHARACTER": 20,
      "20": "UNEXPECTED_NULL_CHARACTER",
      "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
      "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
      "UNEXPECTED_SOLIDUS_IN_TAG": 22,
      "22": "UNEXPECTED_SOLIDUS_IN_TAG",
      "X_INVALID_END_TAG": 23,
      "23": "X_INVALID_END_TAG",
      "X_MISSING_END_TAG": 24,
      "24": "X_MISSING_END_TAG",
      "X_MISSING_INTERPOLATION_END": 25,
      "25": "X_MISSING_INTERPOLATION_END",
      "X_MISSING_DIRECTIVE_NAME": 26,
      "26": "X_MISSING_DIRECTIVE_NAME",
      "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
      "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
      "X_V_IF_NO_EXPRESSION": 28,
      "28": "X_V_IF_NO_EXPRESSION",
      "X_V_IF_SAME_KEY": 29,
      "29": "X_V_IF_SAME_KEY",
      "X_V_ELSE_NO_ADJACENT_IF": 30,
      "30": "X_V_ELSE_NO_ADJACENT_IF",
      "X_V_FOR_NO_EXPRESSION": 31,
      "31": "X_V_FOR_NO_EXPRESSION",
      "X_V_FOR_MALFORMED_EXPRESSION": 32,
      "32": "X_V_FOR_MALFORMED_EXPRESSION",
      "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
      "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
      "X_V_BIND_NO_EXPRESSION": 34,
      "34": "X_V_BIND_NO_EXPRESSION",
      "X_V_ON_NO_EXPRESSION": 35,
      "35": "X_V_ON_NO_EXPRESSION",
      "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
      "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
      "X_V_SLOT_MIXED_SLOT_USAGE": 37,
      "37": "X_V_SLOT_MIXED_SLOT_USAGE",
      "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
      "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
      "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
      "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
      "X_V_SLOT_MISPLACED": 40,
      "40": "X_V_SLOT_MISPLACED",
      "X_V_MODEL_NO_EXPRESSION": 41,
      "41": "X_V_MODEL_NO_EXPRESSION",
      "X_V_MODEL_MALFORMED_EXPRESSION": 42,
      "42": "X_V_MODEL_MALFORMED_EXPRESSION",
      "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
      "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
      "X_V_MODEL_ON_PROPS": 44,
      "44": "X_V_MODEL_ON_PROPS",
      "X_INVALID_EXPRESSION": 45,
      "45": "X_INVALID_EXPRESSION",
      "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
      "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
      "X_PREFIX_ID_NOT_SUPPORTED": 47,
      "47": "X_PREFIX_ID_NOT_SUPPORTED",
      "X_MODULE_MODE_NOT_SUPPORTED": 48,
      "48": "X_MODULE_MODE_NOT_SUPPORTED",
      "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
      "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
      "X_SCOPE_ID_NOT_SUPPORTED": 50,
      "50": "X_SCOPE_ID_NOT_SUPPORTED",
      "X_VNODE_HOOKS": 51,
      "51": "X_VNODE_HOOKS",
      "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
      "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
      "__EXTEND_POINT__": 53,
      "53": "__EXTEND_POINT__"
    };
    errorMessages = {
      // parse errors
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      // transform errors
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [52]: `v-bind with same-name shorthand only allows static argument.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
      [45]: `Error parsing JavaScript expression: `,
      [46]: `<KeepAlive> expects exactly one child component.`,
      [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
      // generic errors
      [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [48]: `ES module mode is not supported in this build of compiler.`,
      [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [50]: `"scopeId" option is only supported in module mode.`,
      // just to fulfill types
      [53]: ``
    };
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    TS_NODE_TYPES = [
      "TSAsExpression",
      // foo as number
      "TSTypeAssertion",
      // (<number>foo)
      "TSNonNullExpression",
      // foo!
      "TSInstantiationExpression",
      // foo<string>
      "TSSatisfiesExpression"
      // foo satisfies T
    ];
    isStaticExp = (p) => p.type === 4 && p.isStatic;
    nonIdentifierRE = /^$|^\d|[^\$\w\xA0-\uFFFF]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
    isMemberExpressionBrowser = (exp) => {
      const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    fnExpRE = /^\s*(?:async\s*)?(?:\([^)]*?\)|[\w$_]+)\s*(?::[^=]+)?=>|^\s*(?:async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
    isFnExpressionNode = NOOP;
    isFnExpression = isFnExpressionBrowser;
    propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
    defaultParserOptions = {
      parseMode: "base",
      ns: 0,
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isIgnoreNewlineTag: NO,
      isCustomElement: NO,
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true,
      prefixIdentifiers: false
    };
    currentOptions = defaultParserOptions;
    currentRoot = null;
    currentInput = "";
    currentOpenTag = null;
    currentProp = null;
    currentAttrValue = "";
    currentAttrStartIndex = -1;
    currentAttrEndIndex = -1;
    inPre = 0;
    inVPre = false;
    currentVPreBoundary = null;
    stack = [];
    tokenizer = new Tokenizer(stack, {
      onerr: emitError,
      ontext(start, end) {
        onText(getSlice(start, end), start, end);
      },
      ontextentity(char, start, end) {
        onText(char, start, end);
      },
      oninterpolation(start, end) {
        if (inVPre) {
          return onText(getSlice(start, end), start, end);
        }
        let innerStart = start + tokenizer.delimiterOpen.length;
        let innerEnd = end - tokenizer.delimiterClose.length;
        while (isWhitespace(currentInput.charCodeAt(innerStart))) {
          innerStart++;
        }
        while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
          innerEnd--;
        }
        let exp = getSlice(innerStart, innerEnd);
        if (exp.includes("&")) {
          {
            exp = currentOptions.decodeEntities(exp, false);
          }
        }
        addNode({
          type: 5,
          content: createExp(exp, false, getLoc(innerStart, innerEnd)),
          loc: getLoc(start, end)
        });
      },
      onopentagname(start, end) {
        const name = getSlice(start, end);
        currentOpenTag = {
          type: 1,
          tag: name,
          ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
          tagType: 0,
          // will be refined on tag close
          props: [],
          children: [],
          loc: getLoc(start - 1, end),
          codegenNode: void 0
        };
      },
      onopentagend(end) {
        endOpenTag(end);
      },
      onclosetag(start, end) {
        const name = getSlice(start, end);
        if (!currentOptions.isVoidTag(name)) {
          let found = false;
          for (let i = 0; i < stack.length; i++) {
            const e = stack[i];
            if (e.tag.toLowerCase() === name.toLowerCase()) {
              found = true;
              if (i > 0) {
                emitError(24, stack[0].loc.start.offset);
              }
              for (let j = 0; j <= i; j++) {
                const el = stack.shift();
                onCloseTag(el, end, j < i);
              }
              break;
            }
          }
          if (!found) {
            emitError(23, backTrack(start, 60));
          }
        }
      },
      onselfclosingtag(end) {
        const name = currentOpenTag.tag;
        currentOpenTag.isSelfClosing = true;
        endOpenTag(end);
        if (stack[0] && stack[0].tag === name) {
          onCloseTag(stack.shift(), end);
        }
      },
      onattribname(start, end) {
        currentProp = {
          type: 6,
          name: getSlice(start, end),
          nameLoc: getLoc(start, end),
          value: void 0,
          loc: getLoc(start)
        };
      },
      ondirname(start, end) {
        const raw = getSlice(start, end);
        const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
        if (!inVPre && name === "") {
          emitError(26, start);
        }
        if (inVPre || name === "") {
          currentProp = {
            type: 6,
            name: raw,
            nameLoc: getLoc(start, end),
            value: void 0,
            loc: getLoc(start)
          };
        } else {
          currentProp = {
            type: 7,
            name,
            rawName: raw,
            exp: void 0,
            arg: void 0,
            modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
            loc: getLoc(start)
          };
          if (name === "pre") {
            inVPre = tokenizer.inVPre = true;
            currentVPreBoundary = currentOpenTag;
            const props = currentOpenTag.props;
            for (let i = 0; i < props.length; i++) {
              if (props[i].type === 7) {
                props[i] = dirToAttr(props[i]);
              }
            }
          }
        }
      },
      ondirarg(start, end) {
        if (start === end) return;
        const arg = getSlice(start, end);
        if (inVPre && !isVPre(currentProp)) {
          currentProp.name += arg;
          setLocEnd(currentProp.nameLoc, end);
        } else {
          const isStatic = arg[0] !== `[`;
          currentProp.arg = createExp(
            isStatic ? arg : arg.slice(1, -1),
            isStatic,
            getLoc(start, end),
            isStatic ? 3 : 0
          );
        }
      },
      ondirmodifier(start, end) {
        const mod = getSlice(start, end);
        if (inVPre && !isVPre(currentProp)) {
          currentProp.name += "." + mod;
          setLocEnd(currentProp.nameLoc, end);
        } else if (currentProp.name === "slot") {
          const arg = currentProp.arg;
          if (arg) {
            arg.content += "." + mod;
            setLocEnd(arg.loc, end);
          }
        } else {
          const exp = createSimpleExpression(mod, true, getLoc(start, end));
          currentProp.modifiers.push(exp);
        }
      },
      onattribdata(start, end) {
        currentAttrValue += getSlice(start, end);
        if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribentity(char, start, end) {
        currentAttrValue += char;
        if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribnameend(end) {
        const start = currentProp.loc.start.offset;
        const name = getSlice(start, end);
        if (currentProp.type === 7) {
          currentProp.rawName = name;
        }
        if (currentOpenTag.props.some(
          (p) => (p.type === 7 ? p.rawName : p.name) === name
        )) {
          emitError(2, start);
        }
      },
      onattribend(quote, end) {
        if (currentOpenTag && currentProp) {
          setLocEnd(currentProp.loc, end);
          if (quote !== 0) {
            if (currentAttrValue.includes("&")) {
              currentAttrValue = currentOptions.decodeEntities(
                currentAttrValue,
                true
              );
            }
            if (currentProp.type === 6) {
              if (currentProp.name === "class") {
                currentAttrValue = condense(currentAttrValue).trim();
              }
              if (quote === 1 && !currentAttrValue) {
                emitError(13, end);
              }
              currentProp.value = {
                type: 2,
                content: currentAttrValue,
                loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
              };
              if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
                tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
              }
            } else {
              let expParseMode = 0;
              currentProp.exp = createExp(
                currentAttrValue,
                false,
                getLoc(currentAttrStartIndex, currentAttrEndIndex),
                0,
                expParseMode
              );
              if (currentProp.name === "for") {
                currentProp.forParseResult = parseForExpression(currentProp.exp);
              }
              let syncIndex = -1;
              if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
                (mod) => mod.content === "sync"
              )) > -1 && checkCompatEnabled(
                "COMPILER_V_BIND_SYNC",
                currentOptions,
                currentProp.loc,
                currentProp.arg.loc.source
              )) {
                currentProp.name = "model";
                currentProp.modifiers.splice(syncIndex, 1);
              }
            }
          }
          if (currentProp.type !== 7 || currentProp.name !== "pre") {
            currentOpenTag.props.push(currentProp);
          }
        }
        currentAttrValue = "";
        currentAttrStartIndex = currentAttrEndIndex = -1;
      },
      oncomment(start, end) {
        if (currentOptions.comments) {
          addNode({
            type: 3,
            content: getSlice(start, end),
            loc: getLoc(start - 4, end + 3)
          });
        }
      },
      onend() {
        const end = currentInput.length;
        if (tokenizer.state !== 1) {
          switch (tokenizer.state) {
            case 5:
            case 8:
              emitError(5, end);
              break;
            case 3:
            case 4:
              emitError(
                25,
                tokenizer.sectionStart
              );
              break;
            case 28:
              if (tokenizer.currentSequence === Sequences.CdataEnd) {
                emitError(6, end);
              } else {
                emitError(7, end);
              }
              break;
            case 6:
            case 7:
            case 9:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              emitError(9, end);
              break;
          }
        }
        for (let index = 0; index < stack.length; index++) {
          onCloseTag(stack[index], end - 1);
          emitError(24, stack[index].loc.start.offset);
        }
      },
      oncdata(start, end) {
        if (stack[0].ns !== 0) {
          onText(getSlice(start, end), start, end);
        } else {
          emitError(1, start - 9);
        }
      },
      onprocessinginstruction(start) {
        if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
          emitError(
            21,
            start - 1
          );
        }
      }
    });
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
    windowsNewlineRE = /\r\n/g;
    allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*@__PURE__*/`;
    aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    prohibitedKeywordRE = new RegExp(
      "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
    );
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(
          node.content,
          context
        );
      } else if (node.type === 1) {
        const memo = findDir(node, "memo");
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg) && // key has been processed in transformFor(vMemo + vFor)
            !(memo && arg && arg.type === 4 && arg.content === "key")) {
              dir.exp = processExpression(
                exp,
                context,
                // slot args must be processed as function params
                dir.name === "slot"
              );
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(
      /^(?:if|else|else-if)$/,
      (node, dir, context) => {
        return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(
                branch,
                key,
                context
              );
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(
                branch,
                key + ifNode.branches.length - 1,
                context
              );
            }
          };
        });
      }
    );
    transformFor = createStructuralDirectiveTransform(
      "for",
      (node, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`, false, true);
          keyProp && keyProp.type === 7;
          let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
          const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(
            context,
            helper(FRAGMENT),
            void 0,
            renderExp,
            fragmentFlag,
            void 0,
            void 0,
            true,
            !isStableFragment,
            false,
            node.loc
          );
          return () => {
            let childBlock;
            const { children } = forNode;
            if (isTemplate) {
              node.children.some((c) => {
                if (c.type === 1) {
                  const key = findProp(c, "key");
                  if (key) {
                    context.onError(
                      createCompilerError(
                        33,
                        key.loc
                      )
                    );
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node.children,
                64,
                void 0,
                void 0,
                true,
                void 0,
                false
              );
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(
                    getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                  );
                } else {
                  removeHelper(
                    getVNodeHelper(context.inSSR, childBlock.isComponent)
                  );
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(
                createForLoopParams(forNode.parseResult, [
                  createSimpleExpression(`_cached`)
                ])
              );
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context.helperString(
                    IS_MEMO_SAME
                  )}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(
                loop,
                createSimpleExpression(`_cache`),
                createSimpleExpression(String(context.cached.length))
              );
              context.cached.push(null);
            } else {
              renderExp.arguments.push(
                createFunctionExpression(
                  createForLoopParams(forNode.parseResult),
                  childBlock,
                  true
                )
              );
            }
          };
        });
      }
    );
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.forParseResult;
        if (result) {
          finalizeForParseResult(result, context);
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
      props,
      children,
      false,
      true,
      children.length ? children[0].loc : loc
    );
    directiveImportMap = /* @__PURE__ */ new WeakMap();
    transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = (
          // dynamic component may resolve to plain elements
          isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
          // updates inside get proper isSVG flag at runtime. (#639, #643)
          // This is technically web-specific, but splitting the logic out of core
          // leads to too much unnecessary complexity.
          (tag === "svg" || tag === "foreignObject" || tag === "math")
        );
        if (props.length > 0) {
          const propsBuildResult = buildProps(
            node,
            context,
            void 0,
            isComponent2,
            isDynamicComponent
          );
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(
            directives.map((dir) => buildDirectiveArgs(dir, context))
          ) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(
                createCompilerError(46, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                })
              );
            }
          }
          const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
          vnodeTag !== TELEPORT && // explained above.
          vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (dynamicPropNames && dynamicPropNames.length) {
          vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
        }
        node.codegenNode = createVNodeCall(
          context,
          vnodeTag,
          vnodeProps,
          vnodeChildren,
          patchFlag === 0 ? void 0 : patchFlag,
          vnodeDynamicProps,
          vnodeDirectives,
          !!shouldUseBlock,
          false,
          isComponent2,
          node.loc
        );
      };
    };
    transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(
          context.helper(RENDER_SLOT),
          slotArgs,
          loc
        );
      }
    };
    transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vnode")) {
            context.onError(createCompilerError(51, arg.loc));
          }
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
            // for non-element and vnode lifecycle event listeners, auto convert
            // it to camelCase. See issue #2249
            toHandlerKey(camelize(rawName))
          ) : (
            // preserve case for plain element listeners that have uppercase
            // letters, as these may be custom elements' custom events
            `on:${rawName}`
          );
          eventName = createSimpleExpression(eventString, true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp);
        const isInlineStatement = !(isMemberExp || isFnExpression(exp));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(
            exp,
            context,
            false,
            hasMultipleStatements
          );
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(
            eventName,
            exp || createSimpleExpression(`() => {}`, false, loc)
          )
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    transformBind = (dir, _node, context) => {
      const { modifiers, loc } = dir;
      const arg = dir.arg;
      let { exp } = dir;
      if (exp && exp.type === 4 && !exp.content.trim()) {
        {
          exp = void 0;
        }
      }
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = arg.content ? `${arg.content} || ""` : `""`;
      }
      if (modifiers.some((mod) => mod.content === "camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.some((mod) => mod.content === "prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.some((mod) => mod.content === "attr")) {
          injectPrefix(arg, "^");
        }
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText$1(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = createCompoundExpression(
                      [child],
                      child.loc
                    );
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || // if this is a plain element with a single text child, leave it
          // as-is since the runtime has dedicated fast path for this by directly
          // setting textContent of the element.
          // for component root it's always normalized anyway.
          children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
          // custom directives can potentially add DOM elements arbitrarily,
          // we need to avoid setting textContent of the element at runtime
          // to avoid accidentally overwriting the DOM elements added
          // by the user through custom directives.
          !node.props.find(
            (p) => p.type === 7 && !context.directiveTransforms[p.name]
          ) && // in compat mode, <template> tags with no special directives
          // will be rendered as a fragment so its children must be
          // converted into vnodes.
          !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(
                  1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``)
                );
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(
                  context.helper(CREATE_TEXT),
                  callArgs
                )
              };
            }
          }
        };
      }
    };
    seen$1 = /* @__PURE__ */ new WeakSet();
    transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen$1.has(node) || context.inVOnce || context.inSSR) {
          return;
        }
        seen$1.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(
              cur.codegenNode,
              true,
              true
            );
          }
        };
      }
    };
    transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(
          createCompilerError(41, dir.loc)
        );
        return createTransformProps();
      }
      const rawExp = exp.loc.source.trim();
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context.bindingMetadata[rawExp];
      if (bindingType === "props" || bindingType === "props-aliased") {
        context.onError(createCompilerError(44, exp.loc));
        return createTransformProps();
      }
      if (!expString.trim() || !isMemberExpression(exp) && true) {
        context.onError(
          createCompilerError(42, exp.loc)
        );
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(
          createObjectProperty(
            modifiersKey,
            createSimpleExpression(
              `{ ${modifiers} }`,
              false,
              dir.loc,
              2
            )
          )
        );
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTERS", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      } else if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen = /* @__PURE__ */ new WeakSet();
    transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen.has(node) || context.inSSR) {
          return;
        }
        seen.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              convertToBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached.length)
            ]);
            context.cached.push(null);
          }
        };
      }
    };
    transformVBindShorthand = (node, context) => {
      if (node.type === 1) {
        for (const prop of node.props) {
          if (prop.type === 7 && prop.name === "bind" && (!prop.exp || // #13930 :foo in in-DOM templates will be parsed into :foo="" by browser
          prop.exp.type === 4 && !prop.exp.content.trim()) && prop.arg) {
            const arg = prop.arg;
            if (arg.type !== 4 || !arg.isStatic) {
              context.onError(
                createCompilerError(
                  52,
                  arg.loc
                )
              );
              prop.exp = createSimpleExpression("", true, arg.loc);
            } else {
              const propName = camelize(arg.content);
              if (validFirstIdentCharRE.test(propName[0]) || // allow hyphen first char for https://github.com/vuejs/language-tools/pull/3424
              propName[0] === "-") {
                prop.exp = createSimpleExpression(propName, false, arg.loc);
              }
            }
          }
        }
      }
    };
    BindingTypes = {
      "DATA": "data",
      "PROPS": "props",
      "PROPS_ALIASED": "props-aliased",
      "SETUP_LET": "setup-let",
      "SETUP_CONST": "setup-const",
      "SETUP_REACTIVE_CONST": "setup-reactive-const",
      "SETUP_MAYBE_REF": "setup-maybe-ref",
      "SETUP_REF": "setup-ref",
      "OPTIONS": "options",
      "LITERAL_CONST": "literal-const"
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  BindingTypes: () => BindingTypes,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  CompilerDeprecationTypes: () => CompilerDeprecationTypes,
  ConstantTypes: () => ConstantTypes,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMErrorCodes: () => DOMErrorCodes,
  DOMErrorMessages: () => DOMErrorMessages,
  DOMNodeTransforms: () => DOMNodeTransforms,
  ElementTypes: () => ElementTypes,
  ErrorCodes: () => ErrorCodes,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  Namespaces: () => Namespaces,
  NodeTypes: () => NodeTypes,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  TS_NODE_TYPES: () => TS_NODE_TYPES,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildDirectiveArgs: () => buildDirectiveArgs,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  convertToBlock: () => convertToBlock,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  errorMessages: () => errorMessages,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  forAliasRE: () => forAliasRE,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getConstantType: () => getConstantType,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isAllWhitespace: () => isAllWhitespace,
  isCommentOrWhitespace: () => isCommentOrWhitespace,
  isCoreComponent: () => isCoreComponent,
  isFnExpression: () => isFnExpression,
  isFnExpressionBrowser: () => isFnExpressionBrowser,
  isFnExpressionNode: () => isFnExpressionNode,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isInNewExpression: () => isInNewExpression,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText$1,
  isVPre: () => isVPre,
  isVSlot: () => isVSlot,
  isWhitespaceText: () => isWhitespaceText,
  locStub: () => locStub,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  stringifyExpression: () => stringifyExpression,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  transformVBindShorthand: () => transformVBindShorthand,
  traverseNode: () => traverseNode,
  unwrapTSNode: () => unwrapTSNode,
  validFirstIdentCharRE: () => validFirstIdentCharRE,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc,
    true ? DOMErrorMessages : void 0
  );
}
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => !isCommentOrWhitespace(c)
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function isValidHTMLNesting(parent, child) {
  if (parent === "template") {
    return true;
  }
  if (parent in onlyValidChildren) {
    return onlyValidChildren[parent].has(child);
  }
  if (child in onlyValidParents) {
    return onlyValidParents[child].has(parent);
  }
  if (parent in knownInvalidChildren) {
    if (knownInvalidChildren[parent].has(child)) return false;
  }
  if (child in knownInvalidParents) {
    if (knownInvalidParents[child].has(parent)) return false;
  }
  return true;
}
function compile(src, options = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, parserOptions, transformStyle, parseInlineCSS, DOMErrorCodes, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, transformTransition, ignoreSideEffectTags, headings, emptySet, onlyValidChildren, onlyValidParents, knownInvalidChildren, knownInvalidParents, validateHtmlNesting, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(
      true ? `vModelCheckbox` : ``
    );
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(
      true ? `vModelSelect` : ``
    );
    V_MODEL_DYNAMIC = Symbol(
      true ? `vModelDynamic` : ``
    );
    V_ON_WITH_MODIFIERS = Symbol(
      true ? `vOnModifiersGuard` : ``
    );
    V_ON_WITH_KEYS = Symbol(
      true ? `vOnKeysGuard` : ``
    );
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(
      true ? `TransitionGroup` : ``
    );
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    parserOptions = {
      parseMode: "html",
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      isPreTag: (tag) => tag === "pre",
      isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (tag === "Transition" || tag === "transition") {
          return TRANSITION;
        } else if (tag === "TransitionGroup" || tag === "transition-group") {
          return TRANSITION_GROUP;
        }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent, rootNamespace) {
        let ns = parent ? parent.ns : rootNamespace;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some(
              (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
            )) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      }
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(
        JSON.stringify(normalized),
        false,
        loc,
        3
      );
    };
    DOMErrorCodes = {
      "X_V_HTML_NO_EXPRESSION": 53,
      "53": "X_V_HTML_NO_EXPRESSION",
      "X_V_HTML_WITH_CHILDREN": 54,
      "54": "X_V_HTML_WITH_CHILDREN",
      "X_V_TEXT_NO_EXPRESSION": 55,
      "55": "X_V_TEXT_NO_EXPRESSION",
      "X_V_TEXT_WITH_CHILDREN": 56,
      "56": "X_V_TEXT_WITH_CHILDREN",
      "X_V_MODEL_ON_INVALID_ELEMENT": 57,
      "57": "X_V_MODEL_ON_INVALID_ELEMENT",
      "X_V_MODEL_ARG_ON_ELEMENT": 58,
      "58": "X_V_MODEL_ARG_ON_ELEMENT",
      "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
      "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
      "X_V_MODEL_UNNECESSARY_VALUE": 60,
      "60": "X_V_MODEL_UNNECESSARY_VALUE",
      "X_V_SHOW_NO_EXPRESSION": 61,
      "61": "X_V_SHOW_NO_EXPRESSION",
      "X_TRANSITION_INVALID_CHILDREN": 62,
      "62": "X_TRANSITION_INVALID_CHILDREN",
      "X_IGNORED_SIDE_EFFECT_TAG": 63,
      "63": "X_IGNORED_SIDE_EFFECT_TAG",
      "__EXTEND_POINT__": 64,
      "64": "__EXTEND_POINT__"
    };
    DOMErrorMessages = {
      [53]: `v-html is missing expression.`,
      [54]: `v-html will override element children.`,
      [55]: `v-text is missing expression.`,
      [56]: `v-text will override element children.`,
      [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [58]: `v-model argument is not supported on plain elements.`,
      [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [61]: `v-show is missing expression.`,
      [62]: `<Transition> expects exactly one child element or component.`,
      [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(53, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(54, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`innerHTML`, true, loc),
            exp || createSimpleExpression("", true)
          )
        ]
      };
    };
    transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(55, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(56, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`textContent`, true),
            exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
              context.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            ) : createSimpleExpression("", true)
          )
        ]
      };
    };
    transformModel2 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(
          createDOMCompilerError(
            58,
            dir.arg.loc
          )
        );
      }
      function checkDuplicatedValue() {
        const value = findDir(node, "bind");
        if (value && isStaticArgOf(value.arg, "value")) {
          context.onError(
            createDOMCompilerError(
              60,
              value.loc
            )
          );
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(
                    createDOMCompilerError(
                      59,
                      dir.loc
                    )
                  );
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(
          createDOMCompilerError(
            57,
            dir.loc
          )
        );
      }
      baseResult.props = baseResult.props.filter(
        (p) => !(p.key.type === 4 && p.key.content === "modelValue")
      );
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(
      // event propagation management
      `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
    );
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(`onkeyup,onkeydown,onkeypress`);
    resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i].content;
        if (modifier === "native" && checkCompatEnabled(
          "COMPILER_V_ON_NATIVE",
          context,
          loc
        )) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content.toLowerCase())) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    transformOn2 = (dir, node, context) => {
      return transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length) return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
        (!isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)]
        };
      });
    };
    transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(61, loc)
        );
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    transformTransition = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (!node.children.length) {
              return;
            }
            if (hasMultipleChildren(node)) {
              context.onError(
                createDOMCompilerError(
                  62,
                  {
                    start: node.children[0].loc.start,
                    end: node.children[node.children.length - 1].loc.end,
                    source: ""
                  }
                )
              );
            }
            const child = node.children[0];
            if (child.type === 1) {
              for (const p of child.props) {
                if (p.type === 7 && p.name === "show") {
                  node.props.push({
                    type: 6,
                    name: "persisted",
                    nameLoc: node.loc,
                    value: void 0,
                    loc: node.loc
                  });
                }
              }
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(
          createDOMCompilerError(
            63,
            node.loc
          )
        );
        context.removeNode();
      }
    };
    headings = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
    emptySet = /* @__PURE__ */ new Set([]);
    onlyValidChildren = {
      head: /* @__PURE__ */ new Set([
        "base",
        "basefront",
        "bgsound",
        "link",
        "meta",
        "title",
        "noscript",
        "noframes",
        "style",
        "script",
        "template"
      ]),
      optgroup: /* @__PURE__ */ new Set(["option"]),
      select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
      // table
      table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
      tr: /* @__PURE__ */ new Set(["td", "th"]),
      colgroup: /* @__PURE__ */ new Set(["col"]),
      tbody: /* @__PURE__ */ new Set(["tr"]),
      thead: /* @__PURE__ */ new Set(["tr"]),
      tfoot: /* @__PURE__ */ new Set(["tr"]),
      // these elements can not have any children elements
      script: emptySet,
      iframe: emptySet,
      option: emptySet,
      textarea: emptySet,
      style: emptySet,
      title: emptySet
    };
    onlyValidParents = {
      // sections
      html: emptySet,
      body: /* @__PURE__ */ new Set(["html"]),
      head: /* @__PURE__ */ new Set(["html"]),
      // table
      td: /* @__PURE__ */ new Set(["tr"]),
      colgroup: /* @__PURE__ */ new Set(["table"]),
      caption: /* @__PURE__ */ new Set(["table"]),
      tbody: /* @__PURE__ */ new Set(["table"]),
      tfoot: /* @__PURE__ */ new Set(["table"]),
      col: /* @__PURE__ */ new Set(["colgroup"]),
      th: /* @__PURE__ */ new Set(["tr"]),
      thead: /* @__PURE__ */ new Set(["table"]),
      tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
      // data list
      dd: /* @__PURE__ */ new Set(["dl", "div"]),
      dt: /* @__PURE__ */ new Set(["dl", "div"]),
      // other
      figcaption: /* @__PURE__ */ new Set(["figure"]),
      // li: new Set(["ul", "ol"]),
      summary: /* @__PURE__ */ new Set(["details"]),
      area: /* @__PURE__ */ new Set(["map"])
    };
    knownInvalidChildren = {
      p: /* @__PURE__ */ new Set([
        "address",
        "article",
        "aside",
        "blockquote",
        "center",
        "details",
        "dialog",
        "dir",
        "div",
        "dl",
        "fieldset",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "li",
        "main",
        "nav",
        "menu",
        "ol",
        "p",
        "pre",
        "section",
        "table",
        "ul"
      ]),
      svg: /* @__PURE__ */ new Set([
        "b",
        "blockquote",
        "br",
        "code",
        "dd",
        "div",
        "dl",
        "dt",
        "em",
        "embed",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hr",
        "i",
        "img",
        "li",
        "menu",
        "meta",
        "ol",
        "p",
        "pre",
        "ruby",
        "s",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "table",
        "u",
        "ul",
        "var"
      ])
    };
    knownInvalidParents = {
      a: /* @__PURE__ */ new Set(["a"]),
      button: /* @__PURE__ */ new Set(["button"]),
      dd: /* @__PURE__ */ new Set(["dd", "dt"]),
      dt: /* @__PURE__ */ new Set(["dd", "dt"]),
      form: /* @__PURE__ */ new Set(["form"]),
      li: /* @__PURE__ */ new Set(["li"]),
      h1: headings,
      h2: headings,
      h3: headings,
      h4: headings,
      h5: headings,
      h6: headings
    };
    validateHtmlNesting = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {
        const error = new SyntaxError(
          `<${node.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
        );
        error.loc = node.loc;
        context.onWarn(error);
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [transformTransition, validateHtmlNesting] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      // override compiler-core
      on: transformOn2,
      // override compiler-core
      show: transformShow
    };
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var runtimeDom = (init_runtime_dom_esm_bundler(), __toCommonJS(runtime_dom_esm_bundler_exports));
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n.default = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespaceDefault(runtimeDom);
    var compileCache = /* @__PURE__ */ Object.create(null);
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = shared.genCacheKey(template, options);
      const cached = compileCache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const opts = shared.extend(
        {
          hoistStatic: true,
          onError,
          onWarn: (e) => onError(e, true)
        },
        options
      );
      if (!opts.isCustomElement && typeof customElements !== "undefined") {
        opts.isCustomElement = (tag) => !!customElements.get(tag);
      }
      const { code } = compilerDom.compile(template, opts);
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(
          template,
          err.loc.start.offset,
          err.loc.end.offset
        );
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return compileCache[key] = render;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    exports.compile = compileToFunction;
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = runtimeDom[k];
    });
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/vue3-grid-layout/dist/vue-grid-layout.common.js
var require_vue_grid_layout_common = __commonJS({
  "node_modules/vue3-grid-layout/dist/vue-grid-layout.common.js"(exports, module) {
    module.exports = /******/
    function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          /******/
          i: moduleId,
          /******/
          l: false,
          /******/
          exports: {}
          /******/
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1) value = __webpack_require__(value);
        if (mode & 8) return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns, key, (function(key2) {
          return value[key2];
        }).bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? (
          /******/
          function getDefault() {
            return module2["default"];
          }
        ) : (
          /******/
          function getModuleExports() {
            return module2;
          }
        );
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      /***/
      "0366": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var aFunction = __webpack_require__("1c0b");
          module2.exports = function(fn, that, length) {
            aFunction(fn);
            if (that === void 0) return fn;
            switch (length) {
              case 0:
                return function() {
                  return fn.call(that);
                };
              case 1:
                return function(a) {
                  return fn.call(that, a);
                };
              case 2:
                return function(a, b) {
                  return fn.call(that, a, b);
                };
              case 3:
                return function(a, b, c) {
                  return fn.call(that, a, b, c);
                };
            }
            return function() {
              return fn.apply(that, arguments);
            };
          };
        }
      ),
      /***/
      "057f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toIndexedObject = __webpack_require__("fc6a");
          var nativeGetOwnPropertyNames = __webpack_require__("241c").f;
          var toString = {}.toString;
          var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
          var getWindowNames = function(it) {
            try {
              return nativeGetOwnPropertyNames(it);
            } catch (error) {
              return windowNames.slice();
            }
          };
          module2.exports.f = function getOwnPropertyNames(it) {
            return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
          };
        }
      ),
      /***/
      "06cf": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var propertyIsEnumerableModule = __webpack_require__("d1e7");
          var createPropertyDescriptor = __webpack_require__("5c6c");
          var toIndexedObject = __webpack_require__("fc6a");
          var toPrimitive = __webpack_require__("c04e");
          var has = __webpack_require__("5135");
          var IE8_DOM_DEFINE = __webpack_require__("0cfb");
          var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
            O = toIndexedObject(O);
            P = toPrimitive(P, true);
            if (IE8_DOM_DEFINE) try {
              return nativeGetOwnPropertyDescriptor(O, P);
            } catch (error) {
            }
            if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
          };
        }
      ),
      /***/
      "0cb2": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toObject = __webpack_require__("7b0b");
          var floor = Math.floor;
          var replace = "".replace;
          var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
          var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
          module2.exports = function(matched, str, position, captures, namedCaptures, replacement) {
            var tailPos = position + matched.length;
            var m = captures.length;
            var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
            if (namedCaptures !== void 0) {
              namedCaptures = toObject(namedCaptures);
              symbols = SUBSTITUTION_SYMBOLS;
            }
            return replace.call(replacement, symbols, function(match, ch) {
              var capture;
              switch (ch.charAt(0)) {
                case "$":
                  return "$";
                case "&":
                  return matched;
                case "`":
                  return str.slice(0, position);
                case "'":
                  return str.slice(tailPos);
                case "<":
                  capture = namedCaptures[ch.slice(1, -1)];
                  break;
                default:
                  var n = +ch;
                  if (n === 0) return match;
                  if (n > m) {
                    var f = floor(n / 10);
                    if (f === 0) return match;
                    if (f <= m) return captures[f - 1] === void 0 ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                    return match;
                  }
                  capture = captures[n - 1];
              }
              return capture === void 0 ? "" : capture;
            });
          };
        }
      ),
      /***/
      "0cfb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var fails = __webpack_require__("d039");
          var createElement = __webpack_require__("cc12");
          module2.exports = !DESCRIPTORS && !fails(function() {
            return Object.defineProperty(createElement("div"), "a", {
              get: function() {
                return 7;
              }
            }).a != 7;
          });
        }
      ),
      /***/
      "14c3": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var classof = __webpack_require__("c6b6");
          var regexpExec = __webpack_require__("9263");
          module2.exports = function(R, S) {
            var exec = R.exec;
            if (typeof exec === "function") {
              var result = exec.call(R, S);
              if (typeof result !== "object") {
                throw TypeError("RegExp exec method returned something other than an Object or null");
              }
              return result;
            }
            if (classof(R) !== "RegExp") {
              throw TypeError("RegExp#exec called on incompatible receiver");
            }
            return regexpExec.call(R, S);
          };
        }
      ),
      /***/
      "159b": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var DOMIterables = __webpack_require__("fdbc");
          var forEach = __webpack_require__("17c2");
          var createNonEnumerableProperty = __webpack_require__("9112");
          for (var COLLECTION_NAME in DOMIterables) {
            var Collection = global[COLLECTION_NAME];
            var CollectionPrototype = Collection && Collection.prototype;
            if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
              createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
            } catch (error) {
              CollectionPrototype.forEach = forEach;
            }
          }
        }
      ),
      /***/
      "17c2": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $forEach = __webpack_require__("b727").forEach;
          var arrayMethodIsStrict = __webpack_require__("a640");
          var STRICT_METHOD = arrayMethodIsStrict("forEach");
          module2.exports = !STRICT_METHOD ? function forEach(callbackfn) {
            return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          } : [].forEach;
        }
      ),
      /***/
      "18d2": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var browserDetector = __webpack_require__("18e9");
          module2.exports = function(options) {
            options = options || {};
            var reporter = options.reporter;
            var batchProcessor = options.batchProcessor;
            var getState = options.stateHandler.getState;
            if (!reporter) {
              throw new Error("Missing required dependency: reporter.");
            }
            function addListener(element, listener) {
              function listenerProxy() {
                listener(element);
              }
              if (browserDetector.isIE(8)) {
                getState(element).object = {
                  proxy: listenerProxy
                };
                element.attachEvent("onresize", listenerProxy);
              } else {
                var object = getObject(element);
                if (!object) {
                  throw new Error("Element is not detectable by this strategy.");
                }
                object.contentDocument.defaultView.addEventListener("resize", listenerProxy);
              }
            }
            function buildCssTextString(rules) {
              var seperator = options.important ? " !important; " : "; ";
              return (rules.join(seperator) + seperator).trim();
            }
            function makeDetectable(options2, element, callback) {
              if (!callback) {
                callback = element;
                element = options2;
                options2 = null;
              }
              options2 = options2 || {};
              var debug = options2.debug;
              function injectObject(element2, callback2) {
                var OBJECT_STYLE = buildCssTextString(["display: block", "position: absolute", "top: 0", "left: 0", "width: 100%", "height: 100%", "border: none", "padding: 0", "margin: 0", "opacity: 0", "z-index: -1000", "pointer-events: none", "visibility: hidden"]);
                var positionCheckPerformed = false;
                var style = window.getComputedStyle(element2);
                var width = element2.offsetWidth;
                var height = element2.offsetHeight;
                getState(element2).startSize = {
                  width,
                  height
                };
                function mutateDom() {
                  function alterPositionStyles() {
                    if (style.position === "static") {
                      element2.style.setProperty("position", "relative", options2.important ? "important" : "");
                      var removeRelativeStyles = function(reporter2, element3, style2, property) {
                        function getNumericalValue(value2) {
                          return value2.replace(/[^-\d\.]/g, "");
                        }
                        var value = style2[property];
                        if (value !== "auto" && getNumericalValue(value) !== "0") {
                          reporter2.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element3);
                          element3.style.setProperty(property, "0", options2.important ? "important" : "");
                        }
                      };
                      removeRelativeStyles(reporter, element2, style, "top");
                      removeRelativeStyles(reporter, element2, style, "right");
                      removeRelativeStyles(reporter, element2, style, "bottom");
                      removeRelativeStyles(reporter, element2, style, "left");
                    }
                  }
                  function onObjectLoad() {
                    if (!positionCheckPerformed) {
                      alterPositionStyles();
                    }
                    function getDocument(element3, callback3) {
                      if (!element3.contentDocument) {
                        var state = getState(element3);
                        if (state.checkForObjectDocumentTimeoutId) {
                          window.clearTimeout(state.checkForObjectDocumentTimeoutId);
                        }
                        state.checkForObjectDocumentTimeoutId = setTimeout(function checkForObjectDocument() {
                          state.checkForObjectDocumentTimeoutId = 0;
                          getDocument(element3, callback3);
                        }, 100);
                        return;
                      }
                      callback3(element3.contentDocument);
                    }
                    var objectElement = this;
                    getDocument(objectElement, function onObjectDocumentReady(objectDocument) {
                      callback2(element2);
                    });
                  }
                  if (style.position !== "") {
                    alterPositionStyles(style);
                    positionCheckPerformed = true;
                  }
                  var object = document.createElement("object");
                  object.style.cssText = OBJECT_STYLE;
                  object.tabIndex = -1;
                  object.type = "text/html";
                  object.setAttribute("aria-hidden", "true");
                  object.onload = onObjectLoad;
                  if (!browserDetector.isIE()) {
                    object.data = "about:blank";
                  }
                  if (!getState(element2)) {
                    return;
                  }
                  element2.appendChild(object);
                  getState(element2).object = object;
                  if (browserDetector.isIE()) {
                    object.data = "about:blank";
                  }
                }
                if (batchProcessor) {
                  batchProcessor.add(mutateDom);
                } else {
                  mutateDom();
                }
              }
              if (browserDetector.isIE(8)) {
                callback(element);
              } else {
                injectObject(element, callback);
              }
            }
            function getObject(element) {
              return getState(element).object;
            }
            function uninstall(element) {
              if (!getState(element)) {
                return;
              }
              var object = getObject(element);
              if (!object) {
                return;
              }
              if (browserDetector.isIE(8)) {
                element.detachEvent("onresize", object.proxy);
              } else {
                element.removeChild(object);
              }
              if (getState(element).checkForObjectDocumentTimeoutId) {
                window.clearTimeout(getState(element).checkForObjectDocumentTimeoutId);
              }
              delete getState(element).object;
            }
            return {
              makeDetectable,
              addListener,
              uninstall
            };
          };
        }
      ),
      /***/
      "18e9": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var detector = module2.exports = {};
          detector.isIE = function(version) {
            function isAnyIeVersion() {
              var agent = navigator.userAgent.toLowerCase();
              return agent.indexOf("msie") !== -1 || agent.indexOf("trident") !== -1 || agent.indexOf(" edge/") !== -1;
            }
            if (!isAnyIeVersion()) {
              return false;
            }
            if (!version) {
              return true;
            }
            var ieVersion = function() {
              var undef, v = 3, div = document.createElement("div"), all = div.getElementsByTagName("i");
              do {
                div.innerHTML = "<!--[if gt IE " + ++v + "]><i></i><![endif]-->";
              } while (all[0]);
              return v > 4 ? v : undef;
            }();
            return version === ieVersion;
          };
          detector.isLegacyOpera = function() {
            return !!window.opera;
          };
        }
      ),
      /***/
      "1be4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var getBuiltIn = __webpack_require__("d066");
          module2.exports = getBuiltIn("document", "documentElement");
        }
      ),
      /***/
      "1c0b": (
        /***/
        function(module2, exports2) {
          module2.exports = function(it) {
            if (typeof it != "function") {
              throw TypeError(String(it) + " is not a function");
            }
            return it;
          };
        }
      ),
      /***/
      "1ca7": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return getDocumentDir;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return addWindowEventListener;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return removeWindowEventListener;
          });
          var currentDir = "auto";
          function hasDocument() {
            return typeof document !== "undefined";
          }
          function hasWindow() {
            return typeof window !== "undefined";
          }
          function getDocumentDir() {
            if (!hasDocument()) {
              return currentDir;
            }
            var direction = typeof document.dir !== "undefined" ? document.dir : document.getElementsByTagName("html")[0].getAttribute("dir");
            return direction;
          }
          function setDocumentDir(dir) {
            if (!hasDocument) {
              currentDir = dir;
              return;
            }
            var html = document.getElementsByTagName("html")[0];
            html.setAttribute("dir", dir);
          }
          function addWindowEventListener(event, callback) {
            if (!hasWindow) {
              callback();
              return;
            }
            window.addEventListener(event, callback);
          }
          function removeWindowEventListener(event, callback) {
            if (!hasWindow) {
              return;
            }
            window.removeEventListener(event, callback);
          }
        }
      ),
      /***/
      "1d80": (
        /***/
        function(module2, exports2) {
          module2.exports = function(it) {
            if (it == void 0) throw TypeError("Can't call method on " + it);
            return it;
          };
        }
      ),
      /***/
      "1dde": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          var wellKnownSymbol = __webpack_require__("b622");
          var V8_VERSION = __webpack_require__("2d00");
          var SPECIES = wellKnownSymbol("species");
          module2.exports = function(METHOD_NAME) {
            return V8_VERSION >= 51 || !fails(function() {
              var array = [];
              var constructor = array.constructor = {};
              constructor[SPECIES] = function() {
                return { foo: 1 };
              };
              return array[METHOD_NAME](Boolean).foo !== 1;
            });
          };
        }
      ),
      /***/
      "23cb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("a691");
          var max = Math.max;
          var min = Math.min;
          module2.exports = function(index, length) {
            var integer = toInteger(index);
            return integer < 0 ? max(integer + length, 0) : min(integer, length);
          };
        }
      ),
      /***/
      "23e7": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
          var createNonEnumerableProperty = __webpack_require__("9112");
          var redefine = __webpack_require__("6eeb");
          var setGlobal = __webpack_require__("ce4e");
          var copyConstructorProperties = __webpack_require__("e893");
          var isForced = __webpack_require__("94ca");
          module2.exports = function(options, source) {
            var TARGET = options.target;
            var GLOBAL = options.global;
            var STATIC = options.stat;
            var FORCED, target, key, targetProperty, sourceProperty, descriptor;
            if (GLOBAL) {
              target = global;
            } else if (STATIC) {
              target = global[TARGET] || setGlobal(TARGET, {});
            } else {
              target = (global[TARGET] || {}).prototype;
            }
            if (target) for (key in source) {
              sourceProperty = source[key];
              if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor(target, key);
                targetProperty = descriptor && descriptor.value;
              } else targetProperty = target[key];
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
              if (!FORCED && targetProperty !== void 0) {
                if (typeof sourceProperty === typeof targetProperty) continue;
                copyConstructorProperties(sourceProperty, targetProperty);
              }
              if (options.sham || targetProperty && targetProperty.sham) {
                createNonEnumerableProperty(sourceProperty, "sham", true);
              }
              redefine(target, key, sourceProperty, options);
            }
          };
        }
      ),
      /***/
      "241c": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var internalObjectKeys = __webpack_require__("ca84");
          var enumBugKeys = __webpack_require__("7839");
          var hiddenKeys = enumBugKeys.concat("length", "prototype");
          exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
            return internalObjectKeys(O, hiddenKeys);
          };
        }
      ),
      /***/
      "24fb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          module2.exports = function(useSourceMap) {
            var list = [];
            list.toString = function toString() {
              return this.map(function(item) {
                var content = cssWithMappingToString(item, useSourceMap);
                if (item[2]) {
                  return "@media ".concat(item[2], " {").concat(content, "}");
                }
                return content;
              }).join("");
            };
            list.i = function(modules, mediaQuery, dedupe) {
              if (typeof modules === "string") {
                modules = [[null, modules, ""]];
              }
              var alreadyImportedModules = {};
              if (dedupe) {
                for (var i = 0; i < this.length; i++) {
                  var id = this[i][0];
                  if (id != null) {
                    alreadyImportedModules[id] = true;
                  }
                }
              }
              for (var _i = 0; _i < modules.length; _i++) {
                var item = [].concat(modules[_i]);
                if (dedupe && alreadyImportedModules[item[0]]) {
                  continue;
                }
                if (mediaQuery) {
                  if (!item[2]) {
                    item[2] = mediaQuery;
                  } else {
                    item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
                  }
                }
                list.push(item);
              }
            };
            return list;
          };
          function cssWithMappingToString(item, useSourceMap) {
            var content = item[1] || "";
            var cssMapping = item[3];
            if (!cssMapping) {
              return content;
            }
            if (useSourceMap && typeof btoa === "function") {
              var sourceMapping = toComment(cssMapping);
              var sourceURLs = cssMapping.sources.map(function(source) {
                return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
              });
              return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
            }
            return [content].join("\n");
          }
          function toComment(sourceMap) {
            var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
            var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
            return "/*# ".concat(data, " */");
          }
        }
      ),
      /***/
      "2af9": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          (function(global) {
            __webpack_require__.d(__webpack_exports__, "d", function() {
              return install;
            });
            var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("159b");
            var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0__);
            var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("b64b");
            var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_1__);
            var _GridItem_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("bc21");
            __webpack_require__.d(__webpack_exports__, "a", function() {
              return _GridItem_vue__WEBPACK_IMPORTED_MODULE_2__["a"];
            });
            var _GridLayout_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("37c8");
            __webpack_require__.d(__webpack_exports__, "b", function() {
              return _GridLayout_vue__WEBPACK_IMPORTED_MODULE_3__["a"];
            });
            var VueGridLayout = {
              // ResponsiveGridLayout,
              GridLayout: _GridLayout_vue__WEBPACK_IMPORTED_MODULE_3__[
                /* default */
                "a"
              ],
              GridItem: _GridItem_vue__WEBPACK_IMPORTED_MODULE_2__[
                /* default */
                "a"
              ]
            };
            function install(Vue) {
              if (install.installed) return;
              install.installed = true;
              Object.keys(VueGridLayout).forEach(function(name) {
                Vue.component(name, VueGridLayout[name]);
              });
            }
            var plugin = {
              install
            };
            var GlobalVue = null;
            if (typeof window !== "undefined") {
              GlobalVue = window.Vue;
            } else if (typeof global !== "undefined") {
              GlobalVue = global.Vue;
            }
            if (GlobalVue) {
              GlobalVue.use(plugin);
            }
            __webpack_exports__["c"] = VueGridLayout;
          }).call(this, __webpack_require__("c8ba"));
        }
      ),
      /***/
      "2cef": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          module2.exports = function() {
            var idCount = 1;
            function generate2() {
              return idCount++;
            }
            return {
              generate: generate2
            };
          };
        }
      ),
      /***/
      "2d00": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var userAgent = __webpack_require__("342f");
          var process2 = global.process;
          var versions = process2 && process2.versions;
          var v8 = versions && versions.v8;
          var match, version;
          if (v8) {
            match = v8.split(".");
            version = match[0] + match[1];
          } else if (userAgent) {
            match = userAgent.match(/Edge\/(\d+)/);
            if (!match || match[1] >= 74) {
              match = userAgent.match(/Chrome\/(\d+)/);
              if (match) version = match[1];
            }
          }
          module2.exports = version && +version;
        }
      ),
      /***/
      "2ef0": (
        /***/
        function(module2, exports2, __webpack_require__) {
          (function(global, module3) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            ;
            (function() {
              var undefined2;
              var VERSION = "4.17.21";
              var LARGE_ARRAY_SIZE = 200;
              var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
              var HASH_UNDEFINED = "__lodash_hash_undefined__";
              var MAX_MEMOIZE_SIZE = 500;
              var PLACEHOLDER = "__lodash_placeholder__";
              var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
              var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
              var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
              var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
              var HOT_COUNT = 800, HOT_SPAN = 16;
              var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
              var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
              var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
              var wrapFlags = [
                ["ary", WRAP_ARY_FLAG],
                ["bind", WRAP_BIND_FLAG],
                ["bindKey", WRAP_BIND_KEY_FLAG],
                ["curry", WRAP_CURRY_FLAG],
                ["curryRight", WRAP_CURRY_RIGHT_FLAG],
                ["flip", WRAP_FLIP_FLAG],
                ["partial", WRAP_PARTIAL_FLAG],
                ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
                ["rearg", WRAP_REARG_FLAG]
              ];
              var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
              var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
              var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
              var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
              var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
              var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
              var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
              var reTrimStart = /^\s+/;
              var reWhitespace = /\s/;
              var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
              var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
              var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
              var reEscapeChar = /\\(\\)?/g;
              var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
              var reFlags = /\w*$/;
              var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
              var reIsBinary = /^0b[01]+$/i;
              var reIsHostCtor = /^\[object .+?Constructor\]$/;
              var reIsOctal = /^0o[0-7]+$/i;
              var reIsUint = /^(?:0|[1-9]\d*)$/;
              var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
              var reNoMatch = /($^)/;
              var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
              var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
              var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
              var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
              var reApos = RegExp(rsApos, "g");
              var reComboMark = RegExp(rsCombo, "g");
              var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
              var reUnicodeWord = RegExp([
                rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
                rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
                rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
                rsUpper + "+" + rsOptContrUpper,
                rsOrdUpper,
                rsOrdLower,
                rsDigits,
                rsEmoji
              ].join("|"), "g");
              var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
              var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
              var contextProps = [
                "Array",
                "Buffer",
                "DataView",
                "Date",
                "Error",
                "Float32Array",
                "Float64Array",
                "Function",
                "Int8Array",
                "Int16Array",
                "Int32Array",
                "Map",
                "Math",
                "Object",
                "Promise",
                "RegExp",
                "Set",
                "String",
                "Symbol",
                "TypeError",
                "Uint8Array",
                "Uint8ClampedArray",
                "Uint16Array",
                "Uint32Array",
                "WeakMap",
                "_",
                "clearTimeout",
                "isFinite",
                "parseInt",
                "setTimeout"
              ];
              var templateCounter = -1;
              var typedArrayTags = {};
              typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
              typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
              var cloneableTags = {};
              cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
              cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
              var deburredLetters = {
                // Latin-1 Supplement block.
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "c",
                "": "D",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "N",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "Y",
                "": "y",
                "": "y",
                "": "Ae",
                "": "ae",
                "": "Th",
                "": "th",
                "": "ss",
                // Latin Extended-A block.
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "D",
                "": "D",
                "": "d",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "H",
                "": "H",
                "": "h",
                "": "h",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "J",
                "": "j",
                "": "K",
                "": "k",
                "": "k",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "R",
                "": "R",
                "": "R",
                "": "r",
                "": "r",
                "": "r",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "T",
                "": "T",
                "": "T",
                "": "t",
                "": "t",
                "": "t",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "W",
                "": "w",
                "": "Y",
                "": "y",
                "": "Y",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "z",
                "": "z",
                "": "z",
                "": "IJ",
                "": "ij",
                "": "Oe",
                "": "oe",
                "": "'n",
                "": "s"
              };
              var htmlEscapes = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
              };
              var htmlUnescapes = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
              };
              var stringEscapes = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
              };
              var freeParseFloat = parseFloat, freeParseInt = parseInt;
              var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
              var freeSelf = typeof self == "object" && self && self.Object === Object && self;
              var root = freeGlobal || freeSelf || Function("return this")();
              var freeExports = exports2 && !exports2.nodeType && exports2;
              var freeModule = freeExports && typeof module3 == "object" && module3 && !module3.nodeType && module3;
              var moduleExports = freeModule && freeModule.exports === freeExports;
              var freeProcess = moduleExports && freeGlobal.process;
              var nodeUtil = function() {
                try {
                  var types = freeModule && freeModule.require && freeModule.require("util").types;
                  if (types) {
                    return types;
                  }
                  return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {
                }
              }();
              var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
              function apply(func, thisArg, args) {
                switch (args.length) {
                  case 0:
                    return func.call(thisArg);
                  case 1:
                    return func.call(thisArg, args[0]);
                  case 2:
                    return func.call(thisArg, args[0], args[1]);
                  case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
                }
                return func.apply(thisArg, args);
              }
              function arrayAggregator(array, setter, iteratee, accumulator) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  var value = array[index];
                  setter(accumulator, value, iteratee(value), array);
                }
                return accumulator;
              }
              function arrayEach(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (iteratee(array[index], index, array) === false) {
                    break;
                  }
                }
                return array;
              }
              function arrayEachRight(array, iteratee) {
                var length = array == null ? 0 : array.length;
                while (length--) {
                  if (iteratee(array[length], length, array) === false) {
                    break;
                  }
                }
                return array;
              }
              function arrayEvery(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (!predicate(array[index], index, array)) {
                    return false;
                  }
                }
                return true;
              }
              function arrayFilter(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }
              function arrayIncludes(array, value) {
                var length = array == null ? 0 : array.length;
                return !!length && baseIndexOf(array, value, 0) > -1;
              }
              function arrayIncludesWith(array, value, comparator) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (comparator(value, array[index])) {
                    return true;
                  }
                }
                return false;
              }
              function arrayMap(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                while (++index < length) {
                  result[index] = iteratee(array[index], index, array);
                }
                return result;
              }
              function arrayPush(array, values) {
                var index = -1, length = values.length, offset = array.length;
                while (++index < length) {
                  array[offset + index] = values[index];
                }
                return array;
              }
              function arrayReduce(array, iteratee, accumulator, initAccum) {
                var index = -1, length = array == null ? 0 : array.length;
                if (initAccum && length) {
                  accumulator = array[++index];
                }
                while (++index < length) {
                  accumulator = iteratee(accumulator, array[index], index, array);
                }
                return accumulator;
              }
              function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                var length = array == null ? 0 : array.length;
                if (initAccum && length) {
                  accumulator = array[--length];
                }
                while (length--) {
                  accumulator = iteratee(accumulator, array[length], length, array);
                }
                return accumulator;
              }
              function arraySome(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (predicate(array[index], index, array)) {
                    return true;
                  }
                }
                return false;
              }
              var asciiSize = baseProperty("length");
              function asciiToArray(string) {
                return string.split("");
              }
              function asciiWords(string) {
                return string.match(reAsciiWord) || [];
              }
              function baseFindKey(collection, predicate, eachFunc) {
                var result;
                eachFunc(collection, function(value, key, collection2) {
                  if (predicate(value, key, collection2)) {
                    result = key;
                    return false;
                  }
                });
                return result;
              }
              function baseFindIndex(array, predicate, fromIndex, fromRight) {
                var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                while (fromRight ? index-- : ++index < length) {
                  if (predicate(array[index], index, array)) {
                    return index;
                  }
                }
                return -1;
              }
              function baseIndexOf(array, value, fromIndex) {
                return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
              }
              function baseIndexOfWith(array, value, fromIndex, comparator) {
                var index = fromIndex - 1, length = array.length;
                while (++index < length) {
                  if (comparator(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              function baseIsNaN(value) {
                return value !== value;
              }
              function baseMean(array, iteratee) {
                var length = array == null ? 0 : array.length;
                return length ? baseSum(array, iteratee) / length : NAN;
              }
              function baseProperty(key) {
                return function(object) {
                  return object == null ? undefined2 : object[key];
                };
              }
              function basePropertyOf(object) {
                return function(key) {
                  return object == null ? undefined2 : object[key];
                };
              }
              function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                eachFunc(collection, function(value, index, collection2) {
                  accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
                });
                return accumulator;
              }
              function baseSortBy(array, comparer) {
                var length = array.length;
                array.sort(comparer);
                while (length--) {
                  array[length] = array[length].value;
                }
                return array;
              }
              function baseSum(array, iteratee) {
                var result, index = -1, length = array.length;
                while (++index < length) {
                  var current = iteratee(array[index]);
                  if (current !== undefined2) {
                    result = result === undefined2 ? current : result + current;
                  }
                }
                return result;
              }
              function baseTimes(n, iteratee) {
                var index = -1, result = Array(n);
                while (++index < n) {
                  result[index] = iteratee(index);
                }
                return result;
              }
              function baseToPairs(object, props) {
                return arrayMap(props, function(key) {
                  return [key, object[key]];
                });
              }
              function baseTrim(string) {
                return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
              }
              function baseUnary(func) {
                return function(value) {
                  return func(value);
                };
              }
              function baseValues(object, props) {
                return arrayMap(props, function(key) {
                  return object[key];
                });
              }
              function cacheHas(cache, key) {
                return cache.has(key);
              }
              function charsStartIndex(strSymbols, chrSymbols) {
                var index = -1, length = strSymbols.length;
                while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                }
                return index;
              }
              function charsEndIndex(strSymbols, chrSymbols) {
                var index = strSymbols.length;
                while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                }
                return index;
              }
              function countHolders(array, placeholder) {
                var length = array.length, result = 0;
                while (length--) {
                  if (array[length] === placeholder) {
                    ++result;
                  }
                }
                return result;
              }
              var deburrLetter = basePropertyOf(deburredLetters);
              var escapeHtmlChar = basePropertyOf(htmlEscapes);
              function escapeStringChar(chr) {
                return "\\" + stringEscapes[chr];
              }
              function getValue(object, key) {
                return object == null ? undefined2 : object[key];
              }
              function hasUnicode(string) {
                return reHasUnicode.test(string);
              }
              function hasUnicodeWord(string) {
                return reHasUnicodeWord.test(string);
              }
              function iteratorToArray(iterator) {
                var data, result = [];
                while (!(data = iterator.next()).done) {
                  result.push(data.value);
                }
                return result;
              }
              function mapToArray(map) {
                var index = -1, result = Array(map.size);
                map.forEach(function(value, key) {
                  result[++index] = [key, value];
                });
                return result;
              }
              function overArg(func, transform2) {
                return function(arg) {
                  return func(transform2(arg));
                };
              }
              function replaceHolders(array, placeholder) {
                var index = -1, length = array.length, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index];
                  if (value === placeholder || value === PLACEHOLDER) {
                    array[index] = PLACEHOLDER;
                    result[resIndex++] = index;
                  }
                }
                return result;
              }
              function setToArray(set) {
                var index = -1, result = Array(set.size);
                set.forEach(function(value) {
                  result[++index] = value;
                });
                return result;
              }
              function setToPairs(set) {
                var index = -1, result = Array(set.size);
                set.forEach(function(value) {
                  result[++index] = [value, value];
                });
                return result;
              }
              function strictIndexOf(array, value, fromIndex) {
                var index = fromIndex - 1, length = array.length;
                while (++index < length) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return -1;
              }
              function strictLastIndexOf(array, value, fromIndex) {
                var index = fromIndex + 1;
                while (index--) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return index;
              }
              function stringSize(string) {
                return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
              }
              function stringToArray(string) {
                return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
              }
              function trimmedEndIndex(string) {
                var index = string.length;
                while (index-- && reWhitespace.test(string.charAt(index))) {
                }
                return index;
              }
              var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
              function unicodeSize(string) {
                var result = reUnicode.lastIndex = 0;
                while (reUnicode.test(string)) {
                  ++result;
                }
                return result;
              }
              function unicodeToArray(string) {
                return string.match(reUnicode) || [];
              }
              function unicodeWords(string) {
                return string.match(reUnicodeWord) || [];
              }
              var runInContext = function runInContext2(context) {
                context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
                var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
                var coreJsData = context["__core-js_shared__"];
                var funcToString = funcProto.toString;
                var hasOwnProperty = objectProto.hasOwnProperty;
                var idCounter = 0;
                var maskSrcKey = function() {
                  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                  return uid ? "Symbol(src)_1." + uid : "";
                }();
                var nativeObjectToString = objectProto.toString;
                var objectCtorString = funcToString.call(Object2);
                var oldDash = root._;
                var reIsNative = RegExp2(
                  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
                );
                var Buffer = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
                var defineProperty = function() {
                  try {
                    var func = getNative(Object2, "defineProperty");
                    func({}, "", {});
                    return func;
                  } catch (e) {
                  }
                }();
                var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
                var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
                var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
                var metaMap = WeakMap2 && new WeakMap2();
                var realNames = {};
                var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
                var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
                function lodash(value) {
                  if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
                    if (value instanceof LodashWrapper) {
                      return value;
                    }
                    if (hasOwnProperty.call(value, "__wrapped__")) {
                      return wrapperClone(value);
                    }
                  }
                  return new LodashWrapper(value);
                }
                var baseCreate = /* @__PURE__ */ function() {
                  function object() {
                  }
                  return function(proto) {
                    if (!isObject2(proto)) {
                      return {};
                    }
                    if (objectCreate) {
                      return objectCreate(proto);
                    }
                    object.prototype = proto;
                    var result2 = new object();
                    object.prototype = undefined2;
                    return result2;
                  };
                }();
                function baseLodash() {
                }
                function LodashWrapper(value, chainAll) {
                  this.__wrapped__ = value;
                  this.__actions__ = [];
                  this.__chain__ = !!chainAll;
                  this.__index__ = 0;
                  this.__values__ = undefined2;
                }
                lodash.templateSettings = {
                  /**
                   * Used to detect `data` property values to be HTML-escaped.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  "escape": reEscape,
                  /**
                   * Used to detect code to be evaluated.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  "evaluate": reEvaluate,
                  /**
                   * Used to detect `data` property values to inject.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  "interpolate": reInterpolate,
                  /**
                   * Used to reference the data object in the template text.
                   *
                   * @memberOf _.templateSettings
                   * @type {string}
                   */
                  "variable": "",
                  /**
                   * Used to import variables into the compiled template.
                   *
                   * @memberOf _.templateSettings
                   * @type {Object}
                   */
                  "imports": {
                    /**
                     * A reference to the `lodash` function.
                     *
                     * @memberOf _.templateSettings.imports
                     * @type {Function}
                     */
                    "_": lodash
                  }
                };
                lodash.prototype = baseLodash.prototype;
                lodash.prototype.constructor = lodash;
                LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                LodashWrapper.prototype.constructor = LodashWrapper;
                function LazyWrapper(value) {
                  this.__wrapped__ = value;
                  this.__actions__ = [];
                  this.__dir__ = 1;
                  this.__filtered__ = false;
                  this.__iteratees__ = [];
                  this.__takeCount__ = MAX_ARRAY_LENGTH;
                  this.__views__ = [];
                }
                function lazyClone() {
                  var result2 = new LazyWrapper(this.__wrapped__);
                  result2.__actions__ = copyArray(this.__actions__);
                  result2.__dir__ = this.__dir__;
                  result2.__filtered__ = this.__filtered__;
                  result2.__iteratees__ = copyArray(this.__iteratees__);
                  result2.__takeCount__ = this.__takeCount__;
                  result2.__views__ = copyArray(this.__views__);
                  return result2;
                }
                function lazyReverse() {
                  if (this.__filtered__) {
                    var result2 = new LazyWrapper(this);
                    result2.__dir__ = -1;
                    result2.__filtered__ = true;
                  } else {
                    result2 = this.clone();
                    result2.__dir__ *= -1;
                  }
                  return result2;
                }
                function lazyValue() {
                  var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                  if (!isArr || !isRight && arrLength == length && takeCount == length) {
                    return baseWrapperValue(array, this.__actions__);
                  }
                  var result2 = [];
                  outer:
                    while (length-- && resIndex < takeCount) {
                      index += dir;
                      var iterIndex = -1, value = array[index];
                      while (++iterIndex < iterLength) {
                        var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                        if (type == LAZY_MAP_FLAG) {
                          value = computed;
                        } else if (!computed) {
                          if (type == LAZY_FILTER_FLAG) {
                            continue outer;
                          } else {
                            break outer;
                          }
                        }
                      }
                      result2[resIndex++] = value;
                    }
                  return result2;
                }
                LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                LazyWrapper.prototype.constructor = LazyWrapper;
                function Hash(entries) {
                  var index = -1, length = entries == null ? 0 : entries.length;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function hashClear() {
                  this.__data__ = nativeCreate ? nativeCreate(null) : {};
                  this.size = 0;
                }
                function hashDelete(key) {
                  var result2 = this.has(key) && delete this.__data__[key];
                  this.size -= result2 ? 1 : 0;
                  return result2;
                }
                function hashGet(key) {
                  var data = this.__data__;
                  if (nativeCreate) {
                    var result2 = data[key];
                    return result2 === HASH_UNDEFINED ? undefined2 : result2;
                  }
                  return hasOwnProperty.call(data, key) ? data[key] : undefined2;
                }
                function hashHas(key) {
                  var data = this.__data__;
                  return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
                }
                function hashSet(key, value) {
                  var data = this.__data__;
                  this.size += this.has(key) ? 0 : 1;
                  data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
                  return this;
                }
                Hash.prototype.clear = hashClear;
                Hash.prototype["delete"] = hashDelete;
                Hash.prototype.get = hashGet;
                Hash.prototype.has = hashHas;
                Hash.prototype.set = hashSet;
                function ListCache(entries) {
                  var index = -1, length = entries == null ? 0 : entries.length;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function listCacheClear() {
                  this.__data__ = [];
                  this.size = 0;
                }
                function listCacheDelete(key) {
                  var data = this.__data__, index = assocIndexOf(data, key);
                  if (index < 0) {
                    return false;
                  }
                  var lastIndex = data.length - 1;
                  if (index == lastIndex) {
                    data.pop();
                  } else {
                    splice.call(data, index, 1);
                  }
                  --this.size;
                  return true;
                }
                function listCacheGet(key) {
                  var data = this.__data__, index = assocIndexOf(data, key);
                  return index < 0 ? undefined2 : data[index][1];
                }
                function listCacheHas(key) {
                  return assocIndexOf(this.__data__, key) > -1;
                }
                function listCacheSet(key, value) {
                  var data = this.__data__, index = assocIndexOf(data, key);
                  if (index < 0) {
                    ++this.size;
                    data.push([key, value]);
                  } else {
                    data[index][1] = value;
                  }
                  return this;
                }
                ListCache.prototype.clear = listCacheClear;
                ListCache.prototype["delete"] = listCacheDelete;
                ListCache.prototype.get = listCacheGet;
                ListCache.prototype.has = listCacheHas;
                ListCache.prototype.set = listCacheSet;
                function MapCache(entries) {
                  var index = -1, length = entries == null ? 0 : entries.length;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function mapCacheClear() {
                  this.size = 0;
                  this.__data__ = {
                    "hash": new Hash(),
                    "map": new (Map2 || ListCache)(),
                    "string": new Hash()
                  };
                }
                function mapCacheDelete(key) {
                  var result2 = getMapData(this, key)["delete"](key);
                  this.size -= result2 ? 1 : 0;
                  return result2;
                }
                function mapCacheGet(key) {
                  return getMapData(this, key).get(key);
                }
                function mapCacheHas(key) {
                  return getMapData(this, key).has(key);
                }
                function mapCacheSet(key, value) {
                  var data = getMapData(this, key), size2 = data.size;
                  data.set(key, value);
                  this.size += data.size == size2 ? 0 : 1;
                  return this;
                }
                MapCache.prototype.clear = mapCacheClear;
                MapCache.prototype["delete"] = mapCacheDelete;
                MapCache.prototype.get = mapCacheGet;
                MapCache.prototype.has = mapCacheHas;
                MapCache.prototype.set = mapCacheSet;
                function SetCache(values2) {
                  var index = -1, length = values2 == null ? 0 : values2.length;
                  this.__data__ = new MapCache();
                  while (++index < length) {
                    this.add(values2[index]);
                  }
                }
                function setCacheAdd(value) {
                  this.__data__.set(value, HASH_UNDEFINED);
                  return this;
                }
                function setCacheHas(value) {
                  return this.__data__.has(value);
                }
                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                SetCache.prototype.has = setCacheHas;
                function Stack(entries) {
                  var data = this.__data__ = new ListCache(entries);
                  this.size = data.size;
                }
                function stackClear() {
                  this.__data__ = new ListCache();
                  this.size = 0;
                }
                function stackDelete(key) {
                  var data = this.__data__, result2 = data["delete"](key);
                  this.size = data.size;
                  return result2;
                }
                function stackGet(key) {
                  return this.__data__.get(key);
                }
                function stackHas(key) {
                  return this.__data__.has(key);
                }
                function stackSet(key, value) {
                  var data = this.__data__;
                  if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                      pairs.push([key, value]);
                      this.size = ++data.size;
                      return this;
                    }
                    data = this.__data__ = new MapCache(pairs);
                  }
                  data.set(key, value);
                  this.size = data.size;
                  return this;
                }
                Stack.prototype.clear = stackClear;
                Stack.prototype["delete"] = stackDelete;
                Stack.prototype.get = stackGet;
                Stack.prototype.has = stackHas;
                Stack.prototype.set = stackSet;
                function arrayLikeKeys(value, inherited) {
                  var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
                  for (var key in value) {
                    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                    isIndex(key, length)))) {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function arraySample(array) {
                  var length = array.length;
                  return length ? array[baseRandom(0, length - 1)] : undefined2;
                }
                function arraySampleSize(array, n) {
                  return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                }
                function arrayShuffle(array) {
                  return shuffleSelf(copyArray(array));
                }
                function assignMergeValue(object, key, value) {
                  if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
                    baseAssignValue(object, key, value);
                  }
                }
                function assignValue(object, key, value) {
                  var objValue = object[key];
                  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
                    baseAssignValue(object, key, value);
                  }
                }
                function assocIndexOf(array, key) {
                  var length = array.length;
                  while (length--) {
                    if (eq(array[length][0], key)) {
                      return length;
                    }
                  }
                  return -1;
                }
                function baseAggregator(collection, setter, iteratee2, accumulator) {
                  baseEach(collection, function(value, key, collection2) {
                    setter(accumulator, value, iteratee2(value), collection2);
                  });
                  return accumulator;
                }
                function baseAssign(object, source) {
                  return object && copyObject(source, keys(source), object);
                }
                function baseAssignIn(object, source) {
                  return object && copyObject(source, keysIn(source), object);
                }
                function baseAssignValue(object, key, value) {
                  if (key == "__proto__" && defineProperty) {
                    defineProperty(object, key, {
                      "configurable": true,
                      "enumerable": true,
                      "value": value,
                      "writable": true
                    });
                  } else {
                    object[key] = value;
                  }
                }
                function baseAt(object, paths) {
                  var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
                  while (++index < length) {
                    result2[index] = skip ? undefined2 : get(object, paths[index]);
                  }
                  return result2;
                }
                function baseClamp(number, lower, upper) {
                  if (number === number) {
                    if (upper !== undefined2) {
                      number = number <= upper ? number : upper;
                    }
                    if (lower !== undefined2) {
                      number = number >= lower ? number : lower;
                    }
                  }
                  return number;
                }
                function baseClone(value, bitmask, customizer, key, object, stack2) {
                  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                  if (customizer) {
                    result2 = object ? customizer(value, key, object, stack2) : customizer(value);
                  }
                  if (result2 !== undefined2) {
                    return result2;
                  }
                  if (!isObject2(value)) {
                    return value;
                  }
                  var isArr = isArray2(value);
                  if (isArr) {
                    result2 = initCloneArray(value);
                    if (!isDeep) {
                      return copyArray(value, result2);
                    }
                  } else {
                    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                    if (isBuffer(value)) {
                      return cloneBuffer(value, isDeep);
                    }
                    if (tag == objectTag || tag == argsTag || isFunc && !object) {
                      result2 = isFlat || isFunc ? {} : initCloneObject(value);
                      if (!isDeep) {
                        return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                      }
                    } else {
                      if (!cloneableTags[tag]) {
                        return object ? value : {};
                      }
                      result2 = initCloneByTag(value, tag, isDeep);
                    }
                  }
                  stack2 || (stack2 = new Stack());
                  var stacked = stack2.get(value);
                  if (stacked) {
                    return stacked;
                  }
                  stack2.set(value, result2);
                  if (isSet(value)) {
                    value.forEach(function(subValue) {
                      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
                    });
                  } else if (isMap(value)) {
                    value.forEach(function(subValue, key2) {
                      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
                    });
                  }
                  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                  var props = isArr ? undefined2 : keysFunc(value);
                  arrayEach(props || value, function(subValue, key2) {
                    if (props) {
                      key2 = subValue;
                      subValue = value[key2];
                    }
                    assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
                  });
                  return result2;
                }
                function baseConforms(source) {
                  var props = keys(source);
                  return function(object) {
                    return baseConformsTo(object, source, props);
                  };
                }
                function baseConformsTo(object, source, props) {
                  var length = props.length;
                  if (object == null) {
                    return !length;
                  }
                  object = Object2(object);
                  while (length--) {
                    var key = props[length], predicate = source[key], value = object[key];
                    if (value === undefined2 && !(key in object) || !predicate(value)) {
                      return false;
                    }
                  }
                  return true;
                }
                function baseDelay(func, wait, args) {
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  return setTimeout2(function() {
                    func.apply(undefined2, args);
                  }, wait);
                }
                function baseDifference(array, values2, iteratee2, comparator) {
                  var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
                  if (!length) {
                    return result2;
                  }
                  if (iteratee2) {
                    values2 = arrayMap(values2, baseUnary(iteratee2));
                  }
                  if (comparator) {
                    includes2 = arrayIncludesWith;
                    isCommon = false;
                  } else if (values2.length >= LARGE_ARRAY_SIZE) {
                    includes2 = cacheHas;
                    isCommon = false;
                    values2 = new SetCache(values2);
                  }
                  outer:
                    while (++index < length) {
                      var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                      value = comparator || value !== 0 ? value : 0;
                      if (isCommon && computed === computed) {
                        var valuesIndex = valuesLength;
                        while (valuesIndex--) {
                          if (values2[valuesIndex] === computed) {
                            continue outer;
                          }
                        }
                        result2.push(value);
                      } else if (!includes2(values2, computed, comparator)) {
                        result2.push(value);
                      }
                    }
                  return result2;
                }
                var baseEach = createBaseEach(baseForOwn);
                var baseEachRight = createBaseEach(baseForOwnRight, true);
                function baseEvery(collection, predicate) {
                  var result2 = true;
                  baseEach(collection, function(value, index, collection2) {
                    result2 = !!predicate(value, index, collection2);
                    return result2;
                  });
                  return result2;
                }
                function baseExtremum(array, iteratee2, comparator) {
                  var index = -1, length = array.length;
                  while (++index < length) {
                    var value = array[index], current = iteratee2(value);
                    if (current != null && (computed === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
                      var computed = current, result2 = value;
                    }
                  }
                  return result2;
                }
                function baseFill(array, value, start, end) {
                  var length = array.length;
                  start = toInteger(start);
                  if (start < 0) {
                    start = -start > length ? 0 : length + start;
                  }
                  end = end === undefined2 || end > length ? length : toInteger(end);
                  if (end < 0) {
                    end += length;
                  }
                  end = start > end ? 0 : toLength(end);
                  while (start < end) {
                    array[start++] = value;
                  }
                  return array;
                }
                function baseFilter(collection, predicate) {
                  var result2 = [];
                  baseEach(collection, function(value, index, collection2) {
                    if (predicate(value, index, collection2)) {
                      result2.push(value);
                    }
                  });
                  return result2;
                }
                function baseFlatten(array, depth, predicate, isStrict, result2) {
                  var index = -1, length = array.length;
                  predicate || (predicate = isFlattenable);
                  result2 || (result2 = []);
                  while (++index < length) {
                    var value = array[index];
                    if (depth > 0 && predicate(value)) {
                      if (depth > 1) {
                        baseFlatten(value, depth - 1, predicate, isStrict, result2);
                      } else {
                        arrayPush(result2, value);
                      }
                    } else if (!isStrict) {
                      result2[result2.length] = value;
                    }
                  }
                  return result2;
                }
                var baseFor = createBaseFor();
                var baseForRight = createBaseFor(true);
                function baseForOwn(object, iteratee2) {
                  return object && baseFor(object, iteratee2, keys);
                }
                function baseForOwnRight(object, iteratee2) {
                  return object && baseForRight(object, iteratee2, keys);
                }
                function baseFunctions(object, props) {
                  return arrayFilter(props, function(key) {
                    return isFunction(object[key]);
                  });
                }
                function baseGet(object, path) {
                  path = castPath(path, object);
                  var index = 0, length = path.length;
                  while (object != null && index < length) {
                    object = object[toKey(path[index++])];
                  }
                  return index && index == length ? object : undefined2;
                }
                function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                  var result2 = keysFunc(object);
                  return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
                }
                function baseGetTag(value) {
                  if (value == null) {
                    return value === undefined2 ? undefinedTag : nullTag;
                  }
                  return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
                }
                function baseGt(value, other) {
                  return value > other;
                }
                function baseHas(object, key) {
                  return object != null && hasOwnProperty.call(object, key);
                }
                function baseHasIn(object, key) {
                  return object != null && key in Object2(object);
                }
                function baseInRange(number, start, end) {
                  return number >= nativeMin(start, end) && number < nativeMax(start, end);
                }
                function baseIntersection(arrays, iteratee2, comparator) {
                  var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
                  while (othIndex--) {
                    var array = arrays[othIndex];
                    if (othIndex && iteratee2) {
                      array = arrayMap(array, baseUnary(iteratee2));
                    }
                    maxLength = nativeMin(array.length, maxLength);
                    caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
                  }
                  array = arrays[0];
                  var index = -1, seen2 = caches[0];
                  outer:
                    while (++index < length && result2.length < maxLength) {
                      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                      value = comparator || value !== 0 ? value : 0;
                      if (!(seen2 ? cacheHas(seen2, computed) : includes2(result2, computed, comparator))) {
                        othIndex = othLength;
                        while (--othIndex) {
                          var cache = caches[othIndex];
                          if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                            continue outer;
                          }
                        }
                        if (seen2) {
                          seen2.push(computed);
                        }
                        result2.push(value);
                      }
                    }
                  return result2;
                }
                function baseInverter(object, setter, iteratee2, accumulator) {
                  baseForOwn(object, function(value, key, object2) {
                    setter(accumulator, iteratee2(value), key, object2);
                  });
                  return accumulator;
                }
                function baseInvoke(object, path, args) {
                  path = castPath(path, object);
                  object = parent(object, path);
                  var func = object == null ? object : object[toKey(last(path))];
                  return func == null ? undefined2 : apply(func, object, args);
                }
                function baseIsArguments(value) {
                  return isObjectLike(value) && baseGetTag(value) == argsTag;
                }
                function baseIsArrayBuffer(value) {
                  return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                }
                function baseIsDate(value) {
                  return isObjectLike(value) && baseGetTag(value) == dateTag;
                }
                function baseIsEqual(value, other, bitmask, customizer, stack2) {
                  if (value === other) {
                    return true;
                  }
                  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                    return value !== value && other !== other;
                  }
                  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
                }
                function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
                  var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                  objTag = objTag == argsTag ? objectTag : objTag;
                  othTag = othTag == argsTag ? objectTag : othTag;
                  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                  if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) {
                      return false;
                    }
                    objIsArr = true;
                    objIsObj = false;
                  }
                  if (isSameTag && !objIsObj) {
                    stack2 || (stack2 = new Stack());
                    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
                  }
                  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                    if (objIsWrapped || othIsWrapped) {
                      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                      stack2 || (stack2 = new Stack());
                      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
                    }
                  }
                  if (!isSameTag) {
                    return false;
                  }
                  stack2 || (stack2 = new Stack());
                  return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
                }
                function baseIsMap(value) {
                  return isObjectLike(value) && getTag(value) == mapTag;
                }
                function baseIsMatch(object, source, matchData, customizer) {
                  var index = matchData.length, length = index, noCustomizer = !customizer;
                  if (object == null) {
                    return !length;
                  }
                  object = Object2(object);
                  while (index--) {
                    var data = matchData[index];
                    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                      return false;
                    }
                  }
                  while (++index < length) {
                    data = matchData[index];
                    var key = data[0], objValue = object[key], srcValue = data[1];
                    if (noCustomizer && data[2]) {
                      if (objValue === undefined2 && !(key in object)) {
                        return false;
                      }
                    } else {
                      var stack2 = new Stack();
                      if (customizer) {
                        var result2 = customizer(objValue, srcValue, key, object, source, stack2);
                      }
                      if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
                        return false;
                      }
                    }
                  }
                  return true;
                }
                function baseIsNative(value) {
                  if (!isObject2(value) || isMasked(value)) {
                    return false;
                  }
                  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                  return pattern.test(toSource(value));
                }
                function baseIsRegExp(value) {
                  return isObjectLike(value) && baseGetTag(value) == regexpTag;
                }
                function baseIsSet(value) {
                  return isObjectLike(value) && getTag(value) == setTag;
                }
                function baseIsTypedArray(value) {
                  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                }
                function baseIteratee(value) {
                  if (typeof value == "function") {
                    return value;
                  }
                  if (value == null) {
                    return identity;
                  }
                  if (typeof value == "object") {
                    return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                  }
                  return property(value);
                }
                function baseKeys(object) {
                  if (!isPrototype(object)) {
                    return nativeKeys(object);
                  }
                  var result2 = [];
                  for (var key in Object2(object)) {
                    if (hasOwnProperty.call(object, key) && key != "constructor") {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function baseKeysIn(object) {
                  if (!isObject2(object)) {
                    return nativeKeysIn(object);
                  }
                  var isProto = isPrototype(object), result2 = [];
                  for (var key in object) {
                    if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function baseLt(value, other) {
                  return value < other;
                }
                function baseMap(collection, iteratee2) {
                  var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                  baseEach(collection, function(value, key, collection2) {
                    result2[++index] = iteratee2(value, key, collection2);
                  });
                  return result2;
                }
                function baseMatches(source) {
                  var matchData = getMatchData(source);
                  if (matchData.length == 1 && matchData[0][2]) {
                    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                  }
                  return function(object) {
                    return object === source || baseIsMatch(object, source, matchData);
                  };
                }
                function baseMatchesProperty(path, srcValue) {
                  if (isKey(path) && isStrictComparable(srcValue)) {
                    return matchesStrictComparable(toKey(path), srcValue);
                  }
                  return function(object) {
                    var objValue = get(object, path);
                    return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                  };
                }
                function baseMerge(object, source, srcIndex, customizer, stack2) {
                  if (object === source) {
                    return;
                  }
                  baseFor(source, function(srcValue, key) {
                    stack2 || (stack2 = new Stack());
                    if (isObject2(srcValue)) {
                      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
                    } else {
                      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : undefined2;
                      if (newValue === undefined2) {
                        newValue = srcValue;
                      }
                      assignMergeValue(object, key, newValue);
                    }
                  }, keysIn);
                }
                function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
                  var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
                  if (stacked) {
                    assignMergeValue(object, key, stacked);
                    return;
                  }
                  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined2;
                  var isCommon = newValue === undefined2;
                  if (isCommon) {
                    var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                    newValue = srcValue;
                    if (isArr || isBuff || isTyped) {
                      if (isArray2(objValue)) {
                        newValue = objValue;
                      } else if (isArrayLikeObject(objValue)) {
                        newValue = copyArray(objValue);
                      } else if (isBuff) {
                        isCommon = false;
                        newValue = cloneBuffer(srcValue, true);
                      } else if (isTyped) {
                        isCommon = false;
                        newValue = cloneTypedArray(srcValue, true);
                      } else {
                        newValue = [];
                      }
                    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                      newValue = objValue;
                      if (isArguments(objValue)) {
                        newValue = toPlainObject(objValue);
                      } else if (!isObject2(objValue) || isFunction(objValue)) {
                        newValue = initCloneObject(srcValue);
                      }
                    } else {
                      isCommon = false;
                    }
                  }
                  if (isCommon) {
                    stack2.set(srcValue, newValue);
                    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
                    stack2["delete"](srcValue);
                  }
                  assignMergeValue(object, key, newValue);
                }
                function baseNth(array, n) {
                  var length = array.length;
                  if (!length) {
                    return;
                  }
                  n += n < 0 ? length : 0;
                  return isIndex(n, length) ? array[n] : undefined2;
                }
                function baseOrderBy(collection, iteratees, orders) {
                  if (iteratees.length) {
                    iteratees = arrayMap(iteratees, function(iteratee2) {
                      if (isArray2(iteratee2)) {
                        return function(value) {
                          return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                        };
                      }
                      return iteratee2;
                    });
                  } else {
                    iteratees = [identity];
                  }
                  var index = -1;
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                  var result2 = baseMap(collection, function(value, key, collection2) {
                    var criteria = arrayMap(iteratees, function(iteratee2) {
                      return iteratee2(value);
                    });
                    return { "criteria": criteria, "index": ++index, "value": value };
                  });
                  return baseSortBy(result2, function(object, other) {
                    return compareMultiple(object, other, orders);
                  });
                }
                function basePick(object, paths) {
                  return basePickBy(object, paths, function(value, path) {
                    return hasIn(object, path);
                  });
                }
                function basePickBy(object, paths, predicate) {
                  var index = -1, length = paths.length, result2 = {};
                  while (++index < length) {
                    var path = paths[index], value = baseGet(object, path);
                    if (predicate(value, path)) {
                      baseSet(result2, castPath(path, object), value);
                    }
                  }
                  return result2;
                }
                function basePropertyDeep(path) {
                  return function(object) {
                    return baseGet(object, path);
                  };
                }
                function basePullAll(array, values2, iteratee2, comparator) {
                  var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen2 = array;
                  if (array === values2) {
                    values2 = copyArray(values2);
                  }
                  if (iteratee2) {
                    seen2 = arrayMap(array, baseUnary(iteratee2));
                  }
                  while (++index < length) {
                    var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
                    while ((fromIndex = indexOf2(seen2, computed, fromIndex, comparator)) > -1) {
                      if (seen2 !== array) {
                        splice.call(seen2, fromIndex, 1);
                      }
                      splice.call(array, fromIndex, 1);
                    }
                  }
                  return array;
                }
                function basePullAt(array, indexes) {
                  var length = array ? indexes.length : 0, lastIndex = length - 1;
                  while (length--) {
                    var index = indexes[length];
                    if (length == lastIndex || index !== previous) {
                      var previous = index;
                      if (isIndex(index)) {
                        splice.call(array, index, 1);
                      } else {
                        baseUnset(array, index);
                      }
                    }
                  }
                  return array;
                }
                function baseRandom(lower, upper) {
                  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                }
                function baseRange(start, end, step, fromRight) {
                  var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
                  while (length--) {
                    result2[fromRight ? length : ++index] = start;
                    start += step;
                  }
                  return result2;
                }
                function baseRepeat(string, n) {
                  var result2 = "";
                  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                    return result2;
                  }
                  do {
                    if (n % 2) {
                      result2 += string;
                    }
                    n = nativeFloor(n / 2);
                    if (n) {
                      string += string;
                    }
                  } while (n);
                  return result2;
                }
                function baseRest(func, start) {
                  return setToString(overRest(func, start, identity), func + "");
                }
                function baseSample(collection) {
                  return arraySample(values(collection));
                }
                function baseSampleSize(collection, n) {
                  var array = values(collection);
                  return shuffleSelf(array, baseClamp(n, 0, array.length));
                }
                function baseSet(object, path, value, customizer) {
                  if (!isObject2(object)) {
                    return object;
                  }
                  path = castPath(path, object);
                  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                  while (nested != null && ++index < length) {
                    var key = toKey(path[index]), newValue = value;
                    if (key === "__proto__" || key === "constructor" || key === "prototype") {
                      return object;
                    }
                    if (index != lastIndex) {
                      var objValue = nested[key];
                      newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                      if (newValue === undefined2) {
                        newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                      }
                    }
                    assignValue(nested, key, newValue);
                    nested = nested[key];
                  }
                  return object;
                }
                var baseSetData = !metaMap ? identity : function(func, data) {
                  metaMap.set(func, data);
                  return func;
                };
                var baseSetToString = !defineProperty ? identity : function(func, string) {
                  return defineProperty(func, "toString", {
                    "configurable": true,
                    "enumerable": false,
                    "value": constant(string),
                    "writable": true
                  });
                };
                function baseShuffle(collection) {
                  return shuffleSelf(values(collection));
                }
                function baseSlice(array, start, end) {
                  var index = -1, length = array.length;
                  if (start < 0) {
                    start = -start > length ? 0 : length + start;
                  }
                  end = end > length ? length : end;
                  if (end < 0) {
                    end += length;
                  }
                  length = start > end ? 0 : end - start >>> 0;
                  start >>>= 0;
                  var result2 = Array2(length);
                  while (++index < length) {
                    result2[index] = array[index + start];
                  }
                  return result2;
                }
                function baseSome(collection, predicate) {
                  var result2;
                  baseEach(collection, function(value, index, collection2) {
                    result2 = predicate(value, index, collection2);
                    return !result2;
                  });
                  return !!result2;
                }
                function baseSortedIndex(array, value, retHighest) {
                  var low = 0, high = array == null ? low : array.length;
                  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                    while (low < high) {
                      var mid = low + high >>> 1, computed = array[mid];
                      if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
                        low = mid + 1;
                      } else {
                        high = mid;
                      }
                    }
                    return high;
                  }
                  return baseSortedIndexBy(array, value, identity, retHighest);
                }
                function baseSortedIndexBy(array, value, iteratee2, retHighest) {
                  var low = 0, high = array == null ? 0 : array.length;
                  if (high === 0) {
                    return 0;
                  }
                  value = iteratee2(value);
                  var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined2;
                  while (low < high) {
                    var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
                    if (valIsNaN) {
                      var setLow = retHighest || othIsReflexive;
                    } else if (valIsUndefined) {
                      setLow = othIsReflexive && (retHighest || othIsDefined);
                    } else if (valIsNull) {
                      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                    } else if (valIsSymbol) {
                      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                    } else if (othIsNull || othIsSymbol) {
                      setLow = false;
                    } else {
                      setLow = retHighest ? computed <= value : computed < value;
                    }
                    if (setLow) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return nativeMin(high, MAX_ARRAY_INDEX);
                }
                function baseSortedUniq(array, iteratee2) {
                  var index = -1, length = array.length, resIndex = 0, result2 = [];
                  while (++index < length) {
                    var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                    if (!index || !eq(computed, seen2)) {
                      var seen2 = computed;
                      result2[resIndex++] = value === 0 ? 0 : value;
                    }
                  }
                  return result2;
                }
                function baseToNumber(value) {
                  if (typeof value == "number") {
                    return value;
                  }
                  if (isSymbol2(value)) {
                    return NAN;
                  }
                  return +value;
                }
                function baseToString(value) {
                  if (typeof value == "string") {
                    return value;
                  }
                  if (isArray2(value)) {
                    return arrayMap(value, baseToString) + "";
                  }
                  if (isSymbol2(value)) {
                    return symbolToString ? symbolToString.call(value) : "";
                  }
                  var result2 = value + "";
                  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
                }
                function baseUniq(array, iteratee2, comparator) {
                  var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen2 = result2;
                  if (comparator) {
                    isCommon = false;
                    includes2 = arrayIncludesWith;
                  } else if (length >= LARGE_ARRAY_SIZE) {
                    var set2 = iteratee2 ? null : createSet(array);
                    if (set2) {
                      return setToArray(set2);
                    }
                    isCommon = false;
                    includes2 = cacheHas;
                    seen2 = new SetCache();
                  } else {
                    seen2 = iteratee2 ? [] : result2;
                  }
                  outer:
                    while (++index < length) {
                      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                      value = comparator || value !== 0 ? value : 0;
                      if (isCommon && computed === computed) {
                        var seenIndex = seen2.length;
                        while (seenIndex--) {
                          if (seen2[seenIndex] === computed) {
                            continue outer;
                          }
                        }
                        if (iteratee2) {
                          seen2.push(computed);
                        }
                        result2.push(value);
                      } else if (!includes2(seen2, computed, comparator)) {
                        if (seen2 !== result2) {
                          seen2.push(computed);
                        }
                        result2.push(value);
                      }
                    }
                  return result2;
                }
                function baseUnset(object, path) {
                  path = castPath(path, object);
                  object = parent(object, path);
                  return object == null || delete object[toKey(last(path))];
                }
                function baseUpdate(object, path, updater, customizer) {
                  return baseSet(object, path, updater(baseGet(object, path)), customizer);
                }
                function baseWhile(array, predicate, isDrop, fromRight) {
                  var length = array.length, index = fromRight ? length : -1;
                  while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                  }
                  return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
                }
                function baseWrapperValue(value, actions) {
                  var result2 = value;
                  if (result2 instanceof LazyWrapper) {
                    result2 = result2.value();
                  }
                  return arrayReduce(actions, function(result3, action) {
                    return action.func.apply(action.thisArg, arrayPush([result3], action.args));
                  }, result2);
                }
                function baseXor(arrays, iteratee2, comparator) {
                  var length = arrays.length;
                  if (length < 2) {
                    return length ? baseUniq(arrays[0]) : [];
                  }
                  var index = -1, result2 = Array2(length);
                  while (++index < length) {
                    var array = arrays[index], othIndex = -1;
                    while (++othIndex < length) {
                      if (othIndex != index) {
                        result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                      }
                    }
                  }
                  return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
                }
                function baseZipObject(props, values2, assignFunc) {
                  var index = -1, length = props.length, valsLength = values2.length, result2 = {};
                  while (++index < length) {
                    var value = index < valsLength ? values2[index] : undefined2;
                    assignFunc(result2, props[index], value);
                  }
                  return result2;
                }
                function castArrayLikeObject(value) {
                  return isArrayLikeObject(value) ? value : [];
                }
                function castFunction(value) {
                  return typeof value == "function" ? value : identity;
                }
                function castPath(value, object) {
                  if (isArray2(value)) {
                    return value;
                  }
                  return isKey(value, object) ? [value] : stringToPath(toString(value));
                }
                var castRest = baseRest;
                function castSlice(array, start, end) {
                  var length = array.length;
                  end = end === undefined2 ? length : end;
                  return !start && end >= length ? array : baseSlice(array, start, end);
                }
                var clearTimeout2 = ctxClearTimeout || function(id) {
                  return root.clearTimeout(id);
                };
                function cloneBuffer(buffer, isDeep) {
                  if (isDeep) {
                    return buffer.slice();
                  }
                  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                  buffer.copy(result2);
                  return result2;
                }
                function cloneArrayBuffer(arrayBuffer) {
                  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                  new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
                  return result2;
                }
                function cloneDataView(dataView, isDeep) {
                  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                }
                function cloneRegExp(regexp) {
                  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                  result2.lastIndex = regexp.lastIndex;
                  return result2;
                }
                function cloneSymbol(symbol) {
                  return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
                }
                function cloneTypedArray(typedArray, isDeep) {
                  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                }
                function compareAscending(value, other) {
                  if (value !== other) {
                    var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
                    var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
                    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                      return 1;
                    }
                    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                      return -1;
                    }
                  }
                  return 0;
                }
                function compareMultiple(object, other, orders) {
                  var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                  while (++index < length) {
                    var result2 = compareAscending(objCriteria[index], othCriteria[index]);
                    if (result2) {
                      if (index >= ordersLength) {
                        return result2;
                      }
                      var order = orders[index];
                      return result2 * (order == "desc" ? -1 : 1);
                    }
                  }
                  return object.index - other.index;
                }
                function composeArgs(args, partials, holders, isCurried) {
                  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
                  while (++leftIndex < leftLength) {
                    result2[leftIndex] = partials[leftIndex];
                  }
                  while (++argsIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                      result2[holders[argsIndex]] = args[argsIndex];
                    }
                  }
                  while (rangeLength--) {
                    result2[leftIndex++] = args[argsIndex++];
                  }
                  return result2;
                }
                function composeArgsRight(args, partials, holders, isCurried) {
                  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
                  while (++argsIndex < rangeLength) {
                    result2[argsIndex] = args[argsIndex];
                  }
                  var offset = argsIndex;
                  while (++rightIndex < rightLength) {
                    result2[offset + rightIndex] = partials[rightIndex];
                  }
                  while (++holdersIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                      result2[offset + holders[holdersIndex]] = args[argsIndex++];
                    }
                  }
                  return result2;
                }
                function copyArray(source, array) {
                  var index = -1, length = source.length;
                  array || (array = Array2(length));
                  while (++index < length) {
                    array[index] = source[index];
                  }
                  return array;
                }
                function copyObject(source, props, object, customizer) {
                  var isNew = !object;
                  object || (object = {});
                  var index = -1, length = props.length;
                  while (++index < length) {
                    var key = props[index];
                    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
                    if (newValue === undefined2) {
                      newValue = source[key];
                    }
                    if (isNew) {
                      baseAssignValue(object, key, newValue);
                    } else {
                      assignValue(object, key, newValue);
                    }
                  }
                  return object;
                }
                function copySymbols(source, object) {
                  return copyObject(source, getSymbols(source), object);
                }
                function copySymbolsIn(source, object) {
                  return copyObject(source, getSymbolsIn(source), object);
                }
                function createAggregator(setter, initializer) {
                  return function(collection, iteratee2) {
                    var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                    return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
                  };
                }
                function createAssigner(assigner) {
                  return baseRest(function(object, sources) {
                    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
                    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
                    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                      customizer = length < 3 ? undefined2 : customizer;
                      length = 1;
                    }
                    object = Object2(object);
                    while (++index < length) {
                      var source = sources[index];
                      if (source) {
                        assigner(object, source, index, customizer);
                      }
                    }
                    return object;
                  });
                }
                function createBaseEach(eachFunc, fromRight) {
                  return function(collection, iteratee2) {
                    if (collection == null) {
                      return collection;
                    }
                    if (!isArrayLike(collection)) {
                      return eachFunc(collection, iteratee2);
                    }
                    var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
                    while (fromRight ? index-- : ++index < length) {
                      if (iteratee2(iterable[index], index, iterable) === false) {
                        break;
                      }
                    }
                    return collection;
                  };
                }
                function createBaseFor(fromRight) {
                  return function(object, iteratee2, keysFunc) {
                    var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
                    while (length--) {
                      var key = props[fromRight ? length : ++index];
                      if (iteratee2(iterable[key], key, iterable) === false) {
                        break;
                      }
                    }
                    return object;
                  };
                }
                function createBind(func, bitmask, thisArg) {
                  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                  function wrapper() {
                    var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                    return fn.apply(isBind ? thisArg : this, arguments);
                  }
                  return wrapper;
                }
                function createCaseFirst(methodName) {
                  return function(string) {
                    string = toString(string);
                    var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
                    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                    return chr[methodName]() + trailing;
                  };
                }
                function createCompounder(callback) {
                  return function(string) {
                    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                  };
                }
                function createCtor(Ctor) {
                  return function() {
                    var args = arguments;
                    switch (args.length) {
                      case 0:
                        return new Ctor();
                      case 1:
                        return new Ctor(args[0]);
                      case 2:
                        return new Ctor(args[0], args[1]);
                      case 3:
                        return new Ctor(args[0], args[1], args[2]);
                      case 4:
                        return new Ctor(args[0], args[1], args[2], args[3]);
                      case 5:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                      case 6:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                      case 7:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                    }
                    var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
                    return isObject2(result2) ? result2 : thisBinding;
                  };
                }
                function createCurry(func, bitmask, arity) {
                  var Ctor = createCtor(func);
                  function wrapper() {
                    var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
                    while (index--) {
                      args[index] = arguments[index];
                    }
                    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                    length -= holders.length;
                    if (length < arity) {
                      return createRecurry(
                        func,
                        bitmask,
                        createHybrid,
                        wrapper.placeholder,
                        undefined2,
                        args,
                        holders,
                        undefined2,
                        undefined2,
                        arity - length
                      );
                    }
                    var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                    return apply(fn, this, args);
                  }
                  return wrapper;
                }
                function createFind(findIndexFunc) {
                  return function(collection, predicate, fromIndex) {
                    var iterable = Object2(collection);
                    if (!isArrayLike(collection)) {
                      var iteratee2 = getIteratee(predicate, 3);
                      collection = keys(collection);
                      predicate = function(key) {
                        return iteratee2(iterable[key], key, iterable);
                      };
                    }
                    var index = findIndexFunc(collection, predicate, fromIndex);
                    return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
                  };
                }
                function createFlow(fromRight) {
                  return flatRest(function(funcs) {
                    var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                    if (fromRight) {
                      funcs.reverse();
                    }
                    while (index--) {
                      var func = funcs[index];
                      if (typeof func != "function") {
                        throw new TypeError2(FUNC_ERROR_TEXT);
                      }
                      if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                        var wrapper = new LodashWrapper([], true);
                      }
                    }
                    index = wrapper ? index : length;
                    while (++index < length) {
                      func = funcs[index];
                      var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                      if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                      } else {
                        wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                      }
                    }
                    return function() {
                      var args = arguments, value = args[0];
                      if (wrapper && args.length == 1 && isArray2(value)) {
                        return wrapper.plant(value).value();
                      }
                      var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                      while (++index2 < length) {
                        result2 = funcs[index2].call(this, result2);
                      }
                      return result2;
                    };
                  });
                }
                function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
                  var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
                  function wrapper() {
                    var length = arguments.length, args = Array2(length), index = length;
                    while (index--) {
                      args[index] = arguments[index];
                    }
                    if (isCurried) {
                      var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                    }
                    if (partials) {
                      args = composeArgs(args, partials, holders, isCurried);
                    }
                    if (partialsRight) {
                      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                    }
                    length -= holdersCount;
                    if (isCurried && length < arity) {
                      var newHolders = replaceHolders(args, placeholder);
                      return createRecurry(
                        func,
                        bitmask,
                        createHybrid,
                        wrapper.placeholder,
                        thisArg,
                        args,
                        newHolders,
                        argPos,
                        ary2,
                        arity - length
                      );
                    }
                    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                    length = args.length;
                    if (argPos) {
                      args = reorder(args, argPos);
                    } else if (isFlip && length > 1) {
                      args.reverse();
                    }
                    if (isAry && ary2 < length) {
                      args.length = ary2;
                    }
                    if (this && this !== root && this instanceof wrapper) {
                      fn = Ctor || createCtor(fn);
                    }
                    return fn.apply(thisBinding, args);
                  }
                  return wrapper;
                }
                function createInverter(setter, toIteratee) {
                  return function(object, iteratee2) {
                    return baseInverter(object, setter, toIteratee(iteratee2), {});
                  };
                }
                function createMathOperation(operator, defaultValue) {
                  return function(value, other) {
                    var result2;
                    if (value === undefined2 && other === undefined2) {
                      return defaultValue;
                    }
                    if (value !== undefined2) {
                      result2 = value;
                    }
                    if (other !== undefined2) {
                      if (result2 === undefined2) {
                        return other;
                      }
                      if (typeof value == "string" || typeof other == "string") {
                        value = baseToString(value);
                        other = baseToString(other);
                      } else {
                        value = baseToNumber(value);
                        other = baseToNumber(other);
                      }
                      result2 = operator(value, other);
                    }
                    return result2;
                  };
                }
                function createOver(arrayFunc) {
                  return flatRest(function(iteratees) {
                    iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                    return baseRest(function(args) {
                      var thisArg = this;
                      return arrayFunc(iteratees, function(iteratee2) {
                        return apply(iteratee2, thisArg, args);
                      });
                    });
                  });
                }
                function createPadding(length, chars) {
                  chars = chars === undefined2 ? " " : baseToString(chars);
                  var charsLength = chars.length;
                  if (charsLength < 2) {
                    return charsLength ? baseRepeat(chars, length) : chars;
                  }
                  var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                  return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
                }
                function createPartial(func, bitmask, thisArg, partials) {
                  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                  function wrapper() {
                    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                    while (++leftIndex < leftLength) {
                      args[leftIndex] = partials[leftIndex];
                    }
                    while (argsLength--) {
                      args[leftIndex++] = arguments[++argsIndex];
                    }
                    return apply(fn, isBind ? thisArg : this, args);
                  }
                  return wrapper;
                }
                function createRange(fromRight) {
                  return function(start, end, step) {
                    if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                      end = step = undefined2;
                    }
                    start = toFinite(start);
                    if (end === undefined2) {
                      end = start;
                      start = 0;
                    } else {
                      end = toFinite(end);
                    }
                    step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
                    return baseRange(start, end, step, fromRight);
                  };
                }
                function createRelationalOperation(operator) {
                  return function(value, other) {
                    if (!(typeof value == "string" && typeof other == "string")) {
                      value = toNumber(value);
                      other = toNumber(other);
                    }
                    return operator(value, other);
                  };
                }
                function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
                  var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
                  bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                    bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                  }
                  var newData = [
                    func,
                    bitmask,
                    thisArg,
                    newPartials,
                    newHolders,
                    newPartialsRight,
                    newHoldersRight,
                    argPos,
                    ary2,
                    arity
                  ];
                  var result2 = wrapFunc.apply(undefined2, newData);
                  if (isLaziable(func)) {
                    setData(result2, newData);
                  }
                  result2.placeholder = placeholder;
                  return setWrapToString(result2, func, bitmask);
                }
                function createRound(methodName) {
                  var func = Math2[methodName];
                  return function(number, precision) {
                    number = toNumber(number);
                    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                    if (precision && nativeIsFinite(number)) {
                      var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                      pair = (toString(value) + "e").split("e");
                      return +(pair[0] + "e" + (+pair[1] - precision));
                    }
                    return func(number);
                  };
                }
                var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
                  return new Set2(values2);
                };
                function createToPairs(keysFunc) {
                  return function(object) {
                    var tag = getTag(object);
                    if (tag == mapTag) {
                      return mapToArray(object);
                    }
                    if (tag == setTag) {
                      return setToPairs(object);
                    }
                    return baseToPairs(object, keysFunc(object));
                  };
                }
                function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
                  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                  if (!isBindKey && typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  var length = partials ? partials.length : 0;
                  if (!length) {
                    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                    partials = holders = undefined2;
                  }
                  ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
                  arity = arity === undefined2 ? arity : toInteger(arity);
                  length -= holders ? holders.length : 0;
                  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                    var partialsRight = partials, holdersRight = holders;
                    partials = holders = undefined2;
                  }
                  var data = isBindKey ? undefined2 : getData(func);
                  var newData = [
                    func,
                    bitmask,
                    thisArg,
                    partials,
                    holders,
                    partialsRight,
                    holdersRight,
                    argPos,
                    ary2,
                    arity
                  ];
                  if (data) {
                    mergeData(newData, data);
                  }
                  func = newData[0];
                  bitmask = newData[1];
                  thisArg = newData[2];
                  partials = newData[3];
                  holders = newData[4];
                  arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                  }
                  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                    var result2 = createBind(func, bitmask, thisArg);
                  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                    result2 = createCurry(func, bitmask, arity);
                  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                    result2 = createPartial(func, bitmask, thisArg, partials);
                  } else {
                    result2 = createHybrid.apply(undefined2, newData);
                  }
                  var setter = data ? baseSetData : setData;
                  return setWrapToString(setter(result2, newData), func, bitmask);
                }
                function customDefaultsAssignIn(objValue, srcValue, key, object) {
                  if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                    return srcValue;
                  }
                  return objValue;
                }
                function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
                  if (isObject2(objValue) && isObject2(srcValue)) {
                    stack2.set(srcValue, objValue);
                    baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack2);
                    stack2["delete"](srcValue);
                  }
                  return objValue;
                }
                function customOmitClone(value) {
                  return isPlainObject(value) ? undefined2 : value;
                }
                function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
                  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                    return false;
                  }
                  var arrStacked = stack2.get(array);
                  var othStacked = stack2.get(other);
                  if (arrStacked && othStacked) {
                    return arrStacked == other && othStacked == array;
                  }
                  var index = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
                  stack2.set(array, other);
                  stack2.set(other, array);
                  while (++index < arrLength) {
                    var arrValue = array[index], othValue = other[index];
                    if (customizer) {
                      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
                    }
                    if (compared !== undefined2) {
                      if (compared) {
                        continue;
                      }
                      result2 = false;
                      break;
                    }
                    if (seen2) {
                      if (!arraySome(other, function(othValue2, othIndex) {
                        if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                          return seen2.push(othIndex);
                        }
                      })) {
                        result2 = false;
                        break;
                      }
                    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
                      result2 = false;
                      break;
                    }
                  }
                  stack2["delete"](array);
                  stack2["delete"](other);
                  return result2;
                }
                function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
                  switch (tag) {
                    case dataViewTag:
                      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                        return false;
                      }
                      object = object.buffer;
                      other = other.buffer;
                    case arrayBufferTag:
                      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                        return false;
                      }
                      return true;
                    case boolTag:
                    case dateTag:
                    case numberTag:
                      return eq(+object, +other);
                    case errorTag:
                      return object.name == other.name && object.message == other.message;
                    case regexpTag:
                    case stringTag:
                      return object == other + "";
                    case mapTag:
                      var convert = mapToArray;
                    case setTag:
                      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                      convert || (convert = setToArray);
                      if (object.size != other.size && !isPartial) {
                        return false;
                      }
                      var stacked = stack2.get(object);
                      if (stacked) {
                        return stacked == other;
                      }
                      bitmask |= COMPARE_UNORDERED_FLAG;
                      stack2.set(object, other);
                      var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
                      stack2["delete"](object);
                      return result2;
                    case symbolTag:
                      if (symbolValueOf) {
                        return symbolValueOf.call(object) == symbolValueOf.call(other);
                      }
                  }
                  return false;
                }
                function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
                  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                  if (objLength != othLength && !isPartial) {
                    return false;
                  }
                  var index = objLength;
                  while (index--) {
                    var key = objProps[index];
                    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                      return false;
                    }
                  }
                  var objStacked = stack2.get(object);
                  var othStacked = stack2.get(other);
                  if (objStacked && othStacked) {
                    return objStacked == other && othStacked == object;
                  }
                  var result2 = true;
                  stack2.set(object, other);
                  stack2.set(other, object);
                  var skipCtor = isPartial;
                  while (++index < objLength) {
                    key = objProps[index];
                    var objValue = object[key], othValue = other[key];
                    if (customizer) {
                      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
                    }
                    if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
                      result2 = false;
                      break;
                    }
                    skipCtor || (skipCtor = key == "constructor");
                  }
                  if (result2 && !skipCtor) {
                    var objCtor = object.constructor, othCtor = other.constructor;
                    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                      result2 = false;
                    }
                  }
                  stack2["delete"](object);
                  stack2["delete"](other);
                  return result2;
                }
                function flatRest(func) {
                  return setToString(overRest(func, undefined2, flatten), func + "");
                }
                function getAllKeys(object) {
                  return baseGetAllKeys(object, keys, getSymbols);
                }
                function getAllKeysIn(object) {
                  return baseGetAllKeys(object, keysIn, getSymbolsIn);
                }
                var getData = !metaMap ? noop : function(func) {
                  return metaMap.get(func);
                };
                function getFuncName(func) {
                  var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
                  while (length--) {
                    var data = array[length], otherFunc = data.func;
                    if (otherFunc == null || otherFunc == func) {
                      return data.name;
                    }
                  }
                  return result2;
                }
                function getHolder(func) {
                  var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
                  return object.placeholder;
                }
                function getIteratee() {
                  var result2 = lodash.iteratee || iteratee;
                  result2 = result2 === iteratee ? baseIteratee : result2;
                  return arguments.length ? result2(arguments[0], arguments[1]) : result2;
                }
                function getMapData(map2, key) {
                  var data = map2.__data__;
                  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
                }
                function getMatchData(object) {
                  var result2 = keys(object), length = result2.length;
                  while (length--) {
                    var key = result2[length], value = object[key];
                    result2[length] = [key, value, isStrictComparable(value)];
                  }
                  return result2;
                }
                function getNative(object, key) {
                  var value = getValue(object, key);
                  return baseIsNative(value) ? value : undefined2;
                }
                function getRawTag(value) {
                  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                  try {
                    value[symToStringTag] = undefined2;
                    var unmasked = true;
                  } catch (e) {
                  }
                  var result2 = nativeObjectToString.call(value);
                  if (unmasked) {
                    if (isOwn) {
                      value[symToStringTag] = tag;
                    } else {
                      delete value[symToStringTag];
                    }
                  }
                  return result2;
                }
                var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                  if (object == null) {
                    return [];
                  }
                  object = Object2(object);
                  return arrayFilter(nativeGetSymbols(object), function(symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                  });
                };
                var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                  var result2 = [];
                  while (object) {
                    arrayPush(result2, getSymbols(object));
                    object = getPrototype(object);
                  }
                  return result2;
                };
                var getTag = baseGetTag;
                if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
                  getTag = function(value) {
                    var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
                    if (ctorString) {
                      switch (ctorString) {
                        case dataViewCtorString:
                          return dataViewTag;
                        case mapCtorString:
                          return mapTag;
                        case promiseCtorString:
                          return promiseTag;
                        case setCtorString:
                          return setTag;
                        case weakMapCtorString:
                          return weakMapTag;
                      }
                    }
                    return result2;
                  };
                }
                function getView(start, end, transforms) {
                  var index = -1, length = transforms.length;
                  while (++index < length) {
                    var data = transforms[index], size2 = data.size;
                    switch (data.type) {
                      case "drop":
                        start += size2;
                        break;
                      case "dropRight":
                        end -= size2;
                        break;
                      case "take":
                        end = nativeMin(end, start + size2);
                        break;
                      case "takeRight":
                        start = nativeMax(start, end - size2);
                        break;
                    }
                  }
                  return { "start": start, "end": end };
                }
                function getWrapDetails(source) {
                  var match = source.match(reWrapDetails);
                  return match ? match[1].split(reSplitDetails) : [];
                }
                function hasPath(object, path, hasFunc) {
                  path = castPath(path, object);
                  var index = -1, length = path.length, result2 = false;
                  while (++index < length) {
                    var key = toKey(path[index]);
                    if (!(result2 = object != null && hasFunc(object, key))) {
                      break;
                    }
                    object = object[key];
                  }
                  if (result2 || ++index != length) {
                    return result2;
                  }
                  length = object == null ? 0 : object.length;
                  return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
                }
                function initCloneArray(array) {
                  var length = array.length, result2 = new array.constructor(length);
                  if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                    result2.index = array.index;
                    result2.input = array.input;
                  }
                  return result2;
                }
                function initCloneObject(object) {
                  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
                }
                function initCloneByTag(object, tag, isDeep) {
                  var Ctor = object.constructor;
                  switch (tag) {
                    case arrayBufferTag:
                      return cloneArrayBuffer(object);
                    case boolTag:
                    case dateTag:
                      return new Ctor(+object);
                    case dataViewTag:
                      return cloneDataView(object, isDeep);
                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                      return cloneTypedArray(object, isDeep);
                    case mapTag:
                      return new Ctor();
                    case numberTag:
                    case stringTag:
                      return new Ctor(object);
                    case regexpTag:
                      return cloneRegExp(object);
                    case setTag:
                      return new Ctor();
                    case symbolTag:
                      return cloneSymbol(object);
                  }
                }
                function insertWrapDetails(source, details) {
                  var length = details.length;
                  if (!length) {
                    return source;
                  }
                  var lastIndex = length - 1;
                  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                  details = details.join(length > 2 ? ", " : " ");
                  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
                }
                function isFlattenable(value) {
                  return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
                }
                function isIndex(value, length) {
                  var type = typeof value;
                  length = length == null ? MAX_SAFE_INTEGER : length;
                  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
                }
                function isIterateeCall(value, index, object) {
                  if (!isObject2(object)) {
                    return false;
                  }
                  var type = typeof index;
                  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                    return eq(object[index], value);
                  }
                  return false;
                }
                function isKey(value, object) {
                  if (isArray2(value)) {
                    return false;
                  }
                  var type = typeof value;
                  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
                    return true;
                  }
                  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
                }
                function isKeyable(value) {
                  var type = typeof value;
                  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
                }
                function isLaziable(func) {
                  var funcName = getFuncName(func), other = lodash[funcName];
                  if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                    return false;
                  }
                  if (func === other) {
                    return true;
                  }
                  var data = getData(other);
                  return !!data && func === data[0];
                }
                function isMasked(func) {
                  return !!maskSrcKey && maskSrcKey in func;
                }
                var isMaskable = coreJsData ? isFunction : stubFalse;
                function isPrototype(value) {
                  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                  return value === proto;
                }
                function isStrictComparable(value) {
                  return value === value && !isObject2(value);
                }
                function matchesStrictComparable(key, srcValue) {
                  return function(object) {
                    if (object == null) {
                      return false;
                    }
                    return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
                  };
                }
                function memoizeCapped(func) {
                  var result2 = memoize(func, function(key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                      cache.clear();
                    }
                    return key;
                  });
                  var cache = result2.cache;
                  return result2;
                }
                function mergeData(data, source) {
                  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                  var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                  if (!(isCommon || isCombo)) {
                    return data;
                  }
                  if (srcBitmask & WRAP_BIND_FLAG) {
                    data[2] = source[2];
                    newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                  }
                  var value = source[3];
                  if (value) {
                    var partials = data[3];
                    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                  }
                  value = source[5];
                  if (value) {
                    partials = data[5];
                    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                  }
                  value = source[7];
                  if (value) {
                    data[7] = value;
                  }
                  if (srcBitmask & WRAP_ARY_FLAG) {
                    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                  }
                  if (data[9] == null) {
                    data[9] = source[9];
                  }
                  data[0] = source[0];
                  data[1] = newBitmask;
                  return data;
                }
                function nativeKeysIn(object) {
                  var result2 = [];
                  if (object != null) {
                    for (var key in Object2(object)) {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function objectToString(value) {
                  return nativeObjectToString.call(value);
                }
                function overRest(func, start, transform3) {
                  start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
                  return function() {
                    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
                    while (++index < length) {
                      array[index] = args[start + index];
                    }
                    index = -1;
                    var otherArgs = Array2(start + 1);
                    while (++index < start) {
                      otherArgs[index] = args[index];
                    }
                    otherArgs[start] = transform3(array);
                    return apply(func, this, otherArgs);
                  };
                }
                function parent(object, path) {
                  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                }
                function reorder(array, indexes) {
                  var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                  while (length--) {
                    var index = indexes[length];
                    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
                  }
                  return array;
                }
                function safeGet(object, key) {
                  if (key === "constructor" && typeof object[key] === "function") {
                    return;
                  }
                  if (key == "__proto__") {
                    return;
                  }
                  return object[key];
                }
                var setData = shortOut(baseSetData);
                var setTimeout2 = ctxSetTimeout || function(func, wait) {
                  return root.setTimeout(func, wait);
                };
                var setToString = shortOut(baseSetToString);
                function setWrapToString(wrapper, reference, bitmask) {
                  var source = reference + "";
                  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                }
                function shortOut(func) {
                  var count = 0, lastCalled = 0;
                  return function() {
                    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                    lastCalled = stamp;
                    if (remaining > 0) {
                      if (++count >= HOT_COUNT) {
                        return arguments[0];
                      }
                    } else {
                      count = 0;
                    }
                    return func.apply(undefined2, arguments);
                  };
                }
                function shuffleSelf(array, size2) {
                  var index = -1, length = array.length, lastIndex = length - 1;
                  size2 = size2 === undefined2 ? length : size2;
                  while (++index < size2) {
                    var rand = baseRandom(index, lastIndex), value = array[rand];
                    array[rand] = array[index];
                    array[index] = value;
                  }
                  array.length = size2;
                  return array;
                }
                var stringToPath = memoizeCapped(function(string) {
                  var result2 = [];
                  if (string.charCodeAt(0) === 46) {
                    result2.push("");
                  }
                  string.replace(rePropName, function(match, number, quote, subString) {
                    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                  });
                  return result2;
                });
                function toKey(value) {
                  if (typeof value == "string" || isSymbol2(value)) {
                    return value;
                  }
                  var result2 = value + "";
                  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
                }
                function toSource(func) {
                  if (func != null) {
                    try {
                      return funcToString.call(func);
                    } catch (e) {
                    }
                    try {
                      return func + "";
                    } catch (e) {
                    }
                  }
                  return "";
                }
                function updateWrapDetails(details, bitmask) {
                  arrayEach(wrapFlags, function(pair) {
                    var value = "_." + pair[0];
                    if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                      details.push(value);
                    }
                  });
                  return details.sort();
                }
                function wrapperClone(wrapper) {
                  if (wrapper instanceof LazyWrapper) {
                    return wrapper.clone();
                  }
                  var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                  result2.__actions__ = copyArray(wrapper.__actions__);
                  result2.__index__ = wrapper.__index__;
                  result2.__values__ = wrapper.__values__;
                  return result2;
                }
                function chunk(array, size2, guard) {
                  if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
                    size2 = 1;
                  } else {
                    size2 = nativeMax(toInteger(size2), 0);
                  }
                  var length = array == null ? 0 : array.length;
                  if (!length || size2 < 1) {
                    return [];
                  }
                  var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
                  while (index < length) {
                    result2[resIndex++] = baseSlice(array, index, index += size2);
                  }
                  return result2;
                }
                function compact(array) {
                  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
                  while (++index < length) {
                    var value = array[index];
                    if (value) {
                      result2[resIndex++] = value;
                    }
                  }
                  return result2;
                }
                function concat() {
                  var length = arguments.length;
                  if (!length) {
                    return [];
                  }
                  var args = Array2(length - 1), array = arguments[0], index = length;
                  while (index--) {
                    args[index - 1] = arguments[index];
                  }
                  return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
                }
                var difference = baseRest(function(array, values2) {
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
                });
                var differenceBy = baseRest(function(array, values2) {
                  var iteratee2 = last(values2);
                  if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined2;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
                });
                var differenceWith = baseRest(function(array, values2) {
                  var comparator = last(values2);
                  if (isArrayLikeObject(comparator)) {
                    comparator = undefined2;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
                });
                function drop(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined2 ? 1 : toInteger(n);
                  return baseSlice(array, n < 0 ? 0 : n, length);
                }
                function dropRight(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined2 ? 1 : toInteger(n);
                  n = length - n;
                  return baseSlice(array, 0, n < 0 ? 0 : n);
                }
                function dropRightWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
                }
                function dropWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
                }
                function fill(array, value, start, end) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                    start = 0;
                    end = length;
                  }
                  return baseFill(array, value, start, end);
                }
                function findIndex(array, predicate, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = fromIndex == null ? 0 : toInteger(fromIndex);
                  if (index < 0) {
                    index = nativeMax(length + index, 0);
                  }
                  return baseFindIndex(array, getIteratee(predicate, 3), index);
                }
                function findLastIndex(array, predicate, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = length - 1;
                  if (fromIndex !== undefined2) {
                    index = toInteger(fromIndex);
                    index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                  }
                  return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                }
                function flatten(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseFlatten(array, 1) : [];
                }
                function flattenDeep(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseFlatten(array, INFINITY) : [];
                }
                function flattenDepth(array, depth) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  depth = depth === undefined2 ? 1 : toInteger(depth);
                  return baseFlatten(array, depth);
                }
                function fromPairs(pairs) {
                  var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
                  while (++index < length) {
                    var pair = pairs[index];
                    result2[pair[0]] = pair[1];
                  }
                  return result2;
                }
                function head(array) {
                  return array && array.length ? array[0] : undefined2;
                }
                function indexOf(array, value, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = fromIndex == null ? 0 : toInteger(fromIndex);
                  if (index < 0) {
                    index = nativeMax(length + index, 0);
                  }
                  return baseIndexOf(array, value, index);
                }
                function initial(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseSlice(array, 0, -1) : [];
                }
                var intersection = baseRest(function(arrays) {
                  var mapped = arrayMap(arrays, castArrayLikeObject);
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
                });
                var intersectionBy = baseRest(function(arrays) {
                  var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                  if (iteratee2 === last(mapped)) {
                    iteratee2 = undefined2;
                  } else {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
                });
                var intersectionWith = baseRest(function(arrays) {
                  var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                  comparator = typeof comparator == "function" ? comparator : undefined2;
                  if (comparator) {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
                });
                function join(array, separator) {
                  return array == null ? "" : nativeJoin.call(array, separator);
                }
                function last(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? array[length - 1] : undefined2;
                }
                function lastIndexOf(array, value, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = length;
                  if (fromIndex !== undefined2) {
                    index = toInteger(fromIndex);
                    index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                  }
                  return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
                }
                function nth(array, n) {
                  return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
                }
                var pull = baseRest(pullAll);
                function pullAll(array, values2) {
                  return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
                }
                function pullAllBy(array, values2, iteratee2) {
                  return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
                }
                function pullAllWith(array, values2, comparator) {
                  return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
                }
                var pullAt = flatRest(function(array, indexes) {
                  var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
                  basePullAt(array, arrayMap(indexes, function(index) {
                    return isIndex(index, length) ? +index : index;
                  }).sort(compareAscending));
                  return result2;
                });
                function remove(array, predicate) {
                  var result2 = [];
                  if (!(array && array.length)) {
                    return result2;
                  }
                  var index = -1, indexes = [], length = array.length;
                  predicate = getIteratee(predicate, 3);
                  while (++index < length) {
                    var value = array[index];
                    if (predicate(value, index, array)) {
                      result2.push(value);
                      indexes.push(index);
                    }
                  }
                  basePullAt(array, indexes);
                  return result2;
                }
                function reverse(array) {
                  return array == null ? array : nativeReverse.call(array);
                }
                function slice(array, start, end) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                    start = 0;
                    end = length;
                  } else {
                    start = start == null ? 0 : toInteger(start);
                    end = end === undefined2 ? length : toInteger(end);
                  }
                  return baseSlice(array, start, end);
                }
                function sortedIndex(array, value) {
                  return baseSortedIndex(array, value);
                }
                function sortedIndexBy(array, value, iteratee2) {
                  return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
                }
                function sortedIndexOf(array, value) {
                  var length = array == null ? 0 : array.length;
                  if (length) {
                    var index = baseSortedIndex(array, value);
                    if (index < length && eq(array[index], value)) {
                      return index;
                    }
                  }
                  return -1;
                }
                function sortedLastIndex(array, value) {
                  return baseSortedIndex(array, value, true);
                }
                function sortedLastIndexBy(array, value, iteratee2) {
                  return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
                }
                function sortedLastIndexOf(array, value) {
                  var length = array == null ? 0 : array.length;
                  if (length) {
                    var index = baseSortedIndex(array, value, true) - 1;
                    if (eq(array[index], value)) {
                      return index;
                    }
                  }
                  return -1;
                }
                function sortedUniq(array) {
                  return array && array.length ? baseSortedUniq(array) : [];
                }
                function sortedUniqBy(array, iteratee2) {
                  return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
                }
                function tail(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseSlice(array, 1, length) : [];
                }
                function take(array, n, guard) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  n = guard || n === undefined2 ? 1 : toInteger(n);
                  return baseSlice(array, 0, n < 0 ? 0 : n);
                }
                function takeRight(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined2 ? 1 : toInteger(n);
                  n = length - n;
                  return baseSlice(array, n < 0 ? 0 : n, length);
                }
                function takeRightWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
                }
                function takeWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
                }
                var union = baseRest(function(arrays) {
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                });
                var unionBy = baseRest(function(arrays) {
                  var iteratee2 = last(arrays);
                  if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined2;
                  }
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
                });
                var unionWith = baseRest(function(arrays) {
                  var comparator = last(arrays);
                  comparator = typeof comparator == "function" ? comparator : undefined2;
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
                });
                function uniq(array) {
                  return array && array.length ? baseUniq(array) : [];
                }
                function uniqBy(array, iteratee2) {
                  return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
                }
                function uniqWith(array, comparator) {
                  comparator = typeof comparator == "function" ? comparator : undefined2;
                  return array && array.length ? baseUniq(array, undefined2, comparator) : [];
                }
                function unzip(array) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  var length = 0;
                  array = arrayFilter(array, function(group) {
                    if (isArrayLikeObject(group)) {
                      length = nativeMax(group.length, length);
                      return true;
                    }
                  });
                  return baseTimes(length, function(index) {
                    return arrayMap(array, baseProperty(index));
                  });
                }
                function unzipWith(array, iteratee2) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  var result2 = unzip(array);
                  if (iteratee2 == null) {
                    return result2;
                  }
                  return arrayMap(result2, function(group) {
                    return apply(iteratee2, undefined2, group);
                  });
                }
                var without = baseRest(function(array, values2) {
                  return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
                });
                var xor = baseRest(function(arrays) {
                  return baseXor(arrayFilter(arrays, isArrayLikeObject));
                });
                var xorBy = baseRest(function(arrays) {
                  var iteratee2 = last(arrays);
                  if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined2;
                  }
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
                });
                var xorWith = baseRest(function(arrays) {
                  var comparator = last(arrays);
                  comparator = typeof comparator == "function" ? comparator : undefined2;
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
                });
                var zip = baseRest(unzip);
                function zipObject(props, values2) {
                  return baseZipObject(props || [], values2 || [], assignValue);
                }
                function zipObjectDeep(props, values2) {
                  return baseZipObject(props || [], values2 || [], baseSet);
                }
                var zipWith = baseRest(function(arrays) {
                  var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
                  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
                  return unzipWith(arrays, iteratee2);
                });
                function chain(value) {
                  var result2 = lodash(value);
                  result2.__chain__ = true;
                  return result2;
                }
                function tap(value, interceptor) {
                  interceptor(value);
                  return value;
                }
                function thru(value, interceptor) {
                  return interceptor(value);
                }
                var wrapperAt = flatRest(function(paths) {
                  var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                    return baseAt(object, paths);
                  };
                  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                    return this.thru(interceptor);
                  }
                  value = value.slice(start, +start + (length ? 1 : 0));
                  value.__actions__.push({
                    "func": thru,
                    "args": [interceptor],
                    "thisArg": undefined2
                  });
                  return new LodashWrapper(value, this.__chain__).thru(function(array) {
                    if (length && !array.length) {
                      array.push(undefined2);
                    }
                    return array;
                  });
                });
                function wrapperChain() {
                  return chain(this);
                }
                function wrapperCommit() {
                  return new LodashWrapper(this.value(), this.__chain__);
                }
                function wrapperNext() {
                  if (this.__values__ === undefined2) {
                    this.__values__ = toArray(this.value());
                  }
                  var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
                  return { "done": done, "value": value };
                }
                function wrapperToIterator() {
                  return this;
                }
                function wrapperPlant(value) {
                  var result2, parent2 = this;
                  while (parent2 instanceof baseLodash) {
                    var clone2 = wrapperClone(parent2);
                    clone2.__index__ = 0;
                    clone2.__values__ = undefined2;
                    if (result2) {
                      previous.__wrapped__ = clone2;
                    } else {
                      result2 = clone2;
                    }
                    var previous = clone2;
                    parent2 = parent2.__wrapped__;
                  }
                  previous.__wrapped__ = value;
                  return result2;
                }
                function wrapperReverse() {
                  var value = this.__wrapped__;
                  if (value instanceof LazyWrapper) {
                    var wrapped = value;
                    if (this.__actions__.length) {
                      wrapped = new LazyWrapper(this);
                    }
                    wrapped = wrapped.reverse();
                    wrapped.__actions__.push({
                      "func": thru,
                      "args": [reverse],
                      "thisArg": undefined2
                    });
                    return new LodashWrapper(wrapped, this.__chain__);
                  }
                  return this.thru(reverse);
                }
                function wrapperValue() {
                  return baseWrapperValue(this.__wrapped__, this.__actions__);
                }
                var countBy = createAggregator(function(result2, value, key) {
                  if (hasOwnProperty.call(result2, key)) {
                    ++result2[key];
                  } else {
                    baseAssignValue(result2, key, 1);
                  }
                });
                function every(collection, predicate, guard) {
                  var func = isArray2(collection) ? arrayEvery : baseEvery;
                  if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined2;
                  }
                  return func(collection, getIteratee(predicate, 3));
                }
                function filter(collection, predicate) {
                  var func = isArray2(collection) ? arrayFilter : baseFilter;
                  return func(collection, getIteratee(predicate, 3));
                }
                var find = createFind(findIndex);
                var findLast = createFind(findLastIndex);
                function flatMap(collection, iteratee2) {
                  return baseFlatten(map(collection, iteratee2), 1);
                }
                function flatMapDeep(collection, iteratee2) {
                  return baseFlatten(map(collection, iteratee2), INFINITY);
                }
                function flatMapDepth(collection, iteratee2, depth) {
                  depth = depth === undefined2 ? 1 : toInteger(depth);
                  return baseFlatten(map(collection, iteratee2), depth);
                }
                function forEach(collection, iteratee2) {
                  var func = isArray2(collection) ? arrayEach : baseEach;
                  return func(collection, getIteratee(iteratee2, 3));
                }
                function forEachRight(collection, iteratee2) {
                  var func = isArray2(collection) ? arrayEachRight : baseEachRight;
                  return func(collection, getIteratee(iteratee2, 3));
                }
                var groupBy = createAggregator(function(result2, value, key) {
                  if (hasOwnProperty.call(result2, key)) {
                    result2[key].push(value);
                  } else {
                    baseAssignValue(result2, key, [value]);
                  }
                });
                function includes(collection, value, fromIndex, guard) {
                  collection = isArrayLike(collection) ? collection : values(collection);
                  fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                  var length = collection.length;
                  if (fromIndex < 0) {
                    fromIndex = nativeMax(length + fromIndex, 0);
                  }
                  return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
                }
                var invokeMap = baseRest(function(collection, path, args) {
                  var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                  baseEach(collection, function(value) {
                    result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                  });
                  return result2;
                });
                var keyBy = createAggregator(function(result2, value, key) {
                  baseAssignValue(result2, key, value);
                });
                function map(collection, iteratee2) {
                  var func = isArray2(collection) ? arrayMap : baseMap;
                  return func(collection, getIteratee(iteratee2, 3));
                }
                function orderBy(collection, iteratees, orders, guard) {
                  if (collection == null) {
                    return [];
                  }
                  if (!isArray2(iteratees)) {
                    iteratees = iteratees == null ? [] : [iteratees];
                  }
                  orders = guard ? undefined2 : orders;
                  if (!isArray2(orders)) {
                    orders = orders == null ? [] : [orders];
                  }
                  return baseOrderBy(collection, iteratees, orders);
                }
                var partition = createAggregator(function(result2, value, key) {
                  result2[key ? 0 : 1].push(value);
                }, function() {
                  return [[], []];
                });
                function reduce(collection, iteratee2, accumulator) {
                  var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                  return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
                }
                function reduceRight(collection, iteratee2, accumulator) {
                  var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                  return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
                }
                function reject(collection, predicate) {
                  var func = isArray2(collection) ? arrayFilter : baseFilter;
                  return func(collection, negate(getIteratee(predicate, 3)));
                }
                function sample(collection) {
                  var func = isArray2(collection) ? arraySample : baseSample;
                  return func(collection);
                }
                function sampleSize(collection, n, guard) {
                  if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
                    n = 1;
                  } else {
                    n = toInteger(n);
                  }
                  var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
                  return func(collection, n);
                }
                function shuffle(collection) {
                  var func = isArray2(collection) ? arrayShuffle : baseShuffle;
                  return func(collection);
                }
                function size(collection) {
                  if (collection == null) {
                    return 0;
                  }
                  if (isArrayLike(collection)) {
                    return isString2(collection) ? stringSize(collection) : collection.length;
                  }
                  var tag = getTag(collection);
                  if (tag == mapTag || tag == setTag) {
                    return collection.size;
                  }
                  return baseKeys(collection).length;
                }
                function some(collection, predicate, guard) {
                  var func = isArray2(collection) ? arraySome : baseSome;
                  if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined2;
                  }
                  return func(collection, getIteratee(predicate, 3));
                }
                var sortBy = baseRest(function(collection, iteratees) {
                  if (collection == null) {
                    return [];
                  }
                  var length = iteratees.length;
                  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                    iteratees = [];
                  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                    iteratees = [iteratees[0]];
                  }
                  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                });
                var now = ctxNow || function() {
                  return root.Date.now();
                };
                function after(n, func) {
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  n = toInteger(n);
                  return function() {
                    if (--n < 1) {
                      return func.apply(this, arguments);
                    }
                  };
                }
                function ary(func, n, guard) {
                  n = guard ? undefined2 : n;
                  n = func && n == null ? func.length : n;
                  return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
                }
                function before(n, func) {
                  var result2;
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  n = toInteger(n);
                  return function() {
                    if (--n > 0) {
                      result2 = func.apply(this, arguments);
                    }
                    if (n <= 1) {
                      func = undefined2;
                    }
                    return result2;
                  };
                }
                var bind = baseRest(function(func, thisArg, partials) {
                  var bitmask = WRAP_BIND_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bind));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(func, bitmask, thisArg, partials, holders);
                });
                var bindKey = baseRest(function(object, key, partials) {
                  var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bindKey));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(key, bitmask, object, partials, holders);
                });
                function curry(func, arity, guard) {
                  arity = guard ? undefined2 : arity;
                  var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
                  result2.placeholder = curry.placeholder;
                  return result2;
                }
                function curryRight(func, arity, guard) {
                  arity = guard ? undefined2 : arity;
                  var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
                  result2.placeholder = curryRight.placeholder;
                  return result2;
                }
                function debounce(func, wait, options) {
                  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  wait = toNumber(wait) || 0;
                  if (isObject2(options)) {
                    leading = !!options.leading;
                    maxing = "maxWait" in options;
                    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                  }
                  function invokeFunc(time) {
                    var args = lastArgs, thisArg = lastThis;
                    lastArgs = lastThis = undefined2;
                    lastInvokeTime = time;
                    result2 = func.apply(thisArg, args);
                    return result2;
                  }
                  function leadingEdge(time) {
                    lastInvokeTime = time;
                    timerId = setTimeout2(timerExpired, wait);
                    return leading ? invokeFunc(time) : result2;
                  }
                  function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                  }
                  function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                    return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                  }
                  function timerExpired() {
                    var time = now();
                    if (shouldInvoke(time)) {
                      return trailingEdge(time);
                    }
                    timerId = setTimeout2(timerExpired, remainingWait(time));
                  }
                  function trailingEdge(time) {
                    timerId = undefined2;
                    if (trailing && lastArgs) {
                      return invokeFunc(time);
                    }
                    lastArgs = lastThis = undefined2;
                    return result2;
                  }
                  function cancel() {
                    if (timerId !== undefined2) {
                      clearTimeout2(timerId);
                    }
                    lastInvokeTime = 0;
                    lastArgs = lastCallTime = lastThis = timerId = undefined2;
                  }
                  function flush() {
                    return timerId === undefined2 ? result2 : trailingEdge(now());
                  }
                  function debounced() {
                    var time = now(), isInvoking = shouldInvoke(time);
                    lastArgs = arguments;
                    lastThis = this;
                    lastCallTime = time;
                    if (isInvoking) {
                      if (timerId === undefined2) {
                        return leadingEdge(lastCallTime);
                      }
                      if (maxing) {
                        clearTimeout2(timerId);
                        timerId = setTimeout2(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                      }
                    }
                    if (timerId === undefined2) {
                      timerId = setTimeout2(timerExpired, wait);
                    }
                    return result2;
                  }
                  debounced.cancel = cancel;
                  debounced.flush = flush;
                  return debounced;
                }
                var defer = baseRest(function(func, args) {
                  return baseDelay(func, 1, args);
                });
                var delay = baseRest(function(func, wait, args) {
                  return baseDelay(func, toNumber(wait) || 0, args);
                });
                function flip(func) {
                  return createWrap(func, WRAP_FLIP_FLAG);
                }
                function memoize(func, resolver) {
                  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  var memoized = function() {
                    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                    if (cache.has(key)) {
                      return cache.get(key);
                    }
                    var result2 = func.apply(this, args);
                    memoized.cache = cache.set(key, result2) || cache;
                    return result2;
                  };
                  memoized.cache = new (memoize.Cache || MapCache)();
                  return memoized;
                }
                memoize.Cache = MapCache;
                function negate(predicate) {
                  if (typeof predicate != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  return function() {
                    var args = arguments;
                    switch (args.length) {
                      case 0:
                        return !predicate.call(this);
                      case 1:
                        return !predicate.call(this, args[0]);
                      case 2:
                        return !predicate.call(this, args[0], args[1]);
                      case 3:
                        return !predicate.call(this, args[0], args[1], args[2]);
                    }
                    return !predicate.apply(this, args);
                  };
                }
                function once(func) {
                  return before(2, func);
                }
                var overArgs = castRest(function(func, transforms) {
                  transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                  var funcsLength = transforms.length;
                  return baseRest(function(args) {
                    var index = -1, length = nativeMin(args.length, funcsLength);
                    while (++index < length) {
                      args[index] = transforms[index].call(this, args[index]);
                    }
                    return apply(func, this, args);
                  });
                });
                var partial = baseRest(function(func, partials) {
                  var holders = replaceHolders(partials, getHolder(partial));
                  return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
                });
                var partialRight = baseRest(function(func, partials) {
                  var holders = replaceHolders(partials, getHolder(partialRight));
                  return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
                });
                var rearg = flatRest(function(func, indexes) {
                  return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
                });
                function rest(func, start) {
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  start = start === undefined2 ? start : toInteger(start);
                  return baseRest(func, start);
                }
                function spread(func, start) {
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  start = start == null ? 0 : nativeMax(toInteger(start), 0);
                  return baseRest(function(args) {
                    var array = args[start], otherArgs = castSlice(args, 0, start);
                    if (array) {
                      arrayPush(otherArgs, array);
                    }
                    return apply(func, this, otherArgs);
                  });
                }
                function throttle(func, wait, options) {
                  var leading = true, trailing = true;
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  if (isObject2(options)) {
                    leading = "leading" in options ? !!options.leading : leading;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                  }
                  return debounce(func, wait, {
                    "leading": leading,
                    "maxWait": wait,
                    "trailing": trailing
                  });
                }
                function unary(func) {
                  return ary(func, 1);
                }
                function wrap(value, wrapper) {
                  return partial(castFunction(wrapper), value);
                }
                function castArray() {
                  if (!arguments.length) {
                    return [];
                  }
                  var value = arguments[0];
                  return isArray2(value) ? value : [value];
                }
                function clone(value) {
                  return baseClone(value, CLONE_SYMBOLS_FLAG);
                }
                function cloneWith(value, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                }
                function cloneDeep(value) {
                  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                }
                function cloneDeepWith(value, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                }
                function conformsTo(object, source) {
                  return source == null || baseConformsTo(object, source, keys(source));
                }
                function eq(value, other) {
                  return value === other || value !== value && other !== other;
                }
                var gt = createRelationalOperation(baseGt);
                var gte = createRelationalOperation(function(value, other) {
                  return value >= other;
                });
                var isArguments = baseIsArguments(/* @__PURE__ */ function() {
                  return arguments;
                }()) ? baseIsArguments : function(value) {
                  return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
                };
                var isArray2 = Array2.isArray;
                var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
                function isArrayLike(value) {
                  return value != null && isLength(value.length) && !isFunction(value);
                }
                function isArrayLikeObject(value) {
                  return isObjectLike(value) && isArrayLike(value);
                }
                function isBoolean(value) {
                  return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
                }
                var isBuffer = nativeIsBuffer || stubFalse;
                var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
                function isElement(value) {
                  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                }
                function isEmpty(value) {
                  if (value == null) {
                    return true;
                  }
                  if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                    return !value.length;
                  }
                  var tag = getTag(value);
                  if (tag == mapTag || tag == setTag) {
                    return !value.size;
                  }
                  if (isPrototype(value)) {
                    return !baseKeys(value).length;
                  }
                  for (var key in value) {
                    if (hasOwnProperty.call(value, key)) {
                      return false;
                    }
                  }
                  return true;
                }
                function isEqual(value, other) {
                  return baseIsEqual(value, other);
                }
                function isEqualWith(value, other, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  var result2 = customizer ? customizer(value, other) : undefined2;
                  return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
                }
                function isError(value) {
                  if (!isObjectLike(value)) {
                    return false;
                  }
                  var tag = baseGetTag(value);
                  return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
                }
                function isFinite(value) {
                  return typeof value == "number" && nativeIsFinite(value);
                }
                function isFunction(value) {
                  if (!isObject2(value)) {
                    return false;
                  }
                  var tag = baseGetTag(value);
                  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                }
                function isInteger(value) {
                  return typeof value == "number" && value == toInteger(value);
                }
                function isLength(value) {
                  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                }
                function isObject2(value) {
                  var type = typeof value;
                  return value != null && (type == "object" || type == "function");
                }
                function isObjectLike(value) {
                  return value != null && typeof value == "object";
                }
                var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                function isMatch(object, source) {
                  return object === source || baseIsMatch(object, source, getMatchData(source));
                }
                function isMatchWith(object, source, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return baseIsMatch(object, source, getMatchData(source), customizer);
                }
                function isNaN2(value) {
                  return isNumber(value) && value != +value;
                }
                function isNative(value) {
                  if (isMaskable(value)) {
                    throw new Error2(CORE_ERROR_TEXT);
                  }
                  return baseIsNative(value);
                }
                function isNull(value) {
                  return value === null;
                }
                function isNil(value) {
                  return value == null;
                }
                function isNumber(value) {
                  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
                }
                function isPlainObject(value) {
                  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                    return false;
                  }
                  var proto = getPrototype(value);
                  if (proto === null) {
                    return true;
                  }
                  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                }
                var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
                function isSafeInteger(value) {
                  return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                }
                var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                function isString2(value) {
                  return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
                }
                function isSymbol2(value) {
                  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
                }
                var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                function isUndefined(value) {
                  return value === undefined2;
                }
                function isWeakMap(value) {
                  return isObjectLike(value) && getTag(value) == weakMapTag;
                }
                function isWeakSet(value) {
                  return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                }
                var lt = createRelationalOperation(baseLt);
                var lte = createRelationalOperation(function(value, other) {
                  return value <= other;
                });
                function toArray(value) {
                  if (!value) {
                    return [];
                  }
                  if (isArrayLike(value)) {
                    return isString2(value) ? stringToArray(value) : copyArray(value);
                  }
                  if (symIterator && value[symIterator]) {
                    return iteratorToArray(value[symIterator]());
                  }
                  var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                  return func(value);
                }
                function toFinite(value) {
                  if (!value) {
                    return value === 0 ? value : 0;
                  }
                  value = toNumber(value);
                  if (value === INFINITY || value === -INFINITY) {
                    var sign = value < 0 ? -1 : 1;
                    return sign * MAX_INTEGER;
                  }
                  return value === value ? value : 0;
                }
                function toInteger(value) {
                  var result2 = toFinite(value), remainder = result2 % 1;
                  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
                }
                function toLength(value) {
                  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                }
                function toNumber(value) {
                  if (typeof value == "number") {
                    return value;
                  }
                  if (isSymbol2(value)) {
                    return NAN;
                  }
                  if (isObject2(value)) {
                    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                    value = isObject2(other) ? other + "" : other;
                  }
                  if (typeof value != "string") {
                    return value === 0 ? value : +value;
                  }
                  value = baseTrim(value);
                  var isBinary = reIsBinary.test(value);
                  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
                }
                function toPlainObject(value) {
                  return copyObject(value, keysIn(value));
                }
                function toSafeInteger(value) {
                  return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
                }
                function toString(value) {
                  return value == null ? "" : baseToString(value);
                }
                var assign = createAssigner(function(object, source) {
                  if (isPrototype(source) || isArrayLike(source)) {
                    copyObject(source, keys(source), object);
                    return;
                  }
                  for (var key in source) {
                    if (hasOwnProperty.call(source, key)) {
                      assignValue(object, key, source[key]);
                    }
                  }
                });
                var assignIn = createAssigner(function(object, source) {
                  copyObject(source, keysIn(source), object);
                });
                var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                  copyObject(source, keysIn(source), object, customizer);
                });
                var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                  copyObject(source, keys(source), object, customizer);
                });
                var at = flatRest(baseAt);
                function create(prototype, properties) {
                  var result2 = baseCreate(prototype);
                  return properties == null ? result2 : baseAssign(result2, properties);
                }
                var defaults = baseRest(function(object, sources) {
                  object = Object2(object);
                  var index = -1;
                  var length = sources.length;
                  var guard = length > 2 ? sources[2] : undefined2;
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    length = 1;
                  }
                  while (++index < length) {
                    var source = sources[index];
                    var props = keysIn(source);
                    var propsIndex = -1;
                    var propsLength = props.length;
                    while (++propsIndex < propsLength) {
                      var key = props[propsIndex];
                      var value = object[key];
                      if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                        object[key] = source[key];
                      }
                    }
                  }
                  return object;
                });
                var defaultsDeep = baseRest(function(args) {
                  args.push(undefined2, customDefaultsMerge);
                  return apply(mergeWith, undefined2, args);
                });
                function findKey(object, predicate) {
                  return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                }
                function findLastKey(object, predicate) {
                  return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                }
                function forIn(object, iteratee2) {
                  return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
                }
                function forInRight(object, iteratee2) {
                  return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
                }
                function forOwn(object, iteratee2) {
                  return object && baseForOwn(object, getIteratee(iteratee2, 3));
                }
                function forOwnRight(object, iteratee2) {
                  return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
                }
                function functions(object) {
                  return object == null ? [] : baseFunctions(object, keys(object));
                }
                function functionsIn(object) {
                  return object == null ? [] : baseFunctions(object, keysIn(object));
                }
                function get(object, path, defaultValue) {
                  var result2 = object == null ? undefined2 : baseGet(object, path);
                  return result2 === undefined2 ? defaultValue : result2;
                }
                function has(object, path) {
                  return object != null && hasPath(object, path, baseHas);
                }
                function hasIn(object, path) {
                  return object != null && hasPath(object, path, baseHasIn);
                }
                var invert = createInverter(function(result2, value, key) {
                  if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                  }
                  result2[value] = key;
                }, constant(identity));
                var invertBy = createInverter(function(result2, value, key) {
                  if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                  }
                  if (hasOwnProperty.call(result2, value)) {
                    result2[value].push(key);
                  } else {
                    result2[value] = [key];
                  }
                }, getIteratee);
                var invoke = baseRest(baseInvoke);
                function keys(object) {
                  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                }
                function keysIn(object) {
                  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                }
                function mapKeys(object, iteratee2) {
                  var result2 = {};
                  iteratee2 = getIteratee(iteratee2, 3);
                  baseForOwn(object, function(value, key, object2) {
                    baseAssignValue(result2, iteratee2(value, key, object2), value);
                  });
                  return result2;
                }
                function mapValues(object, iteratee2) {
                  var result2 = {};
                  iteratee2 = getIteratee(iteratee2, 3);
                  baseForOwn(object, function(value, key, object2) {
                    baseAssignValue(result2, key, iteratee2(value, key, object2));
                  });
                  return result2;
                }
                var merge = createAssigner(function(object, source, srcIndex) {
                  baseMerge(object, source, srcIndex);
                });
                var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                  baseMerge(object, source, srcIndex, customizer);
                });
                var omit = flatRest(function(object, paths) {
                  var result2 = {};
                  if (object == null) {
                    return result2;
                  }
                  var isDeep = false;
                  paths = arrayMap(paths, function(path) {
                    path = castPath(path, object);
                    isDeep || (isDeep = path.length > 1);
                    return path;
                  });
                  copyObject(object, getAllKeysIn(object), result2);
                  if (isDeep) {
                    result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                  }
                  var length = paths.length;
                  while (length--) {
                    baseUnset(result2, paths[length]);
                  }
                  return result2;
                });
                function omitBy(object, predicate) {
                  return pickBy(object, negate(getIteratee(predicate)));
                }
                var pick = flatRest(function(object, paths) {
                  return object == null ? {} : basePick(object, paths);
                });
                function pickBy(object, predicate) {
                  if (object == null) {
                    return {};
                  }
                  var props = arrayMap(getAllKeysIn(object), function(prop) {
                    return [prop];
                  });
                  predicate = getIteratee(predicate);
                  return basePickBy(object, props, function(value, path) {
                    return predicate(value, path[0]);
                  });
                }
                function result(object, path, defaultValue) {
                  path = castPath(path, object);
                  var index = -1, length = path.length;
                  if (!length) {
                    length = 1;
                    object = undefined2;
                  }
                  while (++index < length) {
                    var value = object == null ? undefined2 : object[toKey(path[index])];
                    if (value === undefined2) {
                      index = length;
                      value = defaultValue;
                    }
                    object = isFunction(value) ? value.call(object) : value;
                  }
                  return object;
                }
                function set(object, path, value) {
                  return object == null ? object : baseSet(object, path, value);
                }
                function setWith(object, path, value, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return object == null ? object : baseSet(object, path, value, customizer);
                }
                var toPairs = createToPairs(keys);
                var toPairsIn = createToPairs(keysIn);
                function transform2(object, iteratee2, accumulator) {
                  var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                  iteratee2 = getIteratee(iteratee2, 4);
                  if (accumulator == null) {
                    var Ctor = object && object.constructor;
                    if (isArrLike) {
                      accumulator = isArr ? new Ctor() : [];
                    } else if (isObject2(object)) {
                      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                    } else {
                      accumulator = {};
                    }
                  }
                  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
                    return iteratee2(accumulator, value, index, object2);
                  });
                  return accumulator;
                }
                function unset(object, path) {
                  return object == null ? true : baseUnset(object, path);
                }
                function update(object, path, updater) {
                  return object == null ? object : baseUpdate(object, path, castFunction(updater));
                }
                function updateWith(object, path, updater, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                }
                function values(object) {
                  return object == null ? [] : baseValues(object, keys(object));
                }
                function valuesIn(object) {
                  return object == null ? [] : baseValues(object, keysIn(object));
                }
                function clamp(number, lower, upper) {
                  if (upper === undefined2) {
                    upper = lower;
                    lower = undefined2;
                  }
                  if (upper !== undefined2) {
                    upper = toNumber(upper);
                    upper = upper === upper ? upper : 0;
                  }
                  if (lower !== undefined2) {
                    lower = toNumber(lower);
                    lower = lower === lower ? lower : 0;
                  }
                  return baseClamp(toNumber(number), lower, upper);
                }
                function inRange(number, start, end) {
                  start = toFinite(start);
                  if (end === undefined2) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  number = toNumber(number);
                  return baseInRange(number, start, end);
                }
                function random(lower, upper, floating) {
                  if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                    upper = floating = undefined2;
                  }
                  if (floating === undefined2) {
                    if (typeof upper == "boolean") {
                      floating = upper;
                      upper = undefined2;
                    } else if (typeof lower == "boolean") {
                      floating = lower;
                      lower = undefined2;
                    }
                  }
                  if (lower === undefined2 && upper === undefined2) {
                    lower = 0;
                    upper = 1;
                  } else {
                    lower = toFinite(lower);
                    if (upper === undefined2) {
                      upper = lower;
                      lower = 0;
                    } else {
                      upper = toFinite(upper);
                    }
                  }
                  if (lower > upper) {
                    var temp = lower;
                    lower = upper;
                    upper = temp;
                  }
                  if (floating || lower % 1 || upper % 1) {
                    var rand = nativeRandom();
                    return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                  }
                  return baseRandom(lower, upper);
                }
                var camelCase = createCompounder(function(result2, word, index) {
                  word = word.toLowerCase();
                  return result2 + (index ? capitalize2(word) : word);
                });
                function capitalize2(string) {
                  return upperFirst(toString(string).toLowerCase());
                }
                function deburr(string) {
                  string = toString(string);
                  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
                }
                function endsWith(string, target, position) {
                  string = toString(string);
                  target = baseToString(target);
                  var length = string.length;
                  position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
                  var end = position;
                  position -= target.length;
                  return position >= 0 && string.slice(position, end) == target;
                }
                function escape(string) {
                  string = toString(string);
                  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                }
                function escapeRegExp(string) {
                  string = toString(string);
                  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
                }
                var kebabCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? "-" : "") + word.toLowerCase();
                });
                var lowerCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? " " : "") + word.toLowerCase();
                });
                var lowerFirst = createCaseFirst("toLowerCase");
                function pad(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);
                  var strLength = length ? stringSize(string) : 0;
                  if (!length || strLength >= length) {
                    return string;
                  }
                  var mid = (length - strLength) / 2;
                  return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
                }
                function padEnd(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);
                  var strLength = length ? stringSize(string) : 0;
                  return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
                }
                function padStart(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);
                  var strLength = length ? stringSize(string) : 0;
                  return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
                }
                function parseInt2(string, radix, guard) {
                  if (guard || radix == null) {
                    radix = 0;
                  } else if (radix) {
                    radix = +radix;
                  }
                  return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
                }
                function repeat(string, n, guard) {
                  if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
                    n = 1;
                  } else {
                    n = toInteger(n);
                  }
                  return baseRepeat(toString(string), n);
                }
                function replace() {
                  var args = arguments, string = toString(args[0]);
                  return args.length < 3 ? string : string.replace(args[1], args[2]);
                }
                var snakeCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? "_" : "") + word.toLowerCase();
                });
                function split(string, separator, limit) {
                  if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                    separator = limit = undefined2;
                  }
                  limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
                  if (!limit) {
                    return [];
                  }
                  string = toString(string);
                  if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                    separator = baseToString(separator);
                    if (!separator && hasUnicode(string)) {
                      return castSlice(stringToArray(string), 0, limit);
                    }
                  }
                  return string.split(separator, limit);
                }
                var startCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? " " : "") + upperFirst(word);
                });
                function startsWith(string, target, position) {
                  string = toString(string);
                  position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                  target = baseToString(target);
                  return string.slice(position, position + target.length) == target;
                }
                function template(string, options, guard) {
                  var settings = lodash.templateSettings;
                  if (guard && isIterateeCall(string, options, guard)) {
                    options = undefined2;
                  }
                  string = toString(string);
                  options = assignInWith({}, options, settings, customDefaultsAssignIn);
                  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                  var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                  var reDelimiters = RegExp2(
                    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
                    "g"
                  );
                  var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                    interpolateValue || (interpolateValue = esTemplateValue);
                    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                    if (escapeValue) {
                      isEscaping = true;
                      source += "' +\n__e(" + escapeValue + ") +\n'";
                    }
                    if (evaluateValue) {
                      isEvaluating = true;
                      source += "';\n" + evaluateValue + ";\n__p += '";
                    }
                    if (interpolateValue) {
                      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                    }
                    index = offset + match.length;
                    return match;
                  });
                  source += "';\n";
                  var variable = hasOwnProperty.call(options, "variable") && options.variable;
                  if (!variable) {
                    source = "with (obj) {\n" + source + "\n}\n";
                  } else if (reForbiddenIdentifierChars.test(variable)) {
                    throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
                  }
                  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                  var result2 = attempt(function() {
                    return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
                  });
                  result2.source = source;
                  if (isError(result2)) {
                    throw result2;
                  }
                  return result2;
                }
                function toLower(value) {
                  return toString(value).toLowerCase();
                }
                function toUpper(value) {
                  return toString(value).toUpperCase();
                }
                function trim(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined2)) {
                    return baseTrim(string);
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                  return castSlice(strSymbols, start, end).join("");
                }
                function trimEnd(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined2)) {
                    return string.slice(0, trimmedEndIndex(string) + 1);
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                  return castSlice(strSymbols, 0, end).join("");
                }
                function trimStart(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined2)) {
                    return string.replace(reTrimStart, "");
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                  return castSlice(strSymbols, start).join("");
                }
                function truncate(string, options) {
                  var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                  if (isObject2(options)) {
                    var separator = "separator" in options ? options.separator : separator;
                    length = "length" in options ? toInteger(options.length) : length;
                    omission = "omission" in options ? baseToString(options.omission) : omission;
                  }
                  string = toString(string);
                  var strLength = string.length;
                  if (hasUnicode(string)) {
                    var strSymbols = stringToArray(string);
                    strLength = strSymbols.length;
                  }
                  if (length >= strLength) {
                    return string;
                  }
                  var end = length - stringSize(omission);
                  if (end < 1) {
                    return omission;
                  }
                  var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                  if (separator === undefined2) {
                    return result2 + omission;
                  }
                  if (strSymbols) {
                    end += result2.length - end;
                  }
                  if (isRegExp(separator)) {
                    if (string.slice(end).search(separator)) {
                      var match, substring = result2;
                      if (!separator.global) {
                        separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                      }
                      separator.lastIndex = 0;
                      while (match = separator.exec(substring)) {
                        var newEnd = match.index;
                      }
                      result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
                    }
                  } else if (string.indexOf(baseToString(separator), end) != end) {
                    var index = result2.lastIndexOf(separator);
                    if (index > -1) {
                      result2 = result2.slice(0, index);
                    }
                  }
                  return result2 + omission;
                }
                function unescape2(string) {
                  string = toString(string);
                  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                }
                var upperCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? " " : "") + word.toUpperCase();
                });
                var upperFirst = createCaseFirst("toUpperCase");
                function words(string, pattern, guard) {
                  string = toString(string);
                  pattern = guard ? undefined2 : pattern;
                  if (pattern === undefined2) {
                    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                  }
                  return string.match(pattern) || [];
                }
                var attempt = baseRest(function(func, args) {
                  try {
                    return apply(func, undefined2, args);
                  } catch (e) {
                    return isError(e) ? e : new Error2(e);
                  }
                });
                var bindAll = flatRest(function(object, methodNames) {
                  arrayEach(methodNames, function(key) {
                    key = toKey(key);
                    baseAssignValue(object, key, bind(object[key], object));
                  });
                  return object;
                });
                function cond(pairs) {
                  var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                  pairs = !length ? [] : arrayMap(pairs, function(pair) {
                    if (typeof pair[1] != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    return [toIteratee(pair[0]), pair[1]];
                  });
                  return baseRest(function(args) {
                    var index = -1;
                    while (++index < length) {
                      var pair = pairs[index];
                      if (apply(pair[0], this, args)) {
                        return apply(pair[1], this, args);
                      }
                    }
                  });
                }
                function conforms(source) {
                  return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                }
                function constant(value) {
                  return function() {
                    return value;
                  };
                }
                function defaultTo(value, defaultValue) {
                  return value == null || value !== value ? defaultValue : value;
                }
                var flow = createFlow();
                var flowRight = createFlow(true);
                function identity(value) {
                  return value;
                }
                function iteratee(func) {
                  return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
                }
                function matches(source) {
                  return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                }
                function matchesProperty(path, srcValue) {
                  return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                }
                var method = baseRest(function(path, args) {
                  return function(object) {
                    return baseInvoke(object, path, args);
                  };
                });
                var methodOf = baseRest(function(object, args) {
                  return function(path) {
                    return baseInvoke(object, path, args);
                  };
                });
                function mixin(object, source, options) {
                  var props = keys(source), methodNames = baseFunctions(source, props);
                  if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
                    options = source;
                    source = object;
                    object = this;
                    methodNames = baseFunctions(source, keys(source));
                  }
                  var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
                  arrayEach(methodNames, function(methodName) {
                    var func = source[methodName];
                    object[methodName] = func;
                    if (isFunc) {
                      object.prototype[methodName] = function() {
                        var chainAll = this.__chain__;
                        if (chain2 || chainAll) {
                          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                          actions.push({ "func": func, "args": arguments, "thisArg": object });
                          result2.__chain__ = chainAll;
                          return result2;
                        }
                        return func.apply(object, arrayPush([this.value()], arguments));
                      };
                    }
                  });
                  return object;
                }
                function noConflict() {
                  if (root._ === this) {
                    root._ = oldDash;
                  }
                  return this;
                }
                function noop() {
                }
                function nthArg(n) {
                  n = toInteger(n);
                  return baseRest(function(args) {
                    return baseNth(args, n);
                  });
                }
                var over = createOver(arrayMap);
                var overEvery = createOver(arrayEvery);
                var overSome = createOver(arraySome);
                function property(path) {
                  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                }
                function propertyOf(object) {
                  return function(path) {
                    return object == null ? undefined2 : baseGet(object, path);
                  };
                }
                var range = createRange();
                var rangeRight = createRange(true);
                function stubArray() {
                  return [];
                }
                function stubFalse() {
                  return false;
                }
                function stubObject() {
                  return {};
                }
                function stubString() {
                  return "";
                }
                function stubTrue() {
                  return true;
                }
                function times(n, iteratee2) {
                  n = toInteger(n);
                  if (n < 1 || n > MAX_SAFE_INTEGER) {
                    return [];
                  }
                  var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                  iteratee2 = getIteratee(iteratee2);
                  n -= MAX_ARRAY_LENGTH;
                  var result2 = baseTimes(length, iteratee2);
                  while (++index < n) {
                    iteratee2(index);
                  }
                  return result2;
                }
                function toPath(value) {
                  if (isArray2(value)) {
                    return arrayMap(value, toKey);
                  }
                  return isSymbol2(value) ? [value] : copyArray(stringToPath(toString(value)));
                }
                function uniqueId(prefix) {
                  var id = ++idCounter;
                  return toString(prefix) + id;
                }
                var add = createMathOperation(function(augend, addend) {
                  return augend + addend;
                }, 0);
                var ceil = createRound("ceil");
                var divide = createMathOperation(function(dividend, divisor) {
                  return dividend / divisor;
                }, 1);
                var floor = createRound("floor");
                function max(array) {
                  return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
                }
                function maxBy(array, iteratee2) {
                  return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
                }
                function mean(array) {
                  return baseMean(array, identity);
                }
                function meanBy(array, iteratee2) {
                  return baseMean(array, getIteratee(iteratee2, 2));
                }
                function min(array) {
                  return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
                }
                function minBy(array, iteratee2) {
                  return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
                }
                var multiply = createMathOperation(function(multiplier, multiplicand) {
                  return multiplier * multiplicand;
                }, 1);
                var round = createRound("round");
                var subtract = createMathOperation(function(minuend, subtrahend) {
                  return minuend - subtrahend;
                }, 0);
                function sum(array) {
                  return array && array.length ? baseSum(array, identity) : 0;
                }
                function sumBy(array, iteratee2) {
                  return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
                }
                lodash.after = after;
                lodash.ary = ary;
                lodash.assign = assign;
                lodash.assignIn = assignIn;
                lodash.assignInWith = assignInWith;
                lodash.assignWith = assignWith;
                lodash.at = at;
                lodash.before = before;
                lodash.bind = bind;
                lodash.bindAll = bindAll;
                lodash.bindKey = bindKey;
                lodash.castArray = castArray;
                lodash.chain = chain;
                lodash.chunk = chunk;
                lodash.compact = compact;
                lodash.concat = concat;
                lodash.cond = cond;
                lodash.conforms = conforms;
                lodash.constant = constant;
                lodash.countBy = countBy;
                lodash.create = create;
                lodash.curry = curry;
                lodash.curryRight = curryRight;
                lodash.debounce = debounce;
                lodash.defaults = defaults;
                lodash.defaultsDeep = defaultsDeep;
                lodash.defer = defer;
                lodash.delay = delay;
                lodash.difference = difference;
                lodash.differenceBy = differenceBy;
                lodash.differenceWith = differenceWith;
                lodash.drop = drop;
                lodash.dropRight = dropRight;
                lodash.dropRightWhile = dropRightWhile;
                lodash.dropWhile = dropWhile;
                lodash.fill = fill;
                lodash.filter = filter;
                lodash.flatMap = flatMap;
                lodash.flatMapDeep = flatMapDeep;
                lodash.flatMapDepth = flatMapDepth;
                lodash.flatten = flatten;
                lodash.flattenDeep = flattenDeep;
                lodash.flattenDepth = flattenDepth;
                lodash.flip = flip;
                lodash.flow = flow;
                lodash.flowRight = flowRight;
                lodash.fromPairs = fromPairs;
                lodash.functions = functions;
                lodash.functionsIn = functionsIn;
                lodash.groupBy = groupBy;
                lodash.initial = initial;
                lodash.intersection = intersection;
                lodash.intersectionBy = intersectionBy;
                lodash.intersectionWith = intersectionWith;
                lodash.invert = invert;
                lodash.invertBy = invertBy;
                lodash.invokeMap = invokeMap;
                lodash.iteratee = iteratee;
                lodash.keyBy = keyBy;
                lodash.keys = keys;
                lodash.keysIn = keysIn;
                lodash.map = map;
                lodash.mapKeys = mapKeys;
                lodash.mapValues = mapValues;
                lodash.matches = matches;
                lodash.matchesProperty = matchesProperty;
                lodash.memoize = memoize;
                lodash.merge = merge;
                lodash.mergeWith = mergeWith;
                lodash.method = method;
                lodash.methodOf = methodOf;
                lodash.mixin = mixin;
                lodash.negate = negate;
                lodash.nthArg = nthArg;
                lodash.omit = omit;
                lodash.omitBy = omitBy;
                lodash.once = once;
                lodash.orderBy = orderBy;
                lodash.over = over;
                lodash.overArgs = overArgs;
                lodash.overEvery = overEvery;
                lodash.overSome = overSome;
                lodash.partial = partial;
                lodash.partialRight = partialRight;
                lodash.partition = partition;
                lodash.pick = pick;
                lodash.pickBy = pickBy;
                lodash.property = property;
                lodash.propertyOf = propertyOf;
                lodash.pull = pull;
                lodash.pullAll = pullAll;
                lodash.pullAllBy = pullAllBy;
                lodash.pullAllWith = pullAllWith;
                lodash.pullAt = pullAt;
                lodash.range = range;
                lodash.rangeRight = rangeRight;
                lodash.rearg = rearg;
                lodash.reject = reject;
                lodash.remove = remove;
                lodash.rest = rest;
                lodash.reverse = reverse;
                lodash.sampleSize = sampleSize;
                lodash.set = set;
                lodash.setWith = setWith;
                lodash.shuffle = shuffle;
                lodash.slice = slice;
                lodash.sortBy = sortBy;
                lodash.sortedUniq = sortedUniq;
                lodash.sortedUniqBy = sortedUniqBy;
                lodash.split = split;
                lodash.spread = spread;
                lodash.tail = tail;
                lodash.take = take;
                lodash.takeRight = takeRight;
                lodash.takeRightWhile = takeRightWhile;
                lodash.takeWhile = takeWhile;
                lodash.tap = tap;
                lodash.throttle = throttle;
                lodash.thru = thru;
                lodash.toArray = toArray;
                lodash.toPairs = toPairs;
                lodash.toPairsIn = toPairsIn;
                lodash.toPath = toPath;
                lodash.toPlainObject = toPlainObject;
                lodash.transform = transform2;
                lodash.unary = unary;
                lodash.union = union;
                lodash.unionBy = unionBy;
                lodash.unionWith = unionWith;
                lodash.uniq = uniq;
                lodash.uniqBy = uniqBy;
                lodash.uniqWith = uniqWith;
                lodash.unset = unset;
                lodash.unzip = unzip;
                lodash.unzipWith = unzipWith;
                lodash.update = update;
                lodash.updateWith = updateWith;
                lodash.values = values;
                lodash.valuesIn = valuesIn;
                lodash.without = without;
                lodash.words = words;
                lodash.wrap = wrap;
                lodash.xor = xor;
                lodash.xorBy = xorBy;
                lodash.xorWith = xorWith;
                lodash.zip = zip;
                lodash.zipObject = zipObject;
                lodash.zipObjectDeep = zipObjectDeep;
                lodash.zipWith = zipWith;
                lodash.entries = toPairs;
                lodash.entriesIn = toPairsIn;
                lodash.extend = assignIn;
                lodash.extendWith = assignInWith;
                mixin(lodash, lodash);
                lodash.add = add;
                lodash.attempt = attempt;
                lodash.camelCase = camelCase;
                lodash.capitalize = capitalize2;
                lodash.ceil = ceil;
                lodash.clamp = clamp;
                lodash.clone = clone;
                lodash.cloneDeep = cloneDeep;
                lodash.cloneDeepWith = cloneDeepWith;
                lodash.cloneWith = cloneWith;
                lodash.conformsTo = conformsTo;
                lodash.deburr = deburr;
                lodash.defaultTo = defaultTo;
                lodash.divide = divide;
                lodash.endsWith = endsWith;
                lodash.eq = eq;
                lodash.escape = escape;
                lodash.escapeRegExp = escapeRegExp;
                lodash.every = every;
                lodash.find = find;
                lodash.findIndex = findIndex;
                lodash.findKey = findKey;
                lodash.findLast = findLast;
                lodash.findLastIndex = findLastIndex;
                lodash.findLastKey = findLastKey;
                lodash.floor = floor;
                lodash.forEach = forEach;
                lodash.forEachRight = forEachRight;
                lodash.forIn = forIn;
                lodash.forInRight = forInRight;
                lodash.forOwn = forOwn;
                lodash.forOwnRight = forOwnRight;
                lodash.get = get;
                lodash.gt = gt;
                lodash.gte = gte;
                lodash.has = has;
                lodash.hasIn = hasIn;
                lodash.head = head;
                lodash.identity = identity;
                lodash.includes = includes;
                lodash.indexOf = indexOf;
                lodash.inRange = inRange;
                lodash.invoke = invoke;
                lodash.isArguments = isArguments;
                lodash.isArray = isArray2;
                lodash.isArrayBuffer = isArrayBuffer;
                lodash.isArrayLike = isArrayLike;
                lodash.isArrayLikeObject = isArrayLikeObject;
                lodash.isBoolean = isBoolean;
                lodash.isBuffer = isBuffer;
                lodash.isDate = isDate;
                lodash.isElement = isElement;
                lodash.isEmpty = isEmpty;
                lodash.isEqual = isEqual;
                lodash.isEqualWith = isEqualWith;
                lodash.isError = isError;
                lodash.isFinite = isFinite;
                lodash.isFunction = isFunction;
                lodash.isInteger = isInteger;
                lodash.isLength = isLength;
                lodash.isMap = isMap;
                lodash.isMatch = isMatch;
                lodash.isMatchWith = isMatchWith;
                lodash.isNaN = isNaN2;
                lodash.isNative = isNative;
                lodash.isNil = isNil;
                lodash.isNull = isNull;
                lodash.isNumber = isNumber;
                lodash.isObject = isObject2;
                lodash.isObjectLike = isObjectLike;
                lodash.isPlainObject = isPlainObject;
                lodash.isRegExp = isRegExp;
                lodash.isSafeInteger = isSafeInteger;
                lodash.isSet = isSet;
                lodash.isString = isString2;
                lodash.isSymbol = isSymbol2;
                lodash.isTypedArray = isTypedArray;
                lodash.isUndefined = isUndefined;
                lodash.isWeakMap = isWeakMap;
                lodash.isWeakSet = isWeakSet;
                lodash.join = join;
                lodash.kebabCase = kebabCase;
                lodash.last = last;
                lodash.lastIndexOf = lastIndexOf;
                lodash.lowerCase = lowerCase;
                lodash.lowerFirst = lowerFirst;
                lodash.lt = lt;
                lodash.lte = lte;
                lodash.max = max;
                lodash.maxBy = maxBy;
                lodash.mean = mean;
                lodash.meanBy = meanBy;
                lodash.min = min;
                lodash.minBy = minBy;
                lodash.stubArray = stubArray;
                lodash.stubFalse = stubFalse;
                lodash.stubObject = stubObject;
                lodash.stubString = stubString;
                lodash.stubTrue = stubTrue;
                lodash.multiply = multiply;
                lodash.nth = nth;
                lodash.noConflict = noConflict;
                lodash.noop = noop;
                lodash.now = now;
                lodash.pad = pad;
                lodash.padEnd = padEnd;
                lodash.padStart = padStart;
                lodash.parseInt = parseInt2;
                lodash.random = random;
                lodash.reduce = reduce;
                lodash.reduceRight = reduceRight;
                lodash.repeat = repeat;
                lodash.replace = replace;
                lodash.result = result;
                lodash.round = round;
                lodash.runInContext = runInContext2;
                lodash.sample = sample;
                lodash.size = size;
                lodash.snakeCase = snakeCase;
                lodash.some = some;
                lodash.sortedIndex = sortedIndex;
                lodash.sortedIndexBy = sortedIndexBy;
                lodash.sortedIndexOf = sortedIndexOf;
                lodash.sortedLastIndex = sortedLastIndex;
                lodash.sortedLastIndexBy = sortedLastIndexBy;
                lodash.sortedLastIndexOf = sortedLastIndexOf;
                lodash.startCase = startCase;
                lodash.startsWith = startsWith;
                lodash.subtract = subtract;
                lodash.sum = sum;
                lodash.sumBy = sumBy;
                lodash.template = template;
                lodash.times = times;
                lodash.toFinite = toFinite;
                lodash.toInteger = toInteger;
                lodash.toLength = toLength;
                lodash.toLower = toLower;
                lodash.toNumber = toNumber;
                lodash.toSafeInteger = toSafeInteger;
                lodash.toString = toString;
                lodash.toUpper = toUpper;
                lodash.trim = trim;
                lodash.trimEnd = trimEnd;
                lodash.trimStart = trimStart;
                lodash.truncate = truncate;
                lodash.unescape = unescape2;
                lodash.uniqueId = uniqueId;
                lodash.upperCase = upperCase;
                lodash.upperFirst = upperFirst;
                lodash.each = forEach;
                lodash.eachRight = forEachRight;
                lodash.first = head;
                mixin(lodash, function() {
                  var source = {};
                  baseForOwn(lodash, function(func, methodName) {
                    if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                      source[methodName] = func;
                    }
                  });
                  return source;
                }(), { "chain": false });
                lodash.VERSION = VERSION;
                arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                  lodash[methodName].placeholder = lodash;
                });
                arrayEach(["drop", "take"], function(methodName, index) {
                  LazyWrapper.prototype[methodName] = function(n) {
                    n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
                    var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                    if (result2.__filtered__) {
                      result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
                    } else {
                      result2.__views__.push({
                        "size": nativeMin(n, MAX_ARRAY_LENGTH),
                        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                      });
                    }
                    return result2;
                  };
                  LazyWrapper.prototype[methodName + "Right"] = function(n) {
                    return this.reverse()[methodName](n).reverse();
                  };
                });
                arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
                  var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                  LazyWrapper.prototype[methodName] = function(iteratee2) {
                    var result2 = this.clone();
                    result2.__iteratees__.push({
                      "iteratee": getIteratee(iteratee2, 3),
                      "type": type
                    });
                    result2.__filtered__ = result2.__filtered__ || isFilter;
                    return result2;
                  };
                });
                arrayEach(["head", "last"], function(methodName, index) {
                  var takeName = "take" + (index ? "Right" : "");
                  LazyWrapper.prototype[methodName] = function() {
                    return this[takeName](1).value()[0];
                  };
                });
                arrayEach(["initial", "tail"], function(methodName, index) {
                  var dropName = "drop" + (index ? "" : "Right");
                  LazyWrapper.prototype[methodName] = function() {
                    return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                  };
                });
                LazyWrapper.prototype.compact = function() {
                  return this.filter(identity);
                };
                LazyWrapper.prototype.find = function(predicate) {
                  return this.filter(predicate).head();
                };
                LazyWrapper.prototype.findLast = function(predicate) {
                  return this.reverse().find(predicate);
                };
                LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                  if (typeof path == "function") {
                    return new LazyWrapper(this);
                  }
                  return this.map(function(value) {
                    return baseInvoke(value, path, args);
                  });
                });
                LazyWrapper.prototype.reject = function(predicate) {
                  return this.filter(negate(getIteratee(predicate)));
                };
                LazyWrapper.prototype.slice = function(start, end) {
                  start = toInteger(start);
                  var result2 = this;
                  if (result2.__filtered__ && (start > 0 || end < 0)) {
                    return new LazyWrapper(result2);
                  }
                  if (start < 0) {
                    result2 = result2.takeRight(-start);
                  } else if (start) {
                    result2 = result2.drop(start);
                  }
                  if (end !== undefined2) {
                    end = toInteger(end);
                    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
                  }
                  return result2;
                };
                LazyWrapper.prototype.takeRightWhile = function(predicate) {
                  return this.reverse().takeWhile(predicate).reverse();
                };
                LazyWrapper.prototype.toArray = function() {
                  return this.take(MAX_ARRAY_LENGTH);
                };
                baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                  if (!lodashFunc) {
                    return;
                  }
                  lodash.prototype[methodName] = function() {
                    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
                    var interceptor = function(value2) {
                      var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                      return isTaker && chainAll ? result3[0] : result3;
                    };
                    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                      isLazy = useLazy = false;
                    }
                    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                    if (!retUnwrapped && useLazy) {
                      value = onlyLazy ? value : new LazyWrapper(this);
                      var result2 = func.apply(value, args);
                      result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                      return new LodashWrapper(result2, chainAll);
                    }
                    if (isUnwrapped && onlyLazy) {
                      return func.apply(this, args);
                    }
                    result2 = this.thru(interceptor);
                    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
                  };
                });
                arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                  var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                  lodash.prototype[methodName] = function() {
                    var args = arguments;
                    if (retUnwrapped && !this.__chain__) {
                      var value = this.value();
                      return func.apply(isArray2(value) ? value : [], args);
                    }
                    return this[chainName](function(value2) {
                      return func.apply(isArray2(value2) ? value2 : [], args);
                    });
                  };
                });
                baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                  var lodashFunc = lodash[methodName];
                  if (lodashFunc) {
                    var key = lodashFunc.name + "";
                    if (!hasOwnProperty.call(realNames, key)) {
                      realNames[key] = [];
                    }
                    realNames[key].push({ "name": methodName, "func": lodashFunc });
                  }
                });
                realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
                  "name": "wrapper",
                  "func": undefined2
                }];
                LazyWrapper.prototype.clone = lazyClone;
                LazyWrapper.prototype.reverse = lazyReverse;
                LazyWrapper.prototype.value = lazyValue;
                lodash.prototype.at = wrapperAt;
                lodash.prototype.chain = wrapperChain;
                lodash.prototype.commit = wrapperCommit;
                lodash.prototype.next = wrapperNext;
                lodash.prototype.plant = wrapperPlant;
                lodash.prototype.reverse = wrapperReverse;
                lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                lodash.prototype.first = lodash.prototype.head;
                if (symIterator) {
                  lodash.prototype[symIterator] = wrapperToIterator;
                }
                return lodash;
              };
              var _ = runInContext();
              if (true) {
                root._ = _;
                !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                  return _;
                }).call(exports2, __webpack_require__, exports2, module3), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined2 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else {
              }
            }).call(this);
          }).call(this, __webpack_require__("c8ba"), __webpack_require__("62e4")(module2));
        }
      ),
      /***/
      "342f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var getBuiltIn = __webpack_require__("d066");
          module2.exports = getBuiltIn("navigator", "userAgent") || "";
        }
      ),
      /***/
      "37c8": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
          function render(_ctx, _cache, $props, $setup, $data, $options) {
            var _component_grid_item = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])("grid-item");
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", {
              ref: "item",
              class: "vue-grid-layout",
              style: _ctx.mergedStyle
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default"), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(_component_grid_item, {
              class: "vue-grid-placeholder",
              x: _ctx.placeholder.x,
              y: _ctx.placeholder.y,
              w: _ctx.placeholder.w,
              h: _ctx.placeholder.h,
              i: _ctx.placeholder.i
            }, null, 8, ["x", "y", "w", "h", "i"]), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], _ctx.isDragging]])], 4);
          }
          var es_object_keys = __webpack_require__("b64b");
          var es_symbol = __webpack_require__("a4d3");
          var es_array_filter = __webpack_require__("4de4");
          var es_object_get_own_property_descriptor = __webpack_require__("e439");
          var web_dom_collections_for_each = __webpack_require__("159b");
          var es_object_get_own_property_descriptors = __webpack_require__("dbb4");
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly) symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread2(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          var es_number_constructor = __webpack_require__("a9e3");
          var es_array_concat = __webpack_require__("99af");
          var es_number_is_finite = __webpack_require__("f00c");
          var es_object_assign = __webpack_require__("cca6");
          var utils = __webpack_require__("a2b6");
          var responsiveUtils = __webpack_require__("97a7");
          var mitt = __webpack_require__("cfb9");
          var GridItem = __webpack_require__("bc21");
          var DOM = __webpack_require__("1ca7");
          var elementResizeDetectorMaker = __webpack_require__("eec4");
          var GridLayoutvue_type_script_lang_js = {
            name: "GridLayout",
            components: {
              GridItem: GridItem[
                "a"
                /* default */
              ]
            },
            provide: function provide() {
              return {
                layout: this
              };
            },
            props: {
              // If true, the container height swells and contracts to fit contents
              autoSize: {
                type: Boolean,
                default: true
              },
              colNum: {
                type: Number,
                default: 12
              },
              rowHeight: {
                type: Number,
                default: 150
              },
              maxRows: {
                type: Number,
                default: Infinity
              },
              margin: {
                type: Array,
                default: function _default() {
                  return [10, 10];
                }
              },
              isDraggable: {
                type: Boolean,
                default: true
              },
              isResizable: {
                type: Boolean,
                default: true
              },
              isMirrored: {
                type: Boolean,
                default: false
              },
              useCssTransforms: {
                type: Boolean,
                default: true
              },
              verticalCompact: {
                type: Boolean,
                default: true
              },
              layout: {
                type: Array,
                required: true
              },
              responsive: {
                type: Boolean,
                default: false
              },
              responsiveLayouts: {
                type: Object,
                default: function _default() {
                  return {};
                }
              },
              breakpoints: {
                type: Object,
                default: function _default() {
                  return {
                    lg: 1200,
                    md: 996,
                    sm: 768,
                    xs: 480,
                    xxs: 0
                  };
                }
              },
              cols: {
                type: Object,
                default: function _default() {
                  return {
                    lg: 12,
                    md: 10,
                    sm: 6,
                    xs: 4,
                    xxs: 2
                  };
                }
              },
              preventCollision: {
                type: Boolean,
                default: false
              },
              useStyleCursor: {
                type: Boolean,
                default: true
              }
            },
            emits: ["update:layout", "layout-created", "layout-before-mount", "layout-mounted", "layout-updated", "updateWidth", "layout-ready", "setColNum", "setRowHeight", "setDraggable", "setResizable", "setMaxRows", "resizeEvent", "compact", "breakpoint-changed"],
            data: function data() {
              return {
                width: null,
                mergedStyle: {},
                lastLayoutLength: 0,
                isDragging: false,
                placeholder: {
                  x: 0,
                  y: 0,
                  w: 0,
                  h: 0,
                  i: -1
                },
                layouts: {},
                // array to store all layouts from different breakpoints
                lastBreakpoint: null,
                // store last active breakpoint
                originalLayout: null
                // store original Layout
              };
            },
            created: function created() {
              var self2 = this;
              self2.resizeEventHandler = function(params) {
                self2.resizeEvent(params);
              };
              self2.dragEventHandler = function(params) {
                self2.dragEvent(params);
              };
              mitt[
                "a"
                /* default */
              ].$on("resizeEvent", self2.resizeEventHandler);
              mitt[
                "a"
                /* default */
              ].$on("dragEvent", self2.dragEventHandler);
              self2.$emit("layout-created", self2.layout);
            },
            beforeUnmount: function beforeUnmount() {
              mitt[
                "a"
                /* default */
              ].$off("resizeEvent", this.resizeEventHandler);
              mitt[
                "a"
                /* default */
              ].$off("dragEvent", this.dragEventHandler);
              Object(DOM[
                "c"
                /* removeWindowEventListener */
              ])("resize", this.onWindowResize);
              if (this.erd) {
                this.erd.uninstall(this.$refs.item);
              }
            },
            beforeMount: function beforeMount() {
              this.$emit("layout-before-mount", this.layout);
            },
            mounted: function mounted() {
              this.$emit("layout-mounted", this.layout);
              this.$nextTick(function() {
                Object(utils[
                  "l"
                  /* validateLayout */
                ])(this.layout);
                this.originalLayout = this.layout;
                var self2 = this;
                this.$nextTick(function() {
                  self2.onWindowResize();
                  self2.initResponsiveFeatures();
                  Object(DOM[
                    "a"
                    /* addWindowEventListener */
                  ])("resize", self2.onWindowResize);
                  Object(utils[
                    "c"
                    /* compact */
                  ])(self2.layout, self2.verticalCompact);
                  self2.$emit("layout-updated", self2.layout);
                  self2.updateHeight();
                  self2.$nextTick(function() {
                    this.erd = elementResizeDetectorMaker({
                      strategy: "scroll",
                      //<- For ultra performance.
                      // See https://github.com/wnr/element-resize-detector/issues/110 about callOnAdd.
                      callOnAdd: false
                    });
                    this.erd.listenTo(self2.$refs.item, function() {
                      self2.onWindowResize();
                    });
                  });
                });
              });
            },
            watch: {
              width: function width(newval, oldval) {
                var self2 = this;
                this.$nextTick(function() {
                  var _this = this;
                  mitt[
                    "a"
                    /* default */
                  ].$emit("updateWidth", this.width);
                  if (oldval === null) {
                    this.$nextTick(function() {
                      _this.$emit("layout-ready", self2.layout);
                    });
                  }
                  this.updateHeight();
                });
              },
              layout: function layout() {
                this.layoutUpdate();
              },
              colNum: function colNum(val) {
                mitt[
                  "a"
                  /* default */
                ].$emit("setColNum", val);
              },
              rowHeight: function rowHeight() {
                mitt[
                  "a"
                  /* default */
                ].$emit("setRowHeight", this.rowHeight);
              },
              isDraggable: function isDraggable() {
                mitt[
                  "a"
                  /* default */
                ].$emit("setDraggable", this.isDraggable);
              },
              isResizable: function isResizable() {
                mitt[
                  "a"
                  /* default */
                ].$emit("setResizable", this.isResizable);
              },
              responsive: function responsive() {
                if (!this.responsive) {
                  this.$emit("update:layout", this.originalLayout);
                  mitt[
                    "a"
                    /* default */
                  ].$emit("setColNum", this.colNum);
                }
                this.onWindowResize();
              },
              maxRows: function maxRows() {
                mitt[
                  "a"
                  /* default */
                ].$emit("setMaxRows", this.maxRows);
              },
              margin: function margin() {
                this.updateHeight();
              }
            },
            methods: {
              layoutUpdate: function layoutUpdate() {
                if (this.layout !== void 0 && this.originalLayout !== null) {
                  if (this.layout.length !== this.originalLayout.length) {
                    var diff = this.findDifference(this.layout, this.originalLayout);
                    if (diff.length > 0) {
                      if (this.layout.length > this.originalLayout.length) {
                        this.originalLayout = this.originalLayout.concat(diff);
                      } else {
                        this.originalLayout = this.originalLayout.filter(function(obj) {
                          return !diff.some(function(obj2) {
                            return obj.i === obj2.i;
                          });
                        });
                      }
                    }
                    this.lastLayoutLength = this.layout.length;
                    this.initResponsiveFeatures();
                  }
                  Object(utils[
                    "c"
                    /* compact */
                  ])(this.layout, this.verticalCompact);
                  mitt[
                    "a"
                    /* default */
                  ].$emit("updateWidth", this.width);
                  this.updateHeight();
                  this.$emit("layout-updated", this.layout);
                }
              },
              updateHeight: function updateHeight() {
                this.mergedStyle = {
                  height: this.containerHeight()
                };
              },
              onWindowResize: function onWindowResize() {
                if (this.$refs !== null && this.$refs.item !== null && this.$refs.item !== void 0) {
                  this.width = this.$refs.item.offsetWidth;
                }
                mitt[
                  "a"
                  /* default */
                ].$emit("resizeEvent");
              },
              containerHeight: function containerHeight() {
                if (!this.autoSize) return;
                var containerHeight2 = Object(utils[
                  "a"
                  /* bottom */
                ])(this.layout) * (this.rowHeight + this.margin[1]) + this.margin[1] + "px";
                return containerHeight2;
              },
              dragEvent: function dragEvent(params) {
                var eventName = params[0];
                var id = params[1];
                var x = params[2];
                var y = params[3];
                var h = params[4];
                var w = params[5];
                var l = Object(utils[
                  "f"
                  /* getLayoutItem */
                ])(this.layout, id);
                if (l === void 0 || l === null) {
                  l = {
                    x: 0,
                    y: 0
                  };
                }
                if (eventName === "dragmove" || eventName === "dragstart") {
                  this.placeholder.i = id;
                  this.placeholder.x = l.x;
                  this.placeholder.y = l.y;
                  this.placeholder.w = w;
                  this.placeholder.h = h;
                  this.$nextTick(function() {
                    this.isDragging = true;
                  });
                  mitt[
                    "a"
                    /* default */
                  ].$emit("updateWidth", this.width);
                } else {
                  this.$nextTick(function() {
                    this.isDragging = false;
                  });
                }
                this.$emit("update:layout", Object(utils[
                  "g"
                  /* moveElement */
                ])(this.layout, l, x, y, true, this.preventCollision));
                Object(utils[
                  "c"
                  /* compact */
                ])(this.layout, this.verticalCompact);
                mitt[
                  "a"
                  /* default */
                ].$emit("compact");
                this.updateHeight();
                if (eventName === "dragend") this.$emit("layout-updated", this.layout);
              },
              resizeEvent: function resizeEvent(params) {
                var eventName = params[0];
                var id = params[1];
                var x = params[2];
                var y = params[3];
                var h = params[4];
                var w = params[5];
                var l = Object(utils[
                  "f"
                  /* getLayoutItem */
                ])(this.layout, id);
                if (l === void 0 || l === null) {
                  l = {
                    h: 0,
                    w: 0
                  };
                }
                var hasCollisions;
                if (this.preventCollision) {
                  var collisions = Object(utils[
                    "e"
                    /* getAllCollisions */
                  ])(this.layout, _objectSpread2(_objectSpread2({}, l), {}, {
                    w,
                    h
                  })).filter(function(layoutItem) {
                    return layoutItem.i !== l.i;
                  });
                  hasCollisions = collisions.length > 0;
                  if (hasCollisions) {
                    var leastX = Infinity, leastY = Infinity;
                    collisions.forEach(function(layoutItem) {
                      if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);
                      if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);
                    });
                    if (Number.isFinite(leastX)) l.w = leastX - l.x;
                    if (Number.isFinite(leastY)) l.h = leastY - l.y;
                  }
                }
                if (!hasCollisions) {
                  l.w = w;
                  l.h = h;
                }
                if (eventName === "resizestart" || eventName === "resizemove") {
                  this.placeholder.i = id;
                  this.placeholder.x = x;
                  this.placeholder.y = y;
                  this.placeholder.w = l.w;
                  this.placeholder.h = l.h;
                  this.$nextTick(function() {
                    this.isDragging = true;
                  });
                  mitt[
                    "a"
                    /* default */
                  ].$emit("updateWidth", this.width);
                } else {
                  this.$nextTick(function() {
                    this.isDragging = false;
                  });
                }
                if (this.responsive) this.responsiveGridLayout();
                Object(utils[
                  "c"
                  /* compact */
                ])(this.layout, this.verticalCompact);
                mitt[
                  "a"
                  /* default */
                ].$emit("compact");
                this.updateHeight();
                if (eventName === "resizeend") this.$emit("layout-updated", this.layout);
              },
              // finds or generates new layouts for set breakpoints
              responsiveGridLayout: function responsiveGridLayout() {
                var newBreakpoint = Object(responsiveUtils[
                  "b"
                  /* getBreakpointFromWidth */
                ])(this.breakpoints, this.width);
                var newCols = Object(responsiveUtils[
                  "c"
                  /* getColsFromBreakpoint */
                ])(newBreakpoint, this.cols);
                if (this.lastBreakpoint != null && !this.layouts[this.lastBreakpoint]) this.layouts[this.lastBreakpoint] = Object(utils[
                  "b"
                  /* cloneLayout */
                ])(this.layout);
                var layout = Object(responsiveUtils[
                  "a"
                  /* findOrGenerateResponsiveLayout */
                ])(this.originalLayout, this.layouts, this.breakpoints, newBreakpoint, this.lastBreakpoint, newCols, this.verticalCompact);
                this.layouts[newBreakpoint] = layout;
                if (this.lastBreakpoint !== newBreakpoint) {
                  this.$emit("breakpoint-changed", newBreakpoint, layout);
                }
                this.$emit("update:layout", layout);
                this.lastBreakpoint = newBreakpoint;
                mitt[
                  "a"
                  /* default */
                ].$emit("setColNum", Object(responsiveUtils[
                  "c"
                  /* getColsFromBreakpoint */
                ])(newBreakpoint, this.cols));
              },
              // clear all responsive layouts
              initResponsiveFeatures: function initResponsiveFeatures() {
                this.layouts = Object.assign({}, this.responsiveLayouts);
              },
              // find difference in layouts
              findDifference: function findDifference(layout, originalLayout) {
                var uniqueResultOne = layout.filter(function(obj) {
                  return !originalLayout.some(function(obj2) {
                    return obj.i === obj2.i;
                  });
                });
                var uniqueResultTwo = originalLayout.filter(function(obj) {
                  return !layout.some(function(obj2) {
                    return obj.i === obj2.i;
                  });
                });
                return uniqueResultOne.concat(uniqueResultTwo);
              }
            }
          };
          var GridLayoutvue_type_style_index_0_id_ecf32d88_lang_css = __webpack_require__("dc59");
          GridLayoutvue_type_script_lang_js.render = render;
          var GridLayout = __webpack_exports__["a"] = GridLayoutvue_type_script_lang_js;
        }
      ),
      /***/
      "37e8": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var definePropertyModule = __webpack_require__("9bf2");
          var anObject = __webpack_require__("825a");
          var objectKeys = __webpack_require__("df75");
          module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
            anObject(O);
            var keys = objectKeys(Properties);
            var length = keys.length;
            var index = 0;
            var key;
            while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
            return O;
          };
        }
      ),
      /***/
      "3bbe": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          module2.exports = function(it) {
            if (!isObject2(it) && it !== null) {
              throw TypeError("Can't set " + String(it) + " as a prototype");
            }
            return it;
          };
        }
      ),
      /***/
      "428f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          module2.exports = global;
        }
      ),
      /***/
      "44ad": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          var classof = __webpack_require__("c6b6");
          var split = "".split;
          module2.exports = fails(function() {
            return !Object("z").propertyIsEnumerable(0);
          }) ? function(it) {
            return classof(it) == "String" ? split.call(it, "") : Object(it);
          } : Object;
        }
      ),
      /***/
      "466d": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
          var anObject = __webpack_require__("825a");
          var toLength = __webpack_require__("50c4");
          var requireObjectCoercible = __webpack_require__("1d80");
          var advanceStringIndex = __webpack_require__("8aa5");
          var regExpExec = __webpack_require__("14c3");
          fixRegExpWellKnownSymbolLogic("match", 1, function(MATCH, nativeMatch, maybeCallNative) {
            return [
              // `String.prototype.match` method
              // https://tc39.es/ecma262/#sec-string.prototype.match
              function match(regexp) {
                var O = requireObjectCoercible(this);
                var matcher = regexp == void 0 ? void 0 : regexp[MATCH];
                return matcher !== void 0 ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
              },
              // `RegExp.prototype[@@match]` method
              // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
              function(regexp) {
                var res = maybeCallNative(nativeMatch, regexp, this);
                if (res.done) return res.value;
                var rx = anObject(regexp);
                var S = String(this);
                if (!rx.global) return regExpExec(rx, S);
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
                var A = [];
                var n = 0;
                var result;
                while ((result = regExpExec(rx, S)) !== null) {
                  var matchStr = String(result[0]);
                  A[n] = matchStr;
                  if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                  n++;
                }
                return n === 0 ? null : A;
              }
            ];
          });
        }
      ),
      /***/
      "4930": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var IS_NODE = __webpack_require__("605d");
          var V8_VERSION = __webpack_require__("2d00");
          var fails = __webpack_require__("d039");
          module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
            return !Symbol.sham && // Chrome 38 Symbol has incorrect toString conversion
            // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
            (IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
          });
        }
      ),
      /***/
      "498a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var $trim = __webpack_require__("58a8").trim;
          var forcedStringTrimMethod = __webpack_require__("c8d2");
          $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
            trim: function trim() {
              return $trim(this);
            }
          });
        }
      ),
      /***/
      "499e": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, "default", function() {
            return (
              /* binding */
              addStylesClient
            );
          });
          function listToStyles(parentId, list) {
            var styles = [];
            var newStyles = {};
            for (var i = 0; i < list.length; i++) {
              var item = list[i];
              var id = item[0];
              var css = item[1];
              var media = item[2];
              var sourceMap = item[3];
              var part = {
                id: parentId + ":" + i,
                css,
                media,
                sourceMap
              };
              if (!newStyles[id]) {
                styles.push(newStyles[id] = { id, parts: [part] });
              } else {
                newStyles[id].parts.push(part);
              }
            }
            return styles;
          }
          var hasDocument = typeof document !== "undefined";
          if (typeof DEBUG !== "undefined" && DEBUG) {
            if (!hasDocument) {
              throw new Error(
                "vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
              );
            }
          }
          var stylesInDom = {
            /*
              [id: number]: {
                id: number,
                refs: number,
                parts: Array<(obj?: StyleObjectPart) => void>
              }
            */
          };
          var head = hasDocument && (document.head || document.getElementsByTagName("head")[0]);
          var singletonElement = null;
          var singletonCounter = 0;
          var isProduction = false;
          var noop = function() {
          };
          var options = null;
          var ssrIdKey = "data-vue-ssr-id";
          var isOldIE = typeof navigator !== "undefined" && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
          function addStylesClient(parentId, list, _isProduction, _options) {
            isProduction = _isProduction;
            options = _options || {};
            var styles = listToStyles(parentId, list);
            addStylesToDom(styles);
            return function update(newList) {
              var mayRemove = [];
              for (var i = 0; i < styles.length; i++) {
                var item = styles[i];
                var domStyle = stylesInDom[item.id];
                domStyle.refs--;
                mayRemove.push(domStyle);
              }
              if (newList) {
                styles = listToStyles(parentId, newList);
                addStylesToDom(styles);
              } else {
                styles = [];
              }
              for (var i = 0; i < mayRemove.length; i++) {
                var domStyle = mayRemove[i];
                if (domStyle.refs === 0) {
                  for (var j = 0; j < domStyle.parts.length; j++) {
                    domStyle.parts[j]();
                  }
                  delete stylesInDom[domStyle.id];
                }
              }
            };
          }
          function addStylesToDom(styles) {
            for (var i = 0; i < styles.length; i++) {
              var item = styles[i];
              var domStyle = stylesInDom[item.id];
              if (domStyle) {
                domStyle.refs++;
                for (var j = 0; j < domStyle.parts.length; j++) {
                  domStyle.parts[j](item.parts[j]);
                }
                for (; j < item.parts.length; j++) {
                  domStyle.parts.push(addStyle(item.parts[j]));
                }
                if (domStyle.parts.length > item.parts.length) {
                  domStyle.parts.length = item.parts.length;
                }
              } else {
                var parts = [];
                for (var j = 0; j < item.parts.length; j++) {
                  parts.push(addStyle(item.parts[j]));
                }
                stylesInDom[item.id] = { id: item.id, refs: 1, parts };
              }
            }
          }
          function createStyleElement() {
            var styleElement = document.createElement("style");
            styleElement.type = "text/css";
            head.appendChild(styleElement);
            return styleElement;
          }
          function addStyle(obj) {
            var update, remove;
            var styleElement = document.querySelector("style[" + ssrIdKey + '~="' + obj.id + '"]');
            if (styleElement) {
              if (isProduction) {
                return noop;
              } else {
                styleElement.parentNode.removeChild(styleElement);
              }
            }
            if (isOldIE) {
              var styleIndex = singletonCounter++;
              styleElement = singletonElement || (singletonElement = createStyleElement());
              update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
              remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
            } else {
              styleElement = createStyleElement();
              update = applyToTag.bind(null, styleElement);
              remove = function() {
                styleElement.parentNode.removeChild(styleElement);
              };
            }
            update(obj);
            return function updateStyle(newObj) {
              if (newObj) {
                if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                  return;
                }
                update(obj = newObj);
              } else {
                remove();
              }
            };
          }
          var replaceText = /* @__PURE__ */ function() {
            var textStore = [];
            return function(index, replacement) {
              textStore[index] = replacement;
              return textStore.filter(Boolean).join("\n");
            };
          }();
          function applyToSingletonTag(styleElement, index, remove, obj) {
            var css = remove ? "" : obj.css;
            if (styleElement.styleSheet) {
              styleElement.styleSheet.cssText = replaceText(index, css);
            } else {
              var cssNode = document.createTextNode(css);
              var childNodes = styleElement.childNodes;
              if (childNodes[index]) styleElement.removeChild(childNodes[index]);
              if (childNodes.length) {
                styleElement.insertBefore(cssNode, childNodes[index]);
              } else {
                styleElement.appendChild(cssNode);
              }
            }
          }
          function applyToTag(styleElement, obj) {
            var css = obj.css;
            var media = obj.media;
            var sourceMap = obj.sourceMap;
            if (media) {
              styleElement.setAttribute("media", media);
            }
            if (options.ssrId) {
              styleElement.setAttribute(ssrIdKey, obj.id);
            }
            if (sourceMap) {
              css += "\n/*# sourceURL=" + sourceMap.sources[0] + " */";
              css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
            }
            if (styleElement.styleSheet) {
              styleElement.styleSheet.cssText = css;
            } else {
              while (styleElement.firstChild) {
                styleElement.removeChild(styleElement.firstChild);
              }
              styleElement.appendChild(document.createTextNode(css));
            }
          }
        }
      ),
      /***/
      "49ad": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          module2.exports = function(idHandler) {
            var eventListeners = {};
            function getListeners(element) {
              var id = idHandler.get(element);
              if (id === void 0) {
                return [];
              }
              return eventListeners[id] || [];
            }
            function addListener(element, listener) {
              var id = idHandler.get(element);
              if (!eventListeners[id]) {
                eventListeners[id] = [];
              }
              eventListeners[id].push(listener);
            }
            function removeListener(element, listener) {
              var listeners = getListeners(element);
              for (var i = 0, len = listeners.length; i < len; ++i) {
                if (listeners[i] === listener) {
                  listeners.splice(i, 1);
                  break;
                }
              }
            }
            function removeAllListeners(element) {
              var listeners = getListeners(element);
              if (!listeners) {
                return;
              }
              listeners.length = 0;
            }
            return {
              get: getListeners,
              add: addListener,
              removeListener,
              removeAllListeners
            };
          };
        }
      ),
      /***/
      "4d64": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toIndexedObject = __webpack_require__("fc6a");
          var toLength = __webpack_require__("50c4");
          var toAbsoluteIndex = __webpack_require__("23cb");
          var createMethod = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIndexedObject($this);
              var length = toLength(O.length);
              var index = toAbsoluteIndex(fromIndex, length);
              var value;
              if (IS_INCLUDES && el != el) while (length > index) {
                value = O[index++];
                if (value != value) return true;
              }
              else for (; length > index; index++) {
                if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
              }
              return !IS_INCLUDES && -1;
            };
          };
          module2.exports = {
            // `Array.prototype.includes` method
            // https://tc39.es/ecma262/#sec-array.prototype.includes
            includes: createMethod(true),
            // `Array.prototype.indexOf` method
            // https://tc39.es/ecma262/#sec-array.prototype.indexof
            indexOf: createMethod(false)
          };
        }
      ),
      /***/
      "4de4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var $filter = __webpack_require__("b727").filter;
          var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
          $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            filter: function filter(callbackfn) {
              return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            }
          });
        }
      ),
      /***/
      "5058": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          module2.exports = function(options) {
            var idGenerator = options.idGenerator;
            var getState = options.stateHandler.getState;
            function getId(element) {
              var state = getState(element);
              if (state && state.id !== void 0) {
                return state.id;
              }
              return null;
            }
            function setId(element) {
              var state = getState(element);
              if (!state) {
                throw new Error("setId required the element to have a resize detection state.");
              }
              var id = idGenerator.generate();
              state.id = id;
              return id;
            }
            return {
              get: getId,
              set: setId
            };
          };
        }
      ),
      /***/
      "50bf": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var utils = module2.exports = {};
          utils.getOption = getOption;
          function getOption(options, name, defaultValue) {
            var value = options[name];
            if ((value === void 0 || value === null) && defaultValue !== void 0) {
              return defaultValue;
            }
            return value;
          }
        }
      ),
      /***/
      "50c4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("a691");
          var min = Math.min;
          module2.exports = function(argument) {
            return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
          };
        }
      ),
      /***/
      "5135": (
        /***/
        function(module2, exports2) {
          var hasOwnProperty = {}.hasOwnProperty;
          module2.exports = function(it, key) {
            return hasOwnProperty.call(it, key);
          };
        }
      ),
      /***/
      "5319": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
          var anObject = __webpack_require__("825a");
          var toLength = __webpack_require__("50c4");
          var toInteger = __webpack_require__("a691");
          var requireObjectCoercible = __webpack_require__("1d80");
          var advanceStringIndex = __webpack_require__("8aa5");
          var getSubstitution = __webpack_require__("0cb2");
          var regExpExec = __webpack_require__("14c3");
          var max = Math.max;
          var min = Math.min;
          var maybeToString = function(it) {
            return it === void 0 ? it : String(it);
          };
          fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
            var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
            var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
            var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
            return [
              // `String.prototype.replace` method
              // https://tc39.es/ecma262/#sec-string.prototype.replace
              function replace(searchValue, replaceValue) {
                var O = requireObjectCoercible(this);
                var replacer = searchValue == void 0 ? void 0 : searchValue[REPLACE];
                return replacer !== void 0 ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
              },
              // `RegExp.prototype[@@replace]` method
              // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
              function(regexp, replaceValue) {
                if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
                  var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                  if (res.done) return res.value;
                }
                var rx = anObject(regexp);
                var S = String(this);
                var functionalReplace = typeof replaceValue === "function";
                if (!functionalReplace) replaceValue = String(replaceValue);
                var global = rx.global;
                if (global) {
                  var fullUnicode = rx.unicode;
                  rx.lastIndex = 0;
                }
                var results = [];
                while (true) {
                  var result = regExpExec(rx, S);
                  if (result === null) break;
                  results.push(result);
                  if (!global) break;
                  var matchStr = String(result[0]);
                  if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                }
                var accumulatedResult = "";
                var nextSourcePosition = 0;
                for (var i = 0; i < results.length; i++) {
                  result = results[i];
                  var matched = String(result[0]);
                  var position = max(min(toInteger(result.index), S.length), 0);
                  var captures = [];
                  for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
                  var namedCaptures = result.groups;
                  if (functionalReplace) {
                    var replacerArgs = [matched].concat(captures, position, S);
                    if (namedCaptures !== void 0) replacerArgs.push(namedCaptures);
                    var replacement = String(replaceValue.apply(void 0, replacerArgs));
                  } else {
                    replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                  }
                  if (position >= nextSourcePosition) {
                    accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                    nextSourcePosition = position + matched.length;
                  }
                }
                return accumulatedResult + S.slice(nextSourcePosition);
              }
            ];
          });
        }
      ),
      /***/
      "5692": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var IS_PURE = __webpack_require__("c430");
          var store = __webpack_require__("c6cd");
          (module2.exports = function(key, value) {
            return store[key] || (store[key] = value !== void 0 ? value : {});
          })("versions", []).push({
            version: "3.9.1",
            mode: IS_PURE ? "pure" : "global",
            copyright: " 2021 Denis Pushkarev (zloirock.ru)"
          });
        }
      ),
      /***/
      "56ef": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var getBuiltIn = __webpack_require__("d066");
          var getOwnPropertyNamesModule = __webpack_require__("241c");
          var getOwnPropertySymbolsModule = __webpack_require__("7418");
          var anObject = __webpack_require__("825a");
          module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
            var keys = getOwnPropertyNamesModule.f(anObject(it));
            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
          };
        }
      ),
      /***/
      "5899": (
        /***/
        function(module2, exports2) {
          module2.exports = "	\n\v\f\r \u2028\u2029\uFEFF";
        }
      ),
      /***/
      "58a8": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var requireObjectCoercible = __webpack_require__("1d80");
          var whitespaces = __webpack_require__("5899");
          var whitespace = "[" + whitespaces + "]";
          var ltrim = RegExp("^" + whitespace + whitespace + "*");
          var rtrim = RegExp(whitespace + whitespace + "*$");
          var createMethod = function(TYPE) {
            return function($this) {
              var string = String(requireObjectCoercible($this));
              if (TYPE & 1) string = string.replace(ltrim, "");
              if (TYPE & 2) string = string.replace(rtrim, "");
              return string;
            };
          };
          module2.exports = {
            // `String.prototype.{ trimLeft, trimStart }` methods
            // https://tc39.es/ecma262/#sec-string.prototype.trimstart
            start: createMethod(1),
            // `String.prototype.{ trimRight, trimEnd }` methods
            // https://tc39.es/ecma262/#sec-string.prototype.trimend
            end: createMethod(2),
            // `String.prototype.trim` method
            // https://tc39.es/ecma262/#sec-string.prototype.trim
            trim: createMethod(3)
          };
        }
      ),
      /***/
      "58d5": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var content = __webpack_require__("b548");
          if (typeof content === "string") content = [[module2.i, content, ""]];
          if (content.locals) module2.exports = content.locals;
          var add = __webpack_require__("499e").default;
          var update = add("7d9ce1b0", content, true, { "sourceMap": false, "shadowMode": false });
        }
      ),
      /***/
      "5be5": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          module2.exports = function(options) {
            var getState = options.stateHandler.getState;
            function isDetectable(element) {
              var state = getState(element);
              return state && !!state.isDetectable;
            }
            function markAsDetectable(element) {
              getState(element).isDetectable = true;
            }
            function isBusy(element) {
              return !!getState(element).busy;
            }
            function markBusy(element, busy) {
              getState(element).busy = !!busy;
            }
            return {
              isDetectable,
              markAsDetectable,
              isBusy,
              markBusy
            };
          };
        }
      ),
      /***/
      "5c6c": (
        /***/
        function(module2, exports2) {
          module2.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value
            };
          };
        }
      ),
      /***/
      "605d": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var classof = __webpack_require__("c6b6");
          var global = __webpack_require__("da84");
          module2.exports = classof(global.process) == "process";
        }
      ),
      /***/
      "60da": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var DESCRIPTORS = __webpack_require__("83ab");
          var fails = __webpack_require__("d039");
          var objectKeys = __webpack_require__("df75");
          var getOwnPropertySymbolsModule = __webpack_require__("7418");
          var propertyIsEnumerableModule = __webpack_require__("d1e7");
          var toObject = __webpack_require__("7b0b");
          var IndexedObject = __webpack_require__("44ad");
          var nativeAssign = Object.assign;
          var defineProperty = Object.defineProperty;
          module2.exports = !nativeAssign || fails(function() {
            if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, "a", {
              enumerable: true,
              get: function() {
                defineProperty(this, "b", {
                  value: 3,
                  enumerable: false
                });
              }
            }), { b: 2 })).b !== 1) return true;
            var A = {};
            var B = {};
            var symbol = Symbol();
            var alphabet = "abcdefghijklmnopqrst";
            A[symbol] = 7;
            alphabet.split("").forEach(function(chr) {
              B[chr] = chr;
            });
            return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join("") != alphabet;
          }) ? function assign(target, source) {
            var T = toObject(target);
            var argumentsLength = arguments.length;
            var index = 1;
            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            var propertyIsEnumerable = propertyIsEnumerableModule.f;
            while (argumentsLength > index) {
              var S = IndexedObject(arguments[index++]);
              var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
              var length = keys.length;
              var j = 0;
              var key;
              while (length > j) {
                key = keys[j++];
                if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
              }
            }
            return T;
          } : nativeAssign;
        }
      ),
      /***/
      "6110": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var ___CSS_LOADER_API_IMPORT___ = __webpack_require__("24fb");
          exports2 = ___CSS_LOADER_API_IMPORT___(false);
          exports2.push([module2.i, '.vue-grid-item{-webkit-transition:all .2s ease;transition:all .2s ease;-webkit-transition-property:left,top,right;transition-property:left,top,right;-webkit-box-sizing:border-box;box-sizing:border-box}.vue-grid-item,.vue-grid-item.no-touch{-ms-touch-action:none;touch-action:none}.vue-grid-item.cssTransforms{-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;left:0;right:auto}.vue-grid-item.cssTransforms.render-rtl{left:auto;right:0}.vue-grid-item.resizing{opacity:.6;z-index:3}.vue-grid-item.vue-draggable-dragging{-webkit-transition:none;transition:none;z-index:3}.vue-grid-item.vue-grid-placeholder{background:red;opacity:.2;-webkit-transition-duration:.1s;transition-duration:.1s;z-index:2;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none}.vue-grid-item>.vue-resizable-handle{position:absolute;width:20px;height:20px;bottom:0;right:0;background:url("data:image/svg+xml;base64,PHN2ZyBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjojZmZmZmZmMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjYiIGhlaWdodD0iNiI+PHBhdGggZD0iTTYgNkgwVjQuMmg0LjJWMEg2djZ6IiBvcGFjaXR5PSIuMzAyIi8+PC9zdmc+");background-position:100% 100%;padding:0 3px 3px 0;background-repeat:no-repeat;background-origin:content-box;-webkit-box-sizing:border-box;box-sizing:border-box;cursor:se-resize}.vue-grid-item>.vue-rtl-resizable-handle{bottom:0;left:0;background:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAiIGhlaWdodD0iMTAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTS0xLTFoMTJ2MTJILTF6Ii8+PGc+PHBhdGggc3Ryb2tlLWxpbmVjYXA9InVuZGVmaW5lZCIgc3Ryb2tlLWxpbmVqb2luPSJ1bmRlZmluZWQiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2U9IiMwMDAiIGZpbGw9Im5vbmUiIGQ9Ik0xNDQuODIxLTM4LjM5M2wtMjAuMzU3LTMxLjc4NSIvPjxwYXRoIHN0cm9rZT0iIzY2NiIgc3Ryb2tlLWxpbmVjYXA9InVuZGVmaW5lZCIgc3Ryb2tlLWxpbmVqb2luPSJ1bmRlZmluZWQiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSIgZD0iTS45NDctLjAxOHY5LjEyNU0tLjY1NiA5aDEwLjczIi8+PC9nPjwvc3ZnPg==);background-position:0 100%;padding-left:3px;background-repeat:no-repeat;background-origin:content-box;cursor:sw-resize;right:auto}.vue-grid-item.disable-userselect{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}', ""]);
          module2.exports = exports2;
        }
      ),
      /***/
      "62e4": (
        /***/
        function(module2, exports2) {
          module2.exports = function(module3) {
            if (!module3.webpackPolyfill) {
              module3.deprecate = function() {
              };
              module3.paths = [];
              if (!module3.children) module3.children = [];
              Object.defineProperty(module3, "loaded", {
                enumerable: true,
                get: function() {
                  return module3.l;
                }
              });
              Object.defineProperty(module3, "id", {
                enumerable: true,
                get: function() {
                  return module3.i;
                }
              });
              module3.webpackPolyfill = 1;
            }
            return module3;
          };
        }
      ),
      /***/
      "6547": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("a691");
          var requireObjectCoercible = __webpack_require__("1d80");
          var createMethod = function(CONVERT_TO_STRING) {
            return function($this, pos) {
              var S = String(requireObjectCoercible($this));
              var position = toInteger(pos);
              var size = S.length;
              var first, second;
              if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
              first = S.charCodeAt(position);
              return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
            };
          };
          module2.exports = {
            // `String.prototype.codePointAt` method
            // https://tc39.es/ecma262/#sec-string.prototype.codepointat
            codeAt: createMethod(false),
            // `String.prototype.at` method
            // https://github.com/mathiasbynens/String.prototype.at
            charAt: createMethod(true)
          };
        }
      ),
      /***/
      "65f0": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          var isArray2 = __webpack_require__("e8b5");
          var wellKnownSymbol = __webpack_require__("b622");
          var SPECIES = wellKnownSymbol("species");
          module2.exports = function(originalArray, length) {
            var C;
            if (isArray2(originalArray)) {
              C = originalArray.constructor;
              if (typeof C == "function" && (C === Array || isArray2(C.prototype))) C = void 0;
              else if (isObject2(C)) {
                C = C[SPECIES];
                if (C === null) C = void 0;
              }
            }
            return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
          };
        }
      ),
      /***/
      "69f3": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
          var global = __webpack_require__("da84");
          var isObject2 = __webpack_require__("861d");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var objectHas = __webpack_require__("5135");
          var shared = __webpack_require__("c6cd");
          var sharedKey = __webpack_require__("f772");
          var hiddenKeys = __webpack_require__("d012");
          var WeakMap2 = global.WeakMap;
          var set, get, has;
          var enforce = function(it) {
            return has(it) ? get(it) : set(it, {});
          };
          var getterFor = function(TYPE) {
            return function(it) {
              var state;
              if (!isObject2(it) || (state = get(it)).type !== TYPE) {
                throw TypeError("Incompatible receiver, " + TYPE + " required");
              }
              return state;
            };
          };
          if (NATIVE_WEAK_MAP) {
            var store = shared.state || (shared.state = new WeakMap2());
            var wmget = store.get;
            var wmhas = store.has;
            var wmset = store.set;
            set = function(it, metadata) {
              metadata.facade = it;
              wmset.call(store, it, metadata);
              return metadata;
            };
            get = function(it) {
              return wmget.call(store, it) || {};
            };
            has = function(it) {
              return wmhas.call(store, it);
            };
          } else {
            var STATE = sharedKey("state");
            hiddenKeys[STATE] = true;
            set = function(it, metadata) {
              metadata.facade = it;
              createNonEnumerableProperty(it, STATE, metadata);
              return metadata;
            };
            get = function(it) {
              return objectHas(it, STATE) ? it[STATE] : {};
            };
            has = function(it) {
              return objectHas(it, STATE);
            };
          }
          module2.exports = {
            set,
            get,
            has,
            enforce,
            getterFor
          };
        }
      ),
      /***/
      "6eeb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var has = __webpack_require__("5135");
          var setGlobal = __webpack_require__("ce4e");
          var inspectSource = __webpack_require__("8925");
          var InternalStateModule = __webpack_require__("69f3");
          var getInternalState = InternalStateModule.get;
          var enforceInternalState = InternalStateModule.enforce;
          var TEMPLATE = String(String).split("String");
          (module2.exports = function(O, key, value, options) {
            var unsafe = options ? !!options.unsafe : false;
            var simple = options ? !!options.enumerable : false;
            var noTargetGet = options ? !!options.noTargetGet : false;
            var state;
            if (typeof value == "function") {
              if (typeof key == "string" && !has(value, "name")) {
                createNonEnumerableProperty(value, "name", key);
              }
              state = enforceInternalState(value);
              if (!state.source) {
                state.source = TEMPLATE.join(typeof key == "string" ? key : "");
              }
            }
            if (O === global) {
              if (simple) O[key] = value;
              else setGlobal(key, value);
              return;
            } else if (!unsafe) {
              delete O[key];
            } else if (!noTargetGet && O[key]) {
              simple = true;
            }
            if (simple) O[key] = value;
            else createNonEnumerableProperty(O, key, value);
          })(Function.prototype, "toString", function toString() {
            return typeof this == "function" && getInternalState(this).source || inspectSource(this);
          });
        }
      ),
      /***/
      "7156": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          var setPrototypeOf = __webpack_require__("d2bb");
          module2.exports = function($this, dummy, Wrapper) {
            var NewTarget, NewTargetPrototype;
            if (
              // it can work only with native `setPrototypeOf`
              setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
              typeof (NewTarget = dummy.constructor) == "function" && NewTarget !== Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
            ) setPrototypeOf($this, NewTargetPrototype);
            return $this;
          };
        }
      ),
      /***/
      "7418": (
        /***/
        function(module2, exports2) {
          exports2.f = Object.getOwnPropertySymbols;
        }
      ),
      /***/
      "746f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var path = __webpack_require__("428f");
          var has = __webpack_require__("5135");
          var wrappedWellKnownSymbolModule = __webpack_require__("e538");
          var defineProperty = __webpack_require__("9bf2").f;
          module2.exports = function(NAME) {
            var Symbol2 = path.Symbol || (path.Symbol = {});
            if (!has(Symbol2, NAME)) defineProperty(Symbol2, NAME, {
              value: wrappedWellKnownSymbolModule.f(NAME)
            });
          };
        }
      ),
      /***/
      "7839": (
        /***/
        function(module2, exports2) {
          module2.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
          ];
        }
      ),
      /***/
      "7b0b": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var requireObjectCoercible = __webpack_require__("1d80");
          module2.exports = function(argument) {
            return Object(requireObjectCoercible(argument));
          };
        }
      ),
      /***/
      "7c73": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var anObject = __webpack_require__("825a");
          var defineProperties = __webpack_require__("37e8");
          var enumBugKeys = __webpack_require__("7839");
          var hiddenKeys = __webpack_require__("d012");
          var html = __webpack_require__("1be4");
          var documentCreateElement = __webpack_require__("cc12");
          var sharedKey = __webpack_require__("f772");
          var GT = ">";
          var LT = "<";
          var PROTOTYPE = "prototype";
          var SCRIPT = "script";
          var IE_PROTO = sharedKey("IE_PROTO");
          var EmptyConstructor = function() {
          };
          var scriptTag = function(content) {
            return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
          };
          var NullProtoObjectViaActiveX = function(activeXDocument2) {
            activeXDocument2.write(scriptTag(""));
            activeXDocument2.close();
            var temp = activeXDocument2.parentWindow.Object;
            activeXDocument2 = null;
            return temp;
          };
          var NullProtoObjectViaIFrame = function() {
            var iframe = documentCreateElement("iframe");
            var JS = "java" + SCRIPT + ":";
            var iframeDocument;
            iframe.style.display = "none";
            html.appendChild(iframe);
            iframe.src = String(JS);
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(scriptTag("document.F=Object"));
            iframeDocument.close();
            return iframeDocument.F;
          };
          var activeXDocument;
          var NullProtoObject = function() {
            try {
              activeXDocument = document.domain && new ActiveXObject("htmlfile");
            } catch (error) {
            }
            NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
            var length = enumBugKeys.length;
            while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
            return NullProtoObject();
          };
          hiddenKeys[IE_PROTO] = true;
          module2.exports = Object.create || function create(O, Properties) {
            var result;
            if (O !== null) {
              EmptyConstructor[PROTOTYPE] = anObject(O);
              result = new EmptyConstructor();
              EmptyConstructor[PROTOTYPE] = null;
              result[IE_PROTO] = O;
            } else result = NullProtoObject();
            return Properties === void 0 ? result : defineProperties(result, Properties);
          };
        }
      ),
      /***/
      "7f9a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var inspectSource = __webpack_require__("8925");
          var WeakMap2 = global.WeakMap;
          module2.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
        }
      ),
      /***/
      "825a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          module2.exports = function(it) {
            if (!isObject2(it)) {
              throw TypeError(String(it) + " is not an object");
            }
            return it;
          };
        }
      ),
      /***/
      "83ab": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          module2.exports = !fails(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        }
      ),
      /***/
      "8418": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var toPrimitive = __webpack_require__("c04e");
          var definePropertyModule = __webpack_require__("9bf2");
          var createPropertyDescriptor = __webpack_require__("5c6c");
          module2.exports = function(object, key, value) {
            var propertyKey = toPrimitive(key);
            if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
            else object[propertyKey] = value;
          };
        }
      ),
      /***/
      "861d": (
        /***/
        function(module2, exports2) {
          module2.exports = function(it) {
            return typeof it === "object" ? it !== null : typeof it === "function";
          };
        }
      ),
      /***/
      "8875": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          (function(root, factory) {
            if (true) {
              !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
            }
          })(typeof self !== "undefined" ? self : this, function() {
            function getCurrentScript() {
              var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
              if (!descriptor && "currentScript" in document && document.currentScript) {
                return document.currentScript;
              }
              if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
                return document.currentScript;
              }
              try {
                throw new Error();
              } catch (err) {
                var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
                if (scriptLocation === currentLocation) {
                  pageSource = document.documentElement.outerHTML;
                  inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                  inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
                }
                for (var i = 0; i < scripts.length; i++) {
                  if (scripts[i].readyState === "interactive") {
                    return scripts[i];
                  }
                  if (scripts[i].src === scriptLocation) {
                    return scripts[i];
                  }
                  if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) {
                    return scripts[i];
                  }
                }
                return null;
              }
            }
            ;
            return getCurrentScript;
          });
        }
      ),
      /***/
      "8925": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var store = __webpack_require__("c6cd");
          var functionToString = Function.toString;
          if (typeof store.inspectSource != "function") {
            store.inspectSource = function(it) {
              return functionToString.call(it);
            };
          }
          module2.exports = store.inspectSource;
        }
      ),
      /***/
      "8aa5": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var charAt = __webpack_require__("6547").charAt;
          module2.exports = function(S, index, unicode) {
            return index + (unicode ? charAt(S, index).length : 1);
          };
        }
      ),
      /***/
      "8bbf": (
        /***/
        function(module2, exports2) {
          module2.exports = require_vue();
        }
      ),
      /***/
      "90e3": (
        /***/
        function(module2, exports2) {
          var id = 0;
          var postfix = Math.random();
          module2.exports = function(key) {
            return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
          };
        }
      ),
      /***/
      "9112": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var definePropertyModule = __webpack_require__("9bf2");
          var createPropertyDescriptor = __webpack_require__("5c6c");
          module2.exports = DESCRIPTORS ? function(object, key, value) {
            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
          } : function(object, key, value) {
            object[key] = value;
            return object;
          };
        }
      ),
      /***/
      "9263": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var regexpFlags = __webpack_require__("ad6d");
          var stickyHelpers = __webpack_require__("9f7f");
          var nativeExec = RegExp.prototype.exec;
          var nativeReplace = String.prototype.replace;
          var patchedExec = nativeExec;
          var UPDATES_LAST_INDEX_WRONG = function() {
            var re1 = /a/;
            var re2 = /b*/g;
            nativeExec.call(re1, "a");
            nativeExec.call(re2, "a");
            return re1.lastIndex !== 0 || re2.lastIndex !== 0;
          }();
          var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
          var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
          var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
          if (PATCH) {
            patchedExec = function exec(str) {
              var re = this;
              var lastIndex, reCopy, match, i;
              var sticky = UNSUPPORTED_Y && re.sticky;
              var flags = regexpFlags.call(re);
              var source = re.source;
              var charsAdded = 0;
              var strCopy = str;
              if (sticky) {
                flags = flags.replace("y", "");
                if (flags.indexOf("g") === -1) {
                  flags += "g";
                }
                strCopy = String(str).slice(re.lastIndex);
                if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== "\n")) {
                  source = "(?: " + source + ")";
                  strCopy = " " + strCopy;
                  charsAdded++;
                }
                reCopy = new RegExp("^(?:" + source + ")", flags);
              }
              if (NPCG_INCLUDED) {
                reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
              }
              if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
              match = nativeExec.call(sticky ? reCopy : re, strCopy);
              if (sticky) {
                if (match) {
                  match.input = match.input.slice(charsAdded);
                  match[0] = match[0].slice(charsAdded);
                  match.index = re.lastIndex;
                  re.lastIndex += match[0].length;
                } else re.lastIndex = 0;
              } else if (UPDATES_LAST_INDEX_WRONG && match) {
                re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
              }
              if (NPCG_INCLUDED && match && match.length > 1) {
                nativeReplace.call(match[0], reCopy, function() {
                  for (i = 1; i < arguments.length - 2; i++) {
                    if (arguments[i] === void 0) match[i] = void 0;
                  }
                });
              }
              return match;
            };
          }
          module2.exports = patchedExec;
        }
      ),
      /***/
      "94ca": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          var replacement = /#|\.prototype\./;
          var isForced = function(feature, detection) {
            var value = data[normalize(feature)];
            return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
          };
          var normalize = isForced.normalize = function(string) {
            return String(string).replace(replacement, ".").toLowerCase();
          };
          var data = isForced.data = {};
          var NATIVE = isForced.NATIVE = "N";
          var POLYFILL = isForced.POLYFILL = "P";
          module2.exports = isForced;
        }
      ),
      /***/
      "97a7": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return getBreakpointFromWidth;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return getColsFromBreakpoint;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return findOrGenerateResponsiveLayout;
          });
          var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fb6a");
          var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_0__);
          var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("b64b");
          var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_1__);
          var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("a2b6");
          function getBreakpointFromWidth(breakpoints, width) {
            var sorted = sortBreakpoints(breakpoints);
            var matching = sorted[0];
            for (var i = 1, len = sorted.length; i < len; i++) {
              var breakpointName = sorted[i];
              if (width > breakpoints[breakpointName]) matching = breakpointName;
            }
            return matching;
          }
          function getColsFromBreakpoint(breakpoint, cols) {
            if (!cols[breakpoint]) {
              throw new Error("ResponsiveGridLayout: `cols` entry for breakpoint " + breakpoint + " is missing!");
            }
            return cols[breakpoint];
          }
          function findOrGenerateResponsiveLayout(orgLayout, layouts, breakpoints, breakpoint, lastBreakpoint, cols, verticalCompact) {
            if (layouts[breakpoint]) return Object(_utils__WEBPACK_IMPORTED_MODULE_2__[
              /* cloneLayout */
              "b"
            ])(layouts[breakpoint]);
            var layout = orgLayout;
            var breakpointsSorted = sortBreakpoints(breakpoints);
            var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));
            for (var i = 0, len = breakpointsAbove.length; i < len; i++) {
              var b = breakpointsAbove[i];
              if (layouts[b]) {
                layout = layouts[b];
                break;
              }
            }
            layout = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[
              /* cloneLayout */
              "b"
            ])(layout || []);
            return Object(_utils__WEBPACK_IMPORTED_MODULE_2__[
              /* compact */
              "c"
            ])(Object(_utils__WEBPACK_IMPORTED_MODULE_2__[
              /* correctBounds */
              "d"
            ])(layout, {
              cols
            }), verticalCompact);
          }
          function generateResponsiveLayout(layout, breakpoints, breakpoint, lastBreakpoint, cols, verticalCompact) {
            layout = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[
              /* cloneLayout */
              "b"
            ])(layout || []);
            return Object(_utils__WEBPACK_IMPORTED_MODULE_2__[
              /* compact */
              "c"
            ])(Object(_utils__WEBPACK_IMPORTED_MODULE_2__[
              /* correctBounds */
              "d"
            ])(layout, {
              cols
            }), verticalCompact);
          }
          function sortBreakpoints(breakpoints) {
            var keys = Object.keys(breakpoints);
            return keys.sort(function(a, b) {
              return breakpoints[a] - breakpoints[b];
            });
          }
        }
      ),
      /***/
      "99af": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var fails = __webpack_require__("d039");
          var isArray2 = __webpack_require__("e8b5");
          var isObject2 = __webpack_require__("861d");
          var toObject = __webpack_require__("7b0b");
          var toLength = __webpack_require__("50c4");
          var createProperty = __webpack_require__("8418");
          var arraySpeciesCreate = __webpack_require__("65f0");
          var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
          var wellKnownSymbol = __webpack_require__("b622");
          var V8_VERSION = __webpack_require__("2d00");
          var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
          var MAX_SAFE_INTEGER = 9007199254740991;
          var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
          var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
            var array = [];
            array[IS_CONCAT_SPREADABLE] = false;
            return array.concat()[0] !== array;
          });
          var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
          var isConcatSpreadable = function(O) {
            if (!isObject2(O)) return false;
            var spreadable = O[IS_CONCAT_SPREADABLE];
            return spreadable !== void 0 ? !!spreadable : isArray2(O);
          };
          var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
          $({ target: "Array", proto: true, forced: FORCED }, {
            // eslint-disable-next-line no-unused-vars -- required for `.length`
            concat: function concat(arg) {
              var O = toObject(this);
              var A = arraySpeciesCreate(O, 0);
              var n = 0;
              var i, k, length, len, E;
              for (i = -1, length = arguments.length; i < length; i++) {
                E = i === -1 ? O : arguments[i];
                if (isConcatSpreadable(E)) {
                  len = toLength(E.length);
                  if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                  for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
                } else {
                  if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                  createProperty(A, n++, E);
                }
              }
              A.length = n;
              return A;
            }
          });
        }
      ),
      /***/
      "9bf2": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("83ab");
          var IE8_DOM_DEFINE = __webpack_require__("0cfb");
          var anObject = __webpack_require__("825a");
          var toPrimitive = __webpack_require__("c04e");
          var nativeDefineProperty = Object.defineProperty;
          exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE) try {
              return nativeDefineProperty(O, P, Attributes);
            } catch (error) {
            }
            if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
            if ("value" in Attributes) O[P] = Attributes.value;
            return O;
          };
        }
      ),
      /***/
      "9f7f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var fails = __webpack_require__("d039");
          function RE(s, f) {
            return RegExp(s, f);
          }
          exports2.UNSUPPORTED_Y = fails(function() {
            var re = RE("a", "y");
            re.lastIndex = 2;
            return re.exec("abcd") != null;
          });
          exports2.BROKEN_CARET = fails(function() {
            var re = RE("^r", "gy");
            re.lastIndex = 2;
            return re.exec("str") != null;
          });
        }
      ),
      /***/
      "a221": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var content = __webpack_require__("6110");
          if (typeof content === "string") content = [[module2.i, content, ""]];
          if (content.locals) module2.exports = content.locals;
          var add = __webpack_require__("499e").default;
          var update = add("2c55a03e", content, true, { "sourceMap": false, "shadowMode": false });
        }
      ),
      /***/
      "a2b6": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return bottom;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return cloneLayout;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return compact;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return correctBounds;
          });
          __webpack_require__.d(__webpack_exports__, "f", function() {
            return getLayoutItem;
          });
          __webpack_require__.d(__webpack_exports__, "e", function() {
            return getAllCollisions;
          });
          __webpack_require__.d(__webpack_exports__, "g", function() {
            return moveElement;
          });
          __webpack_require__.d(__webpack_exports__, "j", function() {
            return setTransform;
          });
          __webpack_require__.d(__webpack_exports__, "k", function() {
            return setTransformRtl;
          });
          __webpack_require__.d(__webpack_exports__, "h", function() {
            return setTopLeft;
          });
          __webpack_require__.d(__webpack_exports__, "i", function() {
            return setTopRight;
          });
          __webpack_require__.d(__webpack_exports__, "l", function() {
            return validateLayout;
          });
          var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("4de4");
          var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_0__);
          var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("99af");
          var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_1__);
          var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("159b");
          var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2__);
          var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("b64b");
          var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_3__);
          var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("5319");
          var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_4__);
          var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("ac1f");
          var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_5__);
          var core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("a434");
          var core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_6__);
          function bottom(layout) {
            var max = 0, bottomY;
            for (var i = 0, len = layout.length; i < len; i++) {
              bottomY = layout[i].y + layout[i].h;
              if (bottomY > max) max = bottomY;
            }
            return max;
          }
          function cloneLayout(layout) {
            var newLayout = Array(layout.length);
            for (var i = 0, len = layout.length; i < len; i++) {
              newLayout[i] = cloneLayoutItem(layout[i]);
            }
            return newLayout;
          }
          function cloneLayoutItem(layoutItem) {
            return JSON.parse(JSON.stringify(layoutItem));
          }
          function collides(l1, l2) {
            if (l1 === l2) return false;
            if (l1.x + l1.w <= l2.x) return false;
            if (l1.x >= l2.x + l2.w) return false;
            if (l1.y + l1.h <= l2.y) return false;
            if (l1.y >= l2.y + l2.h) return false;
            return true;
          }
          function compact(layout, verticalCompact) {
            var compareWith = getStatics(layout);
            var sorted = sortLayoutItemsByRowCol(layout);
            var out = Array(layout.length);
            for (var i = 0, len = sorted.length; i < len; i++) {
              var l = sorted[i];
              if (!l.static) {
                l = compactItem(compareWith, l, verticalCompact);
                compareWith.push(l);
              }
              out[layout.indexOf(l)] = l;
              l.moved = false;
            }
            return out;
          }
          function compactItem(compareWith, l, verticalCompact) {
            if (verticalCompact) {
              while (l.y > 0 && !getFirstCollision(compareWith, l)) {
                l.y--;
              }
            }
            var collides2;
            while (collides2 = getFirstCollision(compareWith, l)) {
              l.y = collides2.y + collides2.h;
            }
            return l;
          }
          function correctBounds(layout, bounds) {
            var collidesWith = getStatics(layout);
            for (var i = 0, len = layout.length; i < len; i++) {
              var l = layout[i];
              if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;
              if (l.x < 0) {
                l.x = 0;
                l.w = bounds.cols;
              }
              if (!l.static) collidesWith.push(l);
              else {
                while (getFirstCollision(collidesWith, l)) {
                  l.y++;
                }
              }
            }
            return layout;
          }
          function getLayoutItem(layout, id) {
            for (var i = 0, len = layout.length; i < len; i++) {
              if (layout[i].i === id) return layout[i];
            }
          }
          function getFirstCollision(layout, layoutItem) {
            for (var i = 0, len = layout.length; i < len; i++) {
              if (collides(layout[i], layoutItem)) return layout[i];
            }
          }
          function getAllCollisions(layout, layoutItem) {
            return layout.filter(function(l) {
              return collides(l, layoutItem);
            });
          }
          function getStatics(layout) {
            return layout.filter(function(l) {
              return l.static;
            });
          }
          function moveElement(layout, l, x, y, isUserAction, preventCollision) {
            if (l.static) return layout;
            var oldX = l.x;
            var oldY = l.y;
            var movingUp = y && l.y > y;
            if (typeof x === "number") l.x = x;
            if (typeof y === "number") l.y = y;
            l.moved = true;
            var sorted = sortLayoutItemsByRowCol(layout);
            if (movingUp) sorted = sorted.reverse();
            var collisions = getAllCollisions(sorted, l);
            if (preventCollision && collisions.length) {
              l.x = oldX;
              l.y = oldY;
              l.moved = false;
              return layout;
            }
            for (var i = 0, len = collisions.length; i < len; i++) {
              var collision = collisions[i];
              if (collision.moved) continue;
              if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue;
              if (collision.static) {
                layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);
              } else {
                layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);
              }
            }
            return layout;
          }
          function moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction) {
            var preventCollision = false;
            if (isUserAction) {
              var fakeItem = {
                x: itemToMove.x,
                y: itemToMove.y,
                w: itemToMove.w,
                h: itemToMove.h,
                i: "-1"
              };
              fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);
              if (!getFirstCollision(layout, fakeItem)) {
                return moveElement(layout, itemToMove, void 0, fakeItem.y, preventCollision);
              }
            }
            return moveElement(layout, itemToMove, void 0, itemToMove.y + 1, preventCollision);
          }
          function perc(num) {
            return num * 100 + "%";
          }
          function setTransform(top, left, width, height) {
            var translate = "translate3d(" + left + "px," + top + "px, 0)";
            return {
              transform: translate,
              WebkitTransform: translate,
              MozTransform: translate,
              msTransform: translate,
              OTransform: translate,
              width: width + "px",
              height: height + "px",
              position: "absolute"
            };
          }
          function setTransformRtl(top, right, width, height) {
            var translate = "translate3d(" + right * -1 + "px," + top + "px, 0)";
            return {
              transform: translate,
              WebkitTransform: translate,
              MozTransform: translate,
              msTransform: translate,
              OTransform: translate,
              width: width + "px",
              height: height + "px",
              position: "absolute"
            };
          }
          function setTopLeft(top, left, width, height) {
            return {
              top: top + "px",
              left: left + "px",
              width: width + "px",
              height: height + "px",
              position: "absolute"
            };
          }
          function setTopRight(top, right, width, height) {
            return {
              top: top + "px",
              right: right + "px",
              width: width + "px",
              height: height + "px",
              position: "absolute"
            };
          }
          function sortLayoutItemsByRowCol(layout) {
            return [].concat(layout).sort(function(a, b) {
              if (a.y === b.y && a.x === b.x) {
                return 0;
              }
              if (a.y > b.y || a.y === b.y && a.x > b.x) {
                return 1;
              }
              return -1;
            });
          }
          function validateLayout(layout, contextName) {
            contextName = contextName || "Layout";
            var subProps = ["x", "y", "w", "h"];
            if (!Array.isArray(layout)) throw new Error(contextName + " must be an array!");
            for (var i = 0, len = layout.length; i < len; i++) {
              var item = layout[i];
              for (var j = 0; j < subProps.length; j++) {
                if (typeof item[subProps[j]] !== "number") {
                  throw new Error("VueGridLayout: " + contextName + "[" + i + "]." + subProps[j] + " must be a number!");
                }
              }
              if (item.i && typeof item.i !== "string") {
              }
              if (item.static !== void 0 && typeof item.static !== "boolean") {
                throw new Error("VueGridLayout: " + contextName + "[" + i + "].static must be a boolean!");
              }
            }
          }
          function autoBindHandlers(el, fns) {
            fns.forEach(function(key) {
              return el[key] = el[key].bind(el);
            });
          }
          function createMarkup(obj) {
            var keys = Object.keys(obj);
            if (!keys.length) return "";
            var i, len = keys.length;
            var result = "";
            for (i = 0; i < len; i++) {
              var key = keys[i];
              var val = obj[key];
              result += hyphenate(key) + ":" + addPx(key, val) + ";";
            }
            return result;
          }
          var IS_UNITLESS = {
            animationIterationCount: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridRow: true,
            gridColumn: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related properties
            fillOpacity: true,
            stopOpacity: true,
            strokeDashoffset: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function addPx(name, value) {
            if (typeof value === "number" && !IS_UNITLESS[name]) {
              return value + "px";
            } else {
              return value;
            }
          }
          var hyphenateRE = /([a-z\d])([A-Z])/g;
          function hyphenate(str) {
            return str.replace(hyphenateRE, "$1-$2").toLowerCase();
          }
          function findItemInArray(array, property, value) {
            for (var i = 0; i < array.length; i++) {
              if (array[i][property] == value) return true;
            }
            return false;
          }
          function findAndRemove(array, property, value) {
            array.forEach(function(result, index) {
              if (result[property] === value) {
                array.splice(index, 1);
              }
            });
          }
        }
      ),
      /***/
      "a434": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var toAbsoluteIndex = __webpack_require__("23cb");
          var toInteger = __webpack_require__("a691");
          var toLength = __webpack_require__("50c4");
          var toObject = __webpack_require__("7b0b");
          var arraySpeciesCreate = __webpack_require__("65f0");
          var createProperty = __webpack_require__("8418");
          var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
          var max = Math.max;
          var min = Math.min;
          var MAX_SAFE_INTEGER = 9007199254740991;
          var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
          $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            splice: function splice(start, deleteCount) {
              var O = toObject(this);
              var len = toLength(O.length);
              var actualStart = toAbsoluteIndex(start, len);
              var argumentsLength = arguments.length;
              var insertCount, actualDeleteCount, A, k, from, to;
              if (argumentsLength === 0) {
                insertCount = actualDeleteCount = 0;
              } else if (argumentsLength === 1) {
                insertCount = 0;
                actualDeleteCount = len - actualStart;
              } else {
                insertCount = argumentsLength - 2;
                actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
              }
              if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
                throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
              }
              A = arraySpeciesCreate(O, actualDeleteCount);
              for (k = 0; k < actualDeleteCount; k++) {
                from = actualStart + k;
                if (from in O) createProperty(A, k, O[from]);
              }
              A.length = actualDeleteCount;
              if (insertCount < actualDeleteCount) {
                for (k = actualStart; k < len - actualDeleteCount; k++) {
                  from = k + actualDeleteCount;
                  to = k + insertCount;
                  if (from in O) O[to] = O[from];
                  else delete O[to];
                }
                for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
              } else if (insertCount > actualDeleteCount) {
                for (k = len - actualDeleteCount; k > actualStart; k--) {
                  from = k + actualDeleteCount - 1;
                  to = k + insertCount - 1;
                  if (from in O) O[to] = O[from];
                  else delete O[to];
                }
              }
              for (k = 0; k < insertCount; k++) {
                O[k + actualStart] = arguments[k + 2];
              }
              O.length = len - actualDeleteCount + insertCount;
              return A;
            }
          });
        }
      ),
      /***/
      "a4d3": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var global = __webpack_require__("da84");
          var getBuiltIn = __webpack_require__("d066");
          var IS_PURE = __webpack_require__("c430");
          var DESCRIPTORS = __webpack_require__("83ab");
          var NATIVE_SYMBOL = __webpack_require__("4930");
          var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
          var fails = __webpack_require__("d039");
          var has = __webpack_require__("5135");
          var isArray2 = __webpack_require__("e8b5");
          var isObject2 = __webpack_require__("861d");
          var anObject = __webpack_require__("825a");
          var toObject = __webpack_require__("7b0b");
          var toIndexedObject = __webpack_require__("fc6a");
          var toPrimitive = __webpack_require__("c04e");
          var createPropertyDescriptor = __webpack_require__("5c6c");
          var nativeObjectCreate = __webpack_require__("7c73");
          var objectKeys = __webpack_require__("df75");
          var getOwnPropertyNamesModule = __webpack_require__("241c");
          var getOwnPropertyNamesExternal = __webpack_require__("057f");
          var getOwnPropertySymbolsModule = __webpack_require__("7418");
          var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
          var definePropertyModule = __webpack_require__("9bf2");
          var propertyIsEnumerableModule = __webpack_require__("d1e7");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var redefine = __webpack_require__("6eeb");
          var shared = __webpack_require__("5692");
          var sharedKey = __webpack_require__("f772");
          var hiddenKeys = __webpack_require__("d012");
          var uid = __webpack_require__("90e3");
          var wellKnownSymbol = __webpack_require__("b622");
          var wrappedWellKnownSymbolModule = __webpack_require__("e538");
          var defineWellKnownSymbol = __webpack_require__("746f");
          var setToStringTag = __webpack_require__("d44e");
          var InternalStateModule = __webpack_require__("69f3");
          var $forEach = __webpack_require__("b727").forEach;
          var HIDDEN = sharedKey("hidden");
          var SYMBOL = "Symbol";
          var PROTOTYPE = "prototype";
          var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(SYMBOL);
          var ObjectPrototype = Object[PROTOTYPE];
          var $Symbol = global.Symbol;
          var $stringify = getBuiltIn("JSON", "stringify");
          var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          var nativeDefineProperty = definePropertyModule.f;
          var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
          var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
          var AllSymbols = shared("symbols");
          var ObjectPrototypeSymbols = shared("op-symbols");
          var StringToSymbolRegistry = shared("string-to-symbol-registry");
          var SymbolToStringRegistry = shared("symbol-to-string-registry");
          var WellKnownSymbolsStore = shared("wks");
          var QObject = global.QObject;
          var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
          var setSymbolDescriptor = DESCRIPTORS && fails(function() {
            return nativeObjectCreate(nativeDefineProperty({}, "a", {
              get: function() {
                return nativeDefineProperty(this, "a", { value: 7 }).a;
              }
            })).a != 7;
          }) ? function(O, P, Attributes) {
            var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
            if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
            nativeDefineProperty(O, P, Attributes);
            if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
              nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
            }
          } : nativeDefineProperty;
          var wrap = function(tag, description) {
            var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
            setInternalState(symbol, {
              type: SYMBOL,
              tag,
              description
            });
            if (!DESCRIPTORS) symbol.description = description;
            return symbol;
          };
          var isSymbol2 = USE_SYMBOL_AS_UID ? function(it) {
            return typeof it == "symbol";
          } : function(it) {
            return Object(it) instanceof $Symbol;
          };
          var $defineProperty = function defineProperty(O, P, Attributes) {
            if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
            anObject(O);
            var key = toPrimitive(P, true);
            anObject(Attributes);
            if (has(AllSymbols, key)) {
              if (!Attributes.enumerable) {
                if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
                O[HIDDEN][key] = true;
              } else {
                if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
                Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
              }
              return setSymbolDescriptor(O, key, Attributes);
            }
            return nativeDefineProperty(O, key, Attributes);
          };
          var $defineProperties = function defineProperties(O, Properties) {
            anObject(O);
            var properties = toIndexedObject(Properties);
            var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
            $forEach(keys, function(key) {
              if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
            });
            return O;
          };
          var $create = function create(O, Properties) {
            return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
          };
          var $propertyIsEnumerable = function propertyIsEnumerable(V) {
            var P = toPrimitive(V, true);
            var enumerable = nativePropertyIsEnumerable.call(this, P);
            if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
            return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
          };
          var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
            var it = toIndexedObject(O);
            var key = toPrimitive(P, true);
            if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
            var descriptor = nativeGetOwnPropertyDescriptor(it, key);
            if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
              descriptor.enumerable = true;
            }
            return descriptor;
          };
          var $getOwnPropertyNames = function getOwnPropertyNames(O) {
            var names = nativeGetOwnPropertyNames(toIndexedObject(O));
            var result = [];
            $forEach(names, function(key) {
              if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
            });
            return result;
          };
          var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
            var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
            var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
            var result = [];
            $forEach(names, function(key) {
              if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
                result.push(AllSymbols[key]);
              }
            });
            return result;
          };
          if (!NATIVE_SYMBOL) {
            $Symbol = function Symbol2() {
              if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor");
              var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
              var tag = uid(description);
              var setter = function(value) {
                if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
                if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
                setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
              };
              if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
              return wrap(tag, description);
            };
            redefine($Symbol[PROTOTYPE], "toString", function toString() {
              return getInternalState(this).tag;
            });
            redefine($Symbol, "withoutSetter", function(description) {
              return wrap(uid(description), description);
            });
            propertyIsEnumerableModule.f = $propertyIsEnumerable;
            definePropertyModule.f = $defineProperty;
            getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
            getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
            getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
            wrappedWellKnownSymbolModule.f = function(name) {
              return wrap(wellKnownSymbol(name), name);
            };
            if (DESCRIPTORS) {
              nativeDefineProperty($Symbol[PROTOTYPE], "description", {
                configurable: true,
                get: function description() {
                  return getInternalState(this).description;
                }
              });
              if (!IS_PURE) {
                redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
              }
            }
          }
          $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
            Symbol: $Symbol
          });
          $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
            defineWellKnownSymbol(name);
          });
          $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
            // `Symbol.for` method
            // https://tc39.es/ecma262/#sec-symbol.for
            "for": function(key) {
              var string = String(key);
              if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
              var symbol = $Symbol(string);
              StringToSymbolRegistry[string] = symbol;
              SymbolToStringRegistry[symbol] = string;
              return symbol;
            },
            // `Symbol.keyFor` method
            // https://tc39.es/ecma262/#sec-symbol.keyfor
            keyFor: function keyFor(sym) {
              if (!isSymbol2(sym)) throw TypeError(sym + " is not a symbol");
              if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
            },
            useSetter: function() {
              USE_SETTER = true;
            },
            useSimple: function() {
              USE_SETTER = false;
            }
          });
          $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
            // `Object.create` method
            // https://tc39.es/ecma262/#sec-object.create
            create: $create,
            // `Object.defineProperty` method
            // https://tc39.es/ecma262/#sec-object.defineproperty
            defineProperty: $defineProperty,
            // `Object.defineProperties` method
            // https://tc39.es/ecma262/#sec-object.defineproperties
            defineProperties: $defineProperties,
            // `Object.getOwnPropertyDescriptor` method
            // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor
          });
          $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
            // `Object.getOwnPropertyNames` method
            // https://tc39.es/ecma262/#sec-object.getownpropertynames
            getOwnPropertyNames: $getOwnPropertyNames,
            // `Object.getOwnPropertySymbols` method
            // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
            getOwnPropertySymbols: $getOwnPropertySymbols
          });
          $({ target: "Object", stat: true, forced: fails(function() {
            getOwnPropertySymbolsModule.f(1);
          }) }, {
            getOwnPropertySymbols: function getOwnPropertySymbols(it) {
              return getOwnPropertySymbolsModule.f(toObject(it));
            }
          });
          if ($stringify) {
            var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
              var symbol = $Symbol();
              return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
            });
            $({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
              // eslint-disable-next-line no-unused-vars -- required for `.length`
              stringify: function stringify(it, replacer, space) {
                var args = [it];
                var index = 1;
                var $replacer;
                while (arguments.length > index) args.push(arguments[index++]);
                $replacer = replacer;
                if (!isObject2(replacer) && it === void 0 || isSymbol2(it)) return;
                if (!isArray2(replacer)) replacer = function(key, value) {
                  if (typeof $replacer == "function") value = $replacer.call(this, key, value);
                  if (!isSymbol2(value)) return value;
                };
                args[1] = replacer;
                return $stringify.apply(null, args);
              }
            });
          }
          if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
            createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
          }
          setToStringTag($Symbol, SYMBOL);
          hiddenKeys[HIDDEN] = true;
        }
      ),
      /***/
      "a640": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var fails = __webpack_require__("d039");
          module2.exports = function(METHOD_NAME, argument) {
            var method = [][METHOD_NAME];
            return !!method && fails(function() {
              method.call(null, argument || function() {
                throw 1;
              }, 1);
            });
          };
        }
      ),
      /***/
      "a691": (
        /***/
        function(module2, exports2) {
          var ceil = Math.ceil;
          var floor = Math.floor;
          module2.exports = function(argument) {
            return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
          };
        }
      ),
      /***/
      "a6fd": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var getBuiltIn = __webpack_require__("d066");
          var aFunction = __webpack_require__("1c0b");
          var anObject = __webpack_require__("825a");
          var fails = __webpack_require__("d039");
          var nativeApply = getBuiltIn("Reflect", "apply");
          var functionApply = Function.apply;
          var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
            nativeApply(function() {
            });
          });
          $({ target: "Reflect", stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
            apply: function apply(target, thisArgument, argumentsList) {
              aFunction(target);
              anObject(argumentsList);
              return nativeApply ? nativeApply(target, thisArgument, argumentsList) : functionApply.call(target, thisArgument, argumentsList);
            }
          });
        }
      ),
      /***/
      "a9e3": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var DESCRIPTORS = __webpack_require__("83ab");
          var global = __webpack_require__("da84");
          var isForced = __webpack_require__("94ca");
          var redefine = __webpack_require__("6eeb");
          var has = __webpack_require__("5135");
          var classof = __webpack_require__("c6b6");
          var inheritIfRequired = __webpack_require__("7156");
          var toPrimitive = __webpack_require__("c04e");
          var fails = __webpack_require__("d039");
          var create = __webpack_require__("7c73");
          var getOwnPropertyNames = __webpack_require__("241c").f;
          var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
          var defineProperty = __webpack_require__("9bf2").f;
          var trim = __webpack_require__("58a8").trim;
          var NUMBER = "Number";
          var NativeNumber = global[NUMBER];
          var NumberPrototype = NativeNumber.prototype;
          var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;
          var toNumber = function(argument) {
            var it = toPrimitive(argument, false);
            var first, third, radix, maxCode, digits, length, index, code;
            if (typeof it == "string" && it.length > 2) {
              it = trim(it);
              first = it.charCodeAt(0);
              if (first === 43 || first === 45) {
                third = it.charCodeAt(2);
                if (third === 88 || third === 120) return NaN;
              } else if (first === 48) {
                switch (it.charCodeAt(1)) {
                  case 66:
                  case 98:
                    radix = 2;
                    maxCode = 49;
                    break;
                  case 79:
                  case 111:
                    radix = 8;
                    maxCode = 55;
                    break;
                  default:
                    return +it;
                }
                digits = it.slice(2);
                length = digits.length;
                for (index = 0; index < length; index++) {
                  code = digits.charCodeAt(index);
                  if (code < 48 || code > maxCode) return NaN;
                }
                return parseInt(digits, radix);
              }
            }
            return +it;
          };
          if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
            var NumberWrapper = function Number2(value) {
              var it = arguments.length < 1 ? 0 : value;
              var dummy = this;
              return dummy instanceof NumberWrapper && (BROKEN_CLASSOF ? fails(function() {
                NumberPrototype.valueOf.call(dummy);
              }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
            };
            for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
              // ES3:
              "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(",")
            ), j = 0, key; keys.length > j; j++) {
              if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
                defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
              }
            }
            NumberWrapper.prototype = NumberPrototype;
            NumberPrototype.constructor = NumberWrapper;
            redefine(global, NUMBER, NumberWrapper);
          }
        }
      ),
      /***/
      "abb4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          module2.exports = function(quiet) {
            function noop() {
            }
            var reporter = {
              log: noop,
              warn: noop,
              error: noop
            };
            if (!quiet && window.console) {
              var attachFunction = function(reporter2, name) {
                reporter2[name] = function reporterProxy() {
                  var f = console[name];
                  if (f.apply) {
                    f.apply(console, arguments);
                  } else {
                    for (var i = 0; i < arguments.length; i++) {
                      f(arguments[i]);
                    }
                  }
                };
              };
              attachFunction(reporter, "log");
              attachFunction(reporter, "warn");
              attachFunction(reporter, "error");
            }
            return reporter;
          };
        }
      ),
      /***/
      "ac1f": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var exec = __webpack_require__("9263");
          $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
            exec
          });
        }
      ),
      /***/
      "ad6d": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var anObject = __webpack_require__("825a");
          module2.exports = function() {
            var that = anObject(this);
            var result = "";
            if (that.global) result += "g";
            if (that.ignoreCase) result += "i";
            if (that.multiline) result += "m";
            if (that.dotAll) result += "s";
            if (that.unicode) result += "u";
            if (that.sticky) result += "y";
            return result;
          };
        }
      ),
      /***/
      "b548": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var ___CSS_LOADER_API_IMPORT___ = __webpack_require__("24fb");
          exports2 = ___CSS_LOADER_API_IMPORT___(false);
          exports2.push([module2.i, ".vue-grid-layout{position:relative;-webkit-transition:height .2s ease;transition:height .2s ease}", ""]);
          module2.exports = exports2;
        }
      ),
      /***/
      "b622": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var shared = __webpack_require__("5692");
          var has = __webpack_require__("5135");
          var uid = __webpack_require__("90e3");
          var NATIVE_SYMBOL = __webpack_require__("4930");
          var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
          var WellKnownSymbolsStore = shared("wks");
          var Symbol2 = global.Symbol;
          var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
          module2.exports = function(name) {
            if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
              if (NATIVE_SYMBOL && has(Symbol2, name)) {
                WellKnownSymbolsStore[name] = Symbol2[name];
              } else {
                WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
              }
            }
            return WellKnownSymbolsStore[name];
          };
        }
      ),
      /***/
      "b64b": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var toObject = __webpack_require__("7b0b");
          var nativeKeys = __webpack_require__("df75");
          var fails = __webpack_require__("d039");
          var FAILS_ON_PRIMITIVES = fails(function() {
            nativeKeys(1);
          });
          $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
            keys: function keys(it) {
              return nativeKeys(toObject(it));
            }
          });
        }
      ),
      /***/
      "b727": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var bind = __webpack_require__("0366");
          var IndexedObject = __webpack_require__("44ad");
          var toObject = __webpack_require__("7b0b");
          var toLength = __webpack_require__("50c4");
          var arraySpeciesCreate = __webpack_require__("65f0");
          var push = [].push;
          var createMethod = function(TYPE) {
            var IS_MAP = TYPE == 1;
            var IS_FILTER = TYPE == 2;
            var IS_SOME = TYPE == 3;
            var IS_EVERY = TYPE == 4;
            var IS_FIND_INDEX = TYPE == 6;
            var IS_FILTER_OUT = TYPE == 7;
            var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
            return function($this, callbackfn, that, specificCreate) {
              var O = toObject($this);
              var self2 = IndexedObject(O);
              var boundFunction = bind(callbackfn, that, 3);
              var length = toLength(self2.length);
              var index = 0;
              var create = specificCreate || arraySpeciesCreate;
              var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : void 0;
              var value, result;
              for (; length > index; index++) if (NO_HOLES || index in self2) {
                value = self2[index];
                result = boundFunction(value, index, O);
                if (TYPE) {
                  if (IS_MAP) target[index] = result;
                  else if (result) switch (TYPE) {
                    case 3:
                      return true;
                    case 5:
                      return value;
                    case 6:
                      return index;
                    case 2:
                      push.call(target, value);
                  }
                  else switch (TYPE) {
                    case 4:
                      return false;
                    case 7:
                      push.call(target, value);
                  }
                }
              }
              return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
            };
          };
          module2.exports = {
            // `Array.prototype.forEach` method
            // https://tc39.es/ecma262/#sec-array.prototype.foreach
            forEach: createMethod(0),
            // `Array.prototype.map` method
            // https://tc39.es/ecma262/#sec-array.prototype.map
            map: createMethod(1),
            // `Array.prototype.filter` method
            // https://tc39.es/ecma262/#sec-array.prototype.filter
            filter: createMethod(2),
            // `Array.prototype.some` method
            // https://tc39.es/ecma262/#sec-array.prototype.some
            some: createMethod(3),
            // `Array.prototype.every` method
            // https://tc39.es/ecma262/#sec-array.prototype.every
            every: createMethod(4),
            // `Array.prototype.find` method
            // https://tc39.es/ecma262/#sec-array.prototype.find
            find: createMethod(5),
            // `Array.prototype.findIndex` method
            // https://tc39.es/ecma262/#sec-array.prototype.findIndex
            findIndex: createMethod(6),
            // `Array.prototype.filterOut` method
            // https://github.com/tc39/proposal-array-filtering
            filterOut: createMethod(7)
          };
        }
      ),
      /***/
      "b770": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var utils = module2.exports = {};
          utils.forEach = function(collection, callback) {
            for (var i = 0; i < collection.length; i++) {
              var result = callback(collection[i]);
              if (result) {
                return result;
              }
            }
          };
        }
      ),
      /***/
      "bc21": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          var all_namespaceObject = {};
          __webpack_require__.r(all_namespaceObject);
          __webpack_require__.d(all_namespaceObject, "edgeTarget", function() {
            return edgeTarget;
          });
          __webpack_require__.d(all_namespaceObject, "elements", function() {
            return snappers_elements;
          });
          __webpack_require__.d(all_namespaceObject, "grid", function() {
            return grid;
          });
          var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
          function render(_ctx, _cache, $props, $setup, $data, $options) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("div", {
              ref: "item",
              class: ["vue-grid-item", $options.classObj],
              style: _ctx.style
            }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default"), $options.resizableAndNotStatic ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createBlock"])("span", {
              key: 0,
              ref: "handle",
              class: $options.resizableHandleClass
            }, null, 2)) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true)], 6);
          }
          var es_number_constructor = __webpack_require__("a9e3");
          var es_array_map = __webpack_require__("d81d");
          var es_string_match = __webpack_require__("466d");
          var es_regexp_exec = __webpack_require__("ac1f");
          var es_string_replace = __webpack_require__("5319");
          var es_string_trim = __webpack_require__("498a");
          var utils = __webpack_require__("a2b6");
          function getControlPosition(e) {
            return offsetXYFromParentOf(e);
          }
          function offsetXYFromParentOf(evt) {
            var offsetParent = evt.target.offsetParent || document.body;
            var offsetParentRect = evt.offsetParent === document.body ? {
              left: 0,
              top: 0
            } : offsetParent.getBoundingClientRect();
            var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
            var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;
            return {
              x,
              y
            };
          }
          function createCoreData(lastX, lastY, x, y) {
            var isStart = !isNum(lastX);
            if (isStart) {
              return {
                deltaX: 0,
                deltaY: 0,
                lastX: x,
                lastY: y,
                x,
                y
              };
            } else {
              return {
                deltaX: x - lastX,
                deltaY: y - lastY,
                lastX,
                lastY,
                x,
                y
              };
            }
          }
          function isNum(num) {
            return typeof num === "number" && !isNaN(num);
          }
          var responsiveUtils = __webpack_require__("97a7");
          var DOM = __webpack_require__("1ca7");
          var mitt = __webpack_require__("cfb9");
          const domObjects = {
            init,
            document: null,
            DocumentFragment: null,
            SVGElement: null,
            SVGSVGElement: null,
            SVGElementInstance: null,
            Element: null,
            HTMLElement: null,
            Event: null,
            Touch: null,
            PointerEvent: null
          };
          function blank() {
          }
          var utils_domObjects = domObjects;
          function init(window2) {
            const win2 = window2;
            domObjects.document = win2.document;
            domObjects.DocumentFragment = win2.DocumentFragment || blank;
            domObjects.SVGElement = win2.SVGElement || blank;
            domObjects.SVGSVGElement = win2.SVGSVGElement || blank;
            domObjects.SVGElementInstance = win2.SVGElementInstance || blank;
            domObjects.Element = win2.Element || blank;
            domObjects.HTMLElement = win2.HTMLElement || domObjects.Element;
            domObjects.Event = win2.Event;
            domObjects.Touch = win2.Touch || blank;
            domObjects.PointerEvent = win2.PointerEvent || win2.MSPointerEvent;
          }
          var isWindow = (thing) => !!(thing && thing.Window) && thing instanceof thing.Window;
          let realWindow = void 0;
          let win = void 0;
          function window_init(window2) {
            realWindow = window2;
            const el = window2.document.createTextNode("");
            if (el.ownerDocument !== window2.document && typeof window2.wrap === "function" && window2.wrap(el) === el) {
              window2 = window2.wrap(window2);
            }
            win = window2;
          }
          if (typeof window !== "undefined" && !!window) {
            window_init(window);
          }
          function getWindow(node) {
            if (isWindow(node)) {
              return node;
            }
            const rootNode = node.ownerDocument || node;
            return rootNode.defaultView || win.window;
          }
          const is_window = (thing) => thing === win || isWindow(thing);
          const docFrag = (thing) => object(thing) && thing.nodeType === 11;
          const object = (thing) => !!thing && typeof thing === "object";
          const func = (thing) => typeof thing === "function";
          const number = (thing) => typeof thing === "number";
          const bool = (thing) => typeof thing === "boolean";
          const string = (thing) => typeof thing === "string";
          const is_element = (thing) => {
            if (!thing || typeof thing !== "object") {
              return false;
            }
            const _window = getWindow(thing) || win;
            return /object|function/.test(typeof _window.Element) ? thing instanceof _window.Element : thing.nodeType === 1 && typeof thing.nodeName === "string";
          };
          const plainObject = (thing) => object(thing) && !!thing.constructor && /function Object\b/.test(thing.constructor.toString());
          const array = (thing) => object(thing) && typeof thing.length !== "undefined" && func(thing.splice);
          var is = {
            window: is_window,
            docFrag,
            object,
            func,
            number,
            bool,
            string,
            element: is_element,
            plainObject,
            array
          };
          const browser = {
            init: browser_init,
            supportsTouch: null,
            supportsPointerEvent: null,
            isIOS7: null,
            isIOS: null,
            isIe9: null,
            isOperaMobile: null,
            prefixedMatchesSelector: null,
            pEventTypes: null,
            wheelEvent: null
          };
          function browser_init(window2) {
            const Element = utils_domObjects.Element;
            const navigator2 = win.navigator;
            browser.supportsTouch = "ontouchstart" in window2 || is.func(window2.DocumentTouch) && utils_domObjects.document instanceof window2.DocumentTouch;
            browser.supportsPointerEvent = navigator2.pointerEnabled !== false && !!utils_domObjects.PointerEvent;
            browser.isIOS = /iP(hone|od|ad)/.test(navigator2.platform);
            browser.isIOS7 = /iP(hone|od|ad)/.test(navigator2.platform) && /OS 7[^\d]/.test(navigator2.appVersion);
            browser.isIe9 = /MSIE 9/.test(navigator2.userAgent);
            browser.isOperaMobile = navigator2.appName === "Opera" && browser.supportsTouch && /Presto/.test(navigator2.userAgent);
            browser.prefixedMatchesSelector = "matches" in Element.prototype ? "matches" : "webkitMatchesSelector" in Element.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in Element.prototype ? "mozMatchesSelector" : "oMatchesSelector" in Element.prototype ? "oMatchesSelector" : "msMatchesSelector";
            browser.pEventTypes = browser.supportsPointerEvent ? utils_domObjects.PointerEvent === window2.MSPointerEvent ? {
              up: "MSPointerUp",
              down: "MSPointerDown",
              over: "mouseover",
              out: "mouseout",
              move: "MSPointerMove",
              cancel: "MSPointerCancel"
            } : {
              up: "pointerup",
              down: "pointerdown",
              over: "pointerover",
              out: "pointerout",
              move: "pointermove",
              cancel: "pointercancel"
            } : null;
            browser.wheelEvent = "onmousewheel" in utils_domObjects.document ? "mousewheel" : "wheel";
          }
          var utils_browser = browser;
          const contains = (array2, target) => array2.indexOf(target) !== -1;
          const arr_remove = (array2, target) => array2.splice(array2.indexOf(target), 1);
          const merge = (target, source) => {
            for (const item of source) {
              target.push(item);
            }
            return target;
          };
          const from = (source) => merge([], source);
          const findIndex = (array2, func2) => {
            for (let i = 0; i < array2.length; i++) {
              if (func2(array2[i], i, array2)) {
                return i;
              }
            }
            return -1;
          };
          const find = (array2, func2) => array2[findIndex(array2, func2)];
          function clone(source) {
            const dest = {};
            for (const prop in source) {
              const value = source[prop];
              if (is.plainObject(value)) {
                dest[prop] = clone(value);
              } else if (is.array(value)) {
                dest[prop] = from(value);
              } else {
                dest[prop] = value;
              }
            }
            return dest;
          }
          function extend2(dest, source) {
            for (const prop in source) {
              ;
              dest[prop] = source[prop];
            }
            const ret = dest;
            return ret;
          }
          let lastTime = 0;
          let request;
          let cancel;
          function raf_init(window2) {
            request = window2.requestAnimationFrame;
            cancel = window2.cancelAnimationFrame;
            if (!request) {
              const vendors = ["ms", "moz", "webkit", "o"];
              for (const vendor of vendors) {
                request = window2[`${vendor}RequestAnimationFrame`];
                cancel = window2[`${vendor}CancelAnimationFrame`] || window2[`${vendor}CancelRequestAnimationFrame`];
              }
            }
            request = request && request.bind(window2);
            cancel = cancel && cancel.bind(window2);
            if (!request) {
              request = (callback) => {
                const currTime = Date.now();
                const timeToCall = Math.max(0, 16 - (currTime - lastTime));
                const token = window2.setTimeout(() => {
                  callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return token;
              };
              cancel = (token) => clearTimeout(token);
            }
          }
          var raf = {
            request: (callback) => request(callback),
            cancel: (token) => cancel(token),
            init: raf_init
          };
          function normalize(type, listeners, result) {
            result = result || {};
            if (is.string(type) && type.search(" ") !== -1) {
              type = split(type);
            }
            if (is.array(type)) {
              return type.reduce((acc, t) => extend2(acc, normalize(t, listeners, result)), result);
            }
            if (is.object(type)) {
              listeners = type;
              type = "";
            }
            if (is.func(listeners)) {
              result[type] = result[type] || [];
              result[type].push(listeners);
            } else if (is.array(listeners)) {
              for (const l of listeners) {
                normalize(type, l, result);
              }
            } else if (is.object(listeners)) {
              for (const prefix2 in listeners) {
                const combinedTypes = split(prefix2).map((p) => `${type}${p}`);
                normalize(combinedTypes, listeners[prefix2], result);
              }
            }
            return result;
          }
          function split(type) {
            return type.trim().split(/ +/);
          }
          function fireUntilImmediateStopped(event, listeners) {
            for (const listener of listeners) {
              if (event.immediatePropagationStopped) {
                break;
              }
              listener(event);
            }
          }
          class Eventable_Eventable {
            constructor(options) {
              this.options = void 0;
              this.types = {};
              this.propagationStopped = false;
              this.immediatePropagationStopped = false;
              this.global = void 0;
              this.options = extend2({}, options || {});
            }
            fire(event) {
              let listeners;
              const global = this.global;
              if (listeners = this.types[event.type]) {
                fireUntilImmediateStopped(event, listeners);
              }
              if (!event.propagationStopped && global && (listeners = global[event.type])) {
                fireUntilImmediateStopped(event, listeners);
              }
            }
            on(type, listener) {
              const listeners = normalize(type, listener);
              for (type in listeners) {
                this.types[type] = merge(this.types[type] || [], listeners[type]);
              }
            }
            off(type, listener) {
              const listeners = normalize(type, listener);
              for (type in listeners) {
                const eventList = this.types[type];
                if (!eventList || !eventList.length) {
                  continue;
                }
                for (const subListener of listeners[type]) {
                  const index = eventList.indexOf(subListener);
                  if (index !== -1) {
                    eventList.splice(index, 1);
                  }
                }
              }
            }
            getRect(_element) {
              return null;
            }
          }
          function nodeContains(parent, child) {
            if (parent.contains) {
              return parent.contains(child);
            }
            while (child) {
              if (child === parent) {
                return true;
              }
              child = child.parentNode;
            }
            return false;
          }
          function domUtils_closest(element, selector) {
            while (is.element(element)) {
              if (matchesSelector(element, selector)) {
                return element;
              }
              element = parentNode(element);
            }
            return null;
          }
          function parentNode(node) {
            let parent = node.parentNode;
            if (is.docFrag(parent)) {
              while ((parent = parent.host) && is.docFrag(parent)) {
                continue;
              }
              return parent;
            }
            return parent;
          }
          function matchesSelector(element, selector) {
            if (win !== realWindow) {
              selector = selector.replace(/\/deep\//g, " ");
            }
            return element[utils_browser.prefixedMatchesSelector](selector);
          }
          const getParent = (el) => el.parentNode || el.host;
          function indexOfDeepestElement(elements) {
            let deepestNodeParents = [];
            let deepestNodeIndex;
            for (let i = 0; i < elements.length; i++) {
              const currentNode = elements[i];
              const deepestNode = elements[deepestNodeIndex];
              if (!currentNode || i === deepestNodeIndex) {
                continue;
              }
              if (!deepestNode) {
                deepestNodeIndex = i;
                continue;
              }
              const currentNodeParent = getParent(currentNode);
              const deepestNodeParent = getParent(deepestNode);
              if (currentNodeParent === currentNode.ownerDocument) {
                continue;
              } else if (deepestNodeParent === currentNode.ownerDocument) {
                deepestNodeIndex = i;
                continue;
              }
              if (currentNodeParent === deepestNodeParent) {
                if (zIndexIsHigherThan(currentNode, deepestNode)) {
                  deepestNodeIndex = i;
                }
                continue;
              }
              deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode);
              let ancestryStart;
              if (deepestNode instanceof utils_domObjects.HTMLElement && currentNode instanceof utils_domObjects.SVGElement && !(currentNode instanceof utils_domObjects.SVGSVGElement)) {
                if (currentNode === deepestNodeParent) {
                  continue;
                }
                ancestryStart = currentNode.ownerSVGElement;
              } else {
                ancestryStart = currentNode;
              }
              const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument);
              let commonIndex = 0;
              while (currentNodeParents[commonIndex] && currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]) {
                commonIndex++;
              }
              const parents = [currentNodeParents[commonIndex - 1], currentNodeParents[commonIndex], deepestNodeParents[commonIndex]];
              let child = parents[0].lastChild;
              while (child) {
                if (child === parents[1]) {
                  deepestNodeIndex = i;
                  deepestNodeParents = currentNodeParents;
                  break;
                } else if (child === parents[2]) {
                  break;
                }
                child = child.previousSibling;
              }
            }
            return deepestNodeIndex;
          }
          function getNodeParents(node, limit) {
            const parents = [];
            let parent = node;
            let parentParent;
            while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {
              parents.unshift(parent);
              parent = parentParent;
            }
            return parents;
          }
          function zIndexIsHigherThan(higherNode, lowerNode) {
            const higherIndex = parseInt(getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0;
            const lowerIndex = parseInt(getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0;
            return higherIndex >= lowerIndex;
          }
          function matchesUpTo(element, selector, limit) {
            while (is.element(element)) {
              if (matchesSelector(element, selector)) {
                return true;
              }
              element = parentNode(element);
              if (element === limit) {
                return matchesSelector(element, selector);
              }
            }
            return false;
          }
          function getActualElement(element) {
            return element.correspondingUseElement || element;
          }
          function getScrollXY(relevantWindow) {
            relevantWindow = relevantWindow || win;
            return {
              x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,
              y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop
            };
          }
          function getElementClientRect(element) {
            const clientRect = element instanceof utils_domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];
            return clientRect && {
              left: clientRect.left,
              right: clientRect.right,
              top: clientRect.top,
              bottom: clientRect.bottom,
              width: clientRect.width || clientRect.right - clientRect.left,
              height: clientRect.height || clientRect.bottom - clientRect.top
            };
          }
          function getElementRect(element) {
            const clientRect = getElementClientRect(element);
            if (!utils_browser.isIOS7 && clientRect) {
              const scroll = getScrollXY(getWindow(element));
              clientRect.left += scroll.x;
              clientRect.right += scroll.x;
              clientRect.top += scroll.y;
              clientRect.bottom += scroll.y;
            }
            return clientRect;
          }
          function getPath(node) {
            const path = [];
            while (node) {
              path.push(node);
              node = parentNode(node);
            }
            return path;
          }
          function trySelector(value) {
            if (!is.string(value)) {
              return false;
            }
            utils_domObjects.document.querySelector(value);
            return true;
          }
          function getStringOptionResult(value, target, element) {
            if (value === "parent") {
              return parentNode(element);
            }
            if (value === "self") {
              return target.getRect(element);
            }
            return domUtils_closest(element, value);
          }
          function resolveRectLike(value, target, element, functionArgs) {
            let returnValue = value;
            if (is.string(returnValue)) {
              returnValue = getStringOptionResult(returnValue, target, element);
            } else if (is.func(returnValue)) {
              returnValue = returnValue(...functionArgs);
            }
            if (is.element(returnValue)) {
              returnValue = getElementRect(returnValue);
            }
            return returnValue;
          }
          function rectToXY(rect) {
            return rect && {
              x: "x" in rect ? rect.x : rect.left,
              y: "y" in rect ? rect.y : rect.top
            };
          }
          function xywhToTlbr(rect) {
            if (rect && !("left" in rect && "top" in rect)) {
              rect = extend2({}, rect);
              rect.left = rect.x || 0;
              rect.top = rect.y || 0;
              rect.right = rect.right || rect.left + rect.width;
              rect.bottom = rect.bottom || rect.top + rect.height;
            }
            return rect;
          }
          function tlbrToXywh(rect) {
            if (rect && !("x" in rect && "y" in rect)) {
              rect = extend2({}, rect);
              rect.x = rect.left || 0;
              rect.y = rect.top || 0;
              rect.width = rect.width || (rect.right || 0) - rect.x;
              rect.height = rect.height || (rect.bottom || 0) - rect.y;
            }
            return rect;
          }
          function addEdges(edges, rect, delta) {
            if (edges.left) {
              rect.left += delta.x;
            }
            if (edges.right) {
              rect.right += delta.x;
            }
            if (edges.top) {
              rect.top += delta.y;
            }
            if (edges.bottom) {
              rect.bottom += delta.y;
            }
            rect.width = rect.right - rect.left;
            rect.height = rect.bottom - rect.top;
          }
          var getOriginXY = function(target, element, actionName) {
            const actionOptions = target.options[actionName];
            const actionOrigin = actionOptions && actionOptions.origin;
            const origin = actionOrigin || target.options.origin;
            const originRect = resolveRectLike(origin, target, element, [target && element]);
            return rectToXY(originRect) || {
              x: 0,
              y: 0
            };
          };
          var hypot = (x, y) => Math.sqrt(x * x + y * y);
          class BaseEvent {
            constructor(interaction) {
              this.type = void 0;
              this.target = void 0;
              this.currentTarget = void 0;
              this.interactable = void 0;
              this._interaction = void 0;
              this.timeStamp = void 0;
              this.immediatePropagationStopped = false;
              this.propagationStopped = false;
              this._interaction = interaction;
            }
            preventDefault() {
            }
            /**
             * Don't call any other listeners (even on the current target)
             */
            stopPropagation() {
              this.propagationStopped = true;
            }
            /**
             * Don't call listeners on the remaining targets
             */
            stopImmediatePropagation() {
              this.immediatePropagationStopped = this.propagationStopped = true;
            }
          }
          Object.defineProperty(BaseEvent.prototype, "interaction", {
            get() {
              return this._interaction._proxy;
            },
            set() {
            }
          });
          const defaultOptions_defaults = {
            base: {
              preventDefault: "auto",
              deltaSource: "page"
            },
            perAction: {
              enabled: false,
              origin: {
                x: 0,
                y: 0
              }
            },
            actions: {}
          };
          class InteractEvent_InteractEvent extends BaseEvent {
            // resize
            /** */
            constructor(interaction, event, actionName, phase, element, preEnd, type) {
              super(interaction);
              this.target = void 0;
              this.currentTarget = void 0;
              this.relatedTarget = null;
              this.screenX = void 0;
              this.screenY = void 0;
              this.button = void 0;
              this.buttons = void 0;
              this.ctrlKey = void 0;
              this.shiftKey = void 0;
              this.altKey = void 0;
              this.metaKey = void 0;
              this.page = void 0;
              this.client = void 0;
              this.delta = void 0;
              this.rect = void 0;
              this.x0 = void 0;
              this.y0 = void 0;
              this.t0 = void 0;
              this.dt = void 0;
              this.duration = void 0;
              this.clientX0 = void 0;
              this.clientY0 = void 0;
              this.velocity = void 0;
              this.speed = void 0;
              this.swipe = void 0;
              this.timeStamp = void 0;
              this.axes = void 0;
              this.preEnd = void 0;
              element = element || interaction.element;
              const target = interaction.interactable;
              const deltaSource = (target && target.options || defaultOptions_defaults).deltaSource;
              const origin = getOriginXY(target, element, actionName);
              const starting = phase === "start";
              const ending = phase === "end";
              const prevEvent = starting ? this : interaction.prevEvent;
              const coords = starting ? interaction.coords.start : ending ? {
                page: prevEvent.page,
                client: prevEvent.client,
                timeStamp: interaction.coords.cur.timeStamp
              } : interaction.coords.cur;
              this.page = extend2({}, coords.page);
              this.client = extend2({}, coords.client);
              this.rect = extend2({}, interaction.rect);
              this.timeStamp = coords.timeStamp;
              if (!ending) {
                this.page.x -= origin.x;
                this.page.y -= origin.y;
                this.client.x -= origin.x;
                this.client.y -= origin.y;
              }
              this.ctrlKey = event.ctrlKey;
              this.altKey = event.altKey;
              this.shiftKey = event.shiftKey;
              this.metaKey = event.metaKey;
              this.button = event.button;
              this.buttons = event.buttons;
              this.target = element;
              this.currentTarget = element;
              this.preEnd = preEnd;
              this.type = type || actionName + (phase || "");
              this.interactable = target;
              this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0;
              this.x0 = interaction.coords.start.page.x - origin.x;
              this.y0 = interaction.coords.start.page.y - origin.y;
              this.clientX0 = interaction.coords.start.client.x - origin.x;
              this.clientY0 = interaction.coords.start.client.y - origin.y;
              if (starting || ending) {
                this.delta = {
                  x: 0,
                  y: 0
                };
              } else {
                this.delta = {
                  x: this[deltaSource].x - prevEvent[deltaSource].x,
                  y: this[deltaSource].y - prevEvent[deltaSource].y
                };
              }
              this.dt = interaction.coords.delta.timeStamp;
              this.duration = this.timeStamp - this.t0;
              this.velocity = extend2({}, interaction.coords.velocity[deltaSource]);
              this.speed = hypot(this.velocity.x, this.velocity.y);
              this.swipe = ending || phase === "inertiastart" ? this.getSwipe() : null;
            }
            getSwipe() {
              const interaction = this._interaction;
              if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {
                return null;
              }
              let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;
              const overlap = 22.5;
              if (angle < 0) {
                angle += 360;
              }
              const left = 135 - overlap <= angle && angle < 225 + overlap;
              const up = 225 - overlap <= angle && angle < 315 + overlap;
              const right = !left && (315 - overlap <= angle || angle < 45 + overlap);
              const down = !up && 45 - overlap <= angle && angle < 135 + overlap;
              return {
                up,
                down,
                left,
                right,
                angle,
                speed: interaction.prevEvent.speed,
                velocity: {
                  x: interaction.prevEvent.velocityX,
                  y: interaction.prevEvent.velocityY
                }
              };
            }
            preventDefault() {
            }
            /**
             * Don't call listeners on the remaining targets
             */
            stopImmediatePropagation() {
              this.immediatePropagationStopped = this.propagationStopped = true;
            }
            /**
             * Don't call any other listeners (even on the current target)
             */
            stopPropagation() {
              this.propagationStopped = true;
            }
          }
          Object.defineProperties(InteractEvent_InteractEvent.prototype, {
            pageX: {
              get() {
                return this.page.x;
              },
              set(value) {
                this.page.x = value;
              }
            },
            pageY: {
              get() {
                return this.page.y;
              },
              set(value) {
                this.page.y = value;
              }
            },
            clientX: {
              get() {
                return this.client.x;
              },
              set(value) {
                this.client.x = value;
              }
            },
            clientY: {
              get() {
                return this.client.y;
              },
              set(value) {
                this.client.y = value;
              }
            },
            dx: {
              get() {
                return this.delta.x;
              },
              set(value) {
                this.delta.x = value;
              }
            },
            dy: {
              get() {
                return this.delta.y;
              },
              set(value) {
                this.delta.y = value;
              }
            },
            velocityX: {
              get() {
                return this.velocity.x;
              },
              set(value) {
                this.velocity.x = value;
              }
            },
            velocityY: {
              get() {
                return this.velocity.y;
              },
              set(value) {
                this.velocity.y = value;
              }
            }
          });
          function isNonNativeEvent(type, actions) {
            if (actions.phaselessTypes[type]) {
              return true;
            }
            for (const name in actions.map) {
              if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {
                return true;
              }
            }
            return false;
          }
          class Interactable_Interactable {
            /** @internal */
            get _defaults() {
              return {
                base: {},
                perAction: {},
                actions: {}
              };
            }
            /** */
            constructor(target, options, defaultContext, scopeEvents) {
              this.options = void 0;
              this._actions = void 0;
              this.target = void 0;
              this.events = new Eventable_Eventable();
              this._context = void 0;
              this._win = void 0;
              this._doc = void 0;
              this._scopeEvents = void 0;
              this._rectChecker = void 0;
              this._actions = options.actions;
              this.target = target;
              this._context = options.context || defaultContext;
              this._win = getWindow(trySelector(target) ? this._context : target);
              this._doc = this._win.document;
              this._scopeEvents = scopeEvents;
              this.set(options);
            }
            setOnEvents(actionName, phases) {
              if (is.func(phases.onstart)) {
                this.on(`${actionName}start`, phases.onstart);
              }
              if (is.func(phases.onmove)) {
                this.on(`${actionName}move`, phases.onmove);
              }
              if (is.func(phases.onend)) {
                this.on(`${actionName}end`, phases.onend);
              }
              if (is.func(phases.oninertiastart)) {
                this.on(`${actionName}inertiastart`, phases.oninertiastart);
              }
              return this;
            }
            updatePerActionListeners(actionName, prev, cur) {
              if (is.array(prev) || is.object(prev)) {
                this.off(actionName, prev);
              }
              if (is.array(cur) || is.object(cur)) {
                this.on(actionName, cur);
              }
            }
            setPerAction(actionName, options) {
              const defaults = this._defaults;
              for (const optionName_ in options) {
                const optionName = optionName_;
                const actionOptions = this.options[actionName];
                const optionValue = options[optionName];
                if (optionName === "listeners") {
                  this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue);
                }
                if (is.array(optionValue)) {
                  ;
                  actionOptions[optionName] = from(optionValue);
                } else if (is.plainObject(optionValue)) {
                  ;
                  actionOptions[optionName] = extend2(actionOptions[optionName] || {}, clone(optionValue));
                  if (is.object(defaults.perAction[optionName]) && "enabled" in defaults.perAction[optionName]) {
                    ;
                    actionOptions[optionName].enabled = optionValue.enabled !== false;
                  }
                } else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {
                  ;
                  actionOptions[optionName].enabled = optionValue;
                } else {
                  ;
                  actionOptions[optionName] = optionValue;
                }
              }
            }
            /**
             * The default function to get an Interactables bounding rect. Can be
             * overridden using {@link Interactable.rectChecker}.
             *
             * @param {Element} [element] The element to measure.
             * @return {Rect} The object's bounding rectangle.
             */
            getRect(element) {
              element = element || (is.element(this.target) ? this.target : null);
              if (is.string(this.target)) {
                element = element || this._context.querySelector(this.target);
              }
              return getElementRect(element);
            }
            /**
             * Returns or sets the function used to calculate the interactable's
             * element's rectangle
             *
             * @param {function} [checker] A function which returns this Interactable's
             * bounding rectangle. See {@link Interactable.getRect}
             * @return {function | object} The checker function or this Interactable
             */
            rectChecker(checker) {
              if (is.func(checker)) {
                this._rectChecker = checker;
                this.getRect = (element) => {
                  const rect = extend2({}, this._rectChecker(element));
                  if (!("width" in rect)) {
                    rect.width = rect.right - rect.left;
                    rect.height = rect.bottom - rect.top;
                  }
                  return rect;
                };
                return this;
              }
              if (checker === null) {
                delete this.getRect;
                delete this._rectChecker;
                return this;
              }
              return this.getRect;
            }
            _backCompatOption(optionName, newValue) {
              if (trySelector(newValue) || is.object(newValue)) {
                ;
                this.options[optionName] = newValue;
                for (const action in this._actions.map) {
                  ;
                  this.options[action][optionName] = newValue;
                }
                return this;
              }
              return this.options[optionName];
            }
            /**
             * Gets or sets the origin of the Interactable's element.  The x and y
             * of the origin will be subtracted from action event coordinates.
             *
             * @param {Element | object | string} [origin] An HTML or SVG Element whose
             * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'
             * or any CSS selector
             *
             * @return {object} The current origin or this Interactable
             */
            origin(newValue) {
              return this._backCompatOption("origin", newValue);
            }
            /**
             * Returns or sets the mouse coordinate types used to calculate the
             * movement of the pointer.
             *
             * @param {string} [newValue] Use 'client' if you will be scrolling while
             * interacting; Use 'page' if you want autoScroll to work
             * @return {string | object} The current deltaSource or this Interactable
             */
            deltaSource(newValue) {
              if (newValue === "page" || newValue === "client") {
                this.options.deltaSource = newValue;
                return this;
              }
              return this.options.deltaSource;
            }
            /**
             * Gets the selector context Node of the Interactable. The default is
             * `window.document`.
             *
             * @return {Node} The context Node of this Interactable
             */
            context() {
              return this._context;
            }
            inContext(element) {
              return this._context === element.ownerDocument || nodeContains(this._context, element);
            }
            testIgnoreAllow(options, targetNode, eventTarget) {
              return !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) && this.testAllow(options.allowFrom, targetNode, eventTarget);
            }
            testAllow(allowFrom, targetNode, element) {
              if (!allowFrom) {
                return true;
              }
              if (!is.element(element)) {
                return false;
              }
              if (is.string(allowFrom)) {
                return matchesUpTo(element, allowFrom, targetNode);
              } else if (is.element(allowFrom)) {
                return nodeContains(allowFrom, element);
              }
              return false;
            }
            testIgnore(ignoreFrom, targetNode, element) {
              if (!ignoreFrom || !is.element(element)) {
                return false;
              }
              if (is.string(ignoreFrom)) {
                return matchesUpTo(element, ignoreFrom, targetNode);
              } else if (is.element(ignoreFrom)) {
                return nodeContains(ignoreFrom, element);
              }
              return false;
            }
            /**
             * Calls listeners for the given InteractEvent type bound globally
             * and directly to this Interactable
             *
             * @param {InteractEvent} iEvent The InteractEvent object to be fired on this
             * Interactable
             * @return {Interactable} this Interactable
             */
            fire(iEvent) {
              this.events.fire(iEvent);
              return this;
            }
            _onOff(method, typeArg, listenerArg, options) {
              if (is.object(typeArg) && !is.array(typeArg)) {
                options = listenerArg;
                listenerArg = null;
              }
              const addRemove = method === "on" ? "add" : "remove";
              const listeners = normalize(typeArg, listenerArg);
              for (let type in listeners) {
                if (type === "wheel") {
                  type = utils_browser.wheelEvent;
                }
                for (const listener of listeners[type]) {
                  if (isNonNativeEvent(type, this._actions)) {
                    this.events[method](type, listener);
                  } else if (is.string(this.target)) {
                    this._scopeEvents[`${addRemove}Delegate`](this.target, this._context, type, listener, options);
                  } else {
                    this._scopeEvents[addRemove](this.target, type, listener, options);
                  }
                }
              }
              return this;
            }
            /**
             * Binds a listener for an InteractEvent, pointerEvent or DOM event.
             *
             * @param {string | array | object} types The types of events to listen
             * for
             * @param {function | array | object} [listener] The event listener function(s)
             * @param {object | boolean} [options] options object or useCapture flag for
             * addEventListener
             * @return {Interactable} This Interactable
             */
            on(types, listener, options) {
              return this._onOff("on", types, listener, options);
            }
            /**
             * Removes an InteractEvent, pointerEvent or DOM event listener.
             *
             * @param {string | array | object} types The types of events that were
             * listened for
             * @param {function | array | object} [listener] The event listener function(s)
             * @param {object | boolean} [options] options object or useCapture flag for
             * removeEventListener
             * @return {Interactable} This Interactable
             */
            off(types, listener, options) {
              return this._onOff("off", types, listener, options);
            }
            /**
             * Reset the options of this Interactable
             *
             * @param {object} options The new settings to apply
             * @return {object} This Interactable
             */
            set(options) {
              const defaults = this._defaults;
              if (!is.object(options)) {
                options = {};
              }
              ;
              this.options = clone(defaults.base);
              for (const actionName_ in this._actions.methodDict) {
                const actionName = actionName_;
                const methodName = this._actions.methodDict[actionName];
                this.options[actionName] = {};
                this.setPerAction(actionName, extend2(extend2({}, defaults.perAction), defaults.actions[actionName]));
                this[methodName](options[actionName]);
              }
              for (const setting in options) {
                if (is.func(this[setting])) {
                  ;
                  this[setting](options[setting]);
                }
              }
              return this;
            }
            /**
             * Remove this interactable from the list of interactables and remove it's
             * action capabilities and event listeners
             */
            unset() {
              if (is.string(this.target)) {
                for (const type in this._scopeEvents.delegatedEvents) {
                  const delegated = this._scopeEvents.delegatedEvents[type];
                  for (let i = delegated.length - 1; i >= 0; i--) {
                    const {
                      selector,
                      context,
                      listeners
                    } = delegated[i];
                    if (selector === this.target && context === this._context) {
                      delegated.splice(i, 1);
                    }
                    for (let l = listeners.length - 1; l >= 0; l--) {
                      this._scopeEvents.removeDelegate(this.target, this._context, type, listeners[l][0], listeners[l][1]);
                    }
                  }
                }
              } else {
                this._scopeEvents.remove(this.target, "all");
              }
            }
          }
          class InteractableSet_InteractableSet {
            // all set interactables
            constructor(scope) {
              this.list = [];
              this.selectorMap = {};
              this.scope = void 0;
              this.scope = scope;
              scope.addListeners({
                "interactable:unset": ({
                  interactable
                }) => {
                  const {
                    target,
                    _context: context
                  } = interactable;
                  const targetMappings = is.string(target) ? this.selectorMap[target] : target[this.scope.id];
                  const targetIndex = findIndex(targetMappings, (m) => m.context === context);
                  if (targetMappings[targetIndex]) {
                    targetMappings[targetIndex].context = null;
                    targetMappings[targetIndex].interactable = null;
                  }
                  targetMappings.splice(targetIndex, 1);
                }
              });
            }
            new(target, options) {
              options = extend2(options || {}, {
                actions: this.scope.actions
              });
              const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events);
              const mappingInfo = {
                context: interactable._context,
                interactable
              };
              this.scope.addDocument(interactable._doc);
              this.list.push(interactable);
              if (is.string(target)) {
                if (!this.selectorMap[target]) {
                  this.selectorMap[target] = [];
                }
                this.selectorMap[target].push(mappingInfo);
              } else {
                if (!interactable.target[this.scope.id]) {
                  Object.defineProperty(target, this.scope.id, {
                    value: [],
                    configurable: true
                  });
                }
                ;
                target[this.scope.id].push(mappingInfo);
              }
              this.scope.fire("interactable:new", {
                target,
                options,
                interactable,
                win: this.scope._win
              });
              return interactable;
            }
            get(target, options) {
              const context = options && options.context || this.scope.document;
              const isSelector = is.string(target);
              const targetMappings = isSelector ? this.selectorMap[target] : target[this.scope.id];
              if (!targetMappings) {
                return null;
              }
              const found = find(targetMappings, (m) => m.context === context && (isSelector || m.interactable.inContext(target)));
              return found && found.interactable;
            }
            forEachMatch(node, callback) {
              for (const interactable of this.list) {
                let ret;
                if ((is.string(interactable.target) ? (
                  // target is a selector and the element matches
                  is.element(node) && matchesSelector(node, interactable.target)
                ) : (
                  // target is the element
                  node === interactable.target
                )) && // the element is in context
                interactable.inContext(node)) {
                  ret = callback(interactable);
                }
                if (ret !== void 0) {
                  return ret;
                }
              }
            }
          }
          function pointerExtend(dest, source) {
            for (const prop in source) {
              const prefixedPropREs = pointerExtend.prefixedPropREs;
              let deprecated = false;
              for (const vendor in prefixedPropREs) {
                if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {
                  deprecated = true;
                  break;
                }
              }
              if (!deprecated && typeof source[prop] !== "function") {
                dest[prop] = source[prop];
              }
            }
            return dest;
          }
          pointerExtend.prefixedPropREs = {
            webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,
            moz: /(Pressure)$/
          };
          var utils_pointerExtend = pointerExtend;
          function copyCoords(dest, src) {
            dest.page = dest.page || {};
            dest.page.x = src.page.x;
            dest.page.y = src.page.y;
            dest.client = dest.client || {};
            dest.client.x = src.client.x;
            dest.client.y = src.client.y;
            dest.timeStamp = src.timeStamp;
          }
          function setCoordDeltas(targetObj, prev, cur) {
            targetObj.page.x = cur.page.x - prev.page.x;
            targetObj.page.y = cur.page.y - prev.page.y;
            targetObj.client.x = cur.client.x - prev.client.x;
            targetObj.client.y = cur.client.y - prev.client.y;
            targetObj.timeStamp = cur.timeStamp - prev.timeStamp;
          }
          function setCoordVelocity(targetObj, delta) {
            const dt = Math.max(delta.timeStamp / 1e3, 1e-3);
            targetObj.page.x = delta.page.x / dt;
            targetObj.page.y = delta.page.y / dt;
            targetObj.client.x = delta.client.x / dt;
            targetObj.client.y = delta.client.y / dt;
            targetObj.timeStamp = dt;
          }
          function setZeroCoords(targetObj) {
            targetObj.page.x = 0;
            targetObj.page.y = 0;
            targetObj.client.x = 0;
            targetObj.client.y = 0;
          }
          function isNativePointer(pointer) {
            return pointer instanceof utils_domObjects.Event || pointer instanceof utils_domObjects.Touch;
          }
          function getXY(type, pointer, xy) {
            xy = xy || {};
            type = type || "page";
            xy.x = pointer[type + "X"];
            xy.y = pointer[type + "Y"];
            return xy;
          }
          function getPageXY(pointer, page) {
            page = page || {
              x: 0,
              y: 0
            };
            if (utils_browser.isOperaMobile && isNativePointer(pointer)) {
              getXY("screen", pointer, page);
              page.x += window.scrollX;
              page.y += window.scrollY;
            } else {
              getXY("page", pointer, page);
            }
            return page;
          }
          function getClientXY(pointer, client) {
            client = client || {};
            if (utils_browser.isOperaMobile && isNativePointer(pointer)) {
              getXY("screen", pointer, client);
            } else {
              getXY("client", pointer, client);
            }
            return client;
          }
          function getPointerId(pointer) {
            return is.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;
          }
          function setCoords(dest, pointers, timeStamp) {
            const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0];
            getPageXY(pointer, dest.page);
            getClientXY(pointer, dest.client);
            dest.timeStamp = timeStamp;
          }
          function getTouchPair(event) {
            const touches = [];
            if (is.array(event)) {
              touches[0] = event[0];
              touches[1] = event[1];
            } else {
              if (event.type === "touchend") {
                if (event.touches.length === 1) {
                  touches[0] = event.touches[0];
                  touches[1] = event.changedTouches[0];
                } else if (event.touches.length === 0) {
                  touches[0] = event.changedTouches[0];
                  touches[1] = event.changedTouches[1];
                }
              } else {
                touches[0] = event.touches[0];
                touches[1] = event.touches[1];
              }
            }
            return touches;
          }
          function pointerAverage(pointers) {
            const average = {
              pageX: 0,
              pageY: 0,
              clientX: 0,
              clientY: 0,
              screenX: 0,
              screenY: 0
            };
            for (const pointer of pointers) {
              for (const prop in average) {
                average[prop] += pointer[prop];
              }
            }
            for (const prop in average) {
              average[prop] /= pointers.length;
            }
            return average;
          }
          function touchBBox(event) {
            if (!event.length) {
              return null;
            }
            const touches = getTouchPair(event);
            const minX = Math.min(touches[0].pageX, touches[1].pageX);
            const minY = Math.min(touches[0].pageY, touches[1].pageY);
            const maxX = Math.max(touches[0].pageX, touches[1].pageX);
            const maxY = Math.max(touches[0].pageY, touches[1].pageY);
            return {
              x: minX,
              y: minY,
              left: minX,
              top: minY,
              right: maxX,
              bottom: maxY,
              width: maxX - minX,
              height: maxY - minY
            };
          }
          function touchDistance(event, deltaSource) {
            const sourceX = deltaSource + "X";
            const sourceY = deltaSource + "Y";
            const touches = getTouchPair(event);
            const dx = touches[0][sourceX] - touches[1][sourceX];
            const dy = touches[0][sourceY] - touches[1][sourceY];
            return hypot(dx, dy);
          }
          function touchAngle(event, deltaSource) {
            const sourceX = deltaSource + "X";
            const sourceY = deltaSource + "Y";
            const touches = getTouchPair(event);
            const dx = touches[1][sourceX] - touches[0][sourceX];
            const dy = touches[1][sourceY] - touches[0][sourceY];
            const angle = 180 * Math.atan2(dy, dx) / Math.PI;
            return angle;
          }
          function getPointerType(pointer) {
            return is.string(pointer.pointerType) ? pointer.pointerType : is.number(pointer.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][pointer.pointerType] : (
              // if the PointerEvent API isn't available, then the "pointer" must
              // be either a MouseEvent, TouchEvent, or Touch object
              /touch/.test(pointer.type || "") || pointer instanceof utils_domObjects.Touch ? "touch" : "mouse"
            );
          }
          function getEventTargets(event) {
            const path = is.func(event.composedPath) ? event.composedPath() : event.path;
            return [getActualElement(path ? path[0] : event.target), getActualElement(event.currentTarget)];
          }
          function newCoords() {
            return {
              page: {
                x: 0,
                y: 0
              },
              client: {
                x: 0,
                y: 0
              },
              timeStamp: 0
            };
          }
          function coordsToEvent(coords) {
            const event = {
              coords,
              get page() {
                return this.coords.page;
              },
              get client() {
                return this.coords.client;
              },
              get timeStamp() {
                return this.coords.timeStamp;
              },
              get pageX() {
                return this.coords.page.x;
              },
              get pageY() {
                return this.coords.page.y;
              },
              get clientX() {
                return this.coords.client.x;
              },
              get clientY() {
                return this.coords.client.y;
              },
              get pointerId() {
                return this.coords.pointerId;
              },
              get target() {
                return this.coords.target;
              },
              get type() {
                return this.coords.type;
              },
              get pointerType() {
                return this.coords.pointerType;
              },
              get buttons() {
                return this.coords.buttons;
              },
              preventDefault() {
              }
            };
            return event;
          }
          function install(scope) {
            const targets = [];
            const delegatedEvents = {};
            const documents = [];
            const eventsMethods = {
              add,
              remove,
              addDelegate,
              removeDelegate,
              delegateListener,
              delegateUseCapture,
              delegatedEvents,
              documents,
              targets,
              supportsOptions: false,
              supportsPassive: false
            };
            scope.document.createElement("div").addEventListener("test", null, {
              get capture() {
                return eventsMethods.supportsOptions = true;
              },
              get passive() {
                return eventsMethods.supportsPassive = true;
              }
            });
            scope.events = eventsMethods;
            function add(eventTarget, type, listener, optionalArg) {
              const options = getOptions(optionalArg);
              let target = find(targets, (t) => t.eventTarget === eventTarget);
              if (!target) {
                target = {
                  eventTarget,
                  events: {}
                };
                targets.push(target);
              }
              if (!target.events[type]) {
                target.events[type] = [];
              }
              if (eventTarget.addEventListener && !contains(target.events[type], listener)) {
                eventTarget.addEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
                target.events[type].push(listener);
              }
            }
            function remove(eventTarget, type, listener, optionalArg) {
              const options = getOptions(optionalArg);
              const targetIndex = findIndex(targets, (t) => t.eventTarget === eventTarget);
              const target = targets[targetIndex];
              if (!target || !target.events) {
                return;
              }
              if (type === "all") {
                for (type in target.events) {
                  if (target.events.hasOwnProperty(type)) {
                    remove(eventTarget, type, "all");
                  }
                }
                return;
              }
              let typeIsEmpty = false;
              const typeListeners = target.events[type];
              if (typeListeners) {
                if (listener === "all") {
                  for (let i = typeListeners.length - 1; i >= 0; i--) {
                    remove(eventTarget, type, typeListeners[i], options);
                  }
                  return;
                } else {
                  for (let i = 0; i < typeListeners.length; i++) {
                    if (typeListeners[i] === listener) {
                      eventTarget.removeEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
                      typeListeners.splice(i, 1);
                      if (typeListeners.length === 0) {
                        delete target.events[type];
                        typeIsEmpty = true;
                      }
                      break;
                    }
                  }
                }
              }
              if (typeIsEmpty && !Object.keys(target.events).length) {
                targets.splice(targetIndex, 1);
              }
            }
            function addDelegate(selector, context, type, listener, optionalArg) {
              const options = getOptions(optionalArg);
              if (!delegatedEvents[type]) {
                delegatedEvents[type] = [];
                for (const doc of documents) {
                  add(doc, type, delegateListener);
                  add(doc, type, delegateUseCapture, true);
                }
              }
              const delegates = delegatedEvents[type];
              let delegate = find(delegates, (d) => d.selector === selector && d.context === context);
              if (!delegate) {
                delegate = {
                  selector,
                  context,
                  listeners: []
                };
                delegates.push(delegate);
              }
              delegate.listeners.push([listener, options]);
            }
            function removeDelegate(selector, context, type, listener, optionalArg) {
              const options = getOptions(optionalArg);
              const delegates = delegatedEvents[type];
              let matchFound = false;
              let index;
              if (!delegates) return;
              for (index = delegates.length - 1; index >= 0; index--) {
                const cur = delegates[index];
                if (cur.selector === selector && cur.context === context) {
                  const {
                    listeners
                  } = cur;
                  for (let i = listeners.length - 1; i >= 0; i--) {
                    const [fn, {
                      capture,
                      passive
                    }] = listeners[i];
                    if (fn === listener && capture === options.capture && passive === options.passive) {
                      listeners.splice(i, 1);
                      if (!listeners.length) {
                        delegates.splice(index, 1);
                        remove(context, type, delegateListener);
                        remove(context, type, delegateUseCapture, true);
                      }
                      matchFound = true;
                      break;
                    }
                  }
                  if (matchFound) {
                    break;
                  }
                }
              }
            }
            function delegateListener(event, optionalArg) {
              const options = getOptions(optionalArg);
              const fakeEvent = new events_FakeEvent(event);
              const delegates = delegatedEvents[event.type];
              const [eventTarget] = getEventTargets(event);
              let element = eventTarget;
              while (is.element(element)) {
                for (let i = 0; i < delegates.length; i++) {
                  const cur = delegates[i];
                  const {
                    selector,
                    context
                  } = cur;
                  if (matchesSelector(element, selector) && nodeContains(context, eventTarget) && nodeContains(context, element)) {
                    const {
                      listeners
                    } = cur;
                    fakeEvent.currentTarget = element;
                    for (const [fn, {
                      capture,
                      passive
                    }] of listeners) {
                      if (capture === options.capture && passive === options.passive) {
                        fn(fakeEvent);
                      }
                    }
                  }
                }
                element = parentNode(element);
              }
            }
            function delegateUseCapture(event) {
              return delegateListener.call(this, event, true);
            }
            return eventsMethods;
          }
          class events_FakeEvent {
            constructor(originalEvent) {
              this.currentTarget = void 0;
              this.originalEvent = void 0;
              this.type = void 0;
              this.originalEvent = originalEvent;
              utils_pointerExtend(this, originalEvent);
            }
            preventOriginalDefault() {
              this.originalEvent.preventDefault();
            }
            stopPropagation() {
              this.originalEvent.stopPropagation();
            }
            stopImmediatePropagation() {
              this.originalEvent.stopImmediatePropagation();
            }
          }
          function getOptions(param) {
            if (!is.object(param)) {
              return {
                capture: !!param,
                passive: false
              };
            }
            const options = extend2({}, param);
            options.capture = !!param.capture;
            options.passive = !!param.passive;
            return options;
          }
          var events = {
            id: "events",
            install
          };
          function warnOnce(method, message) {
            let warned = false;
            return function() {
              if (!warned) {
                ;
                win.console.warn(message);
                warned = true;
              }
              return method.apply(this, arguments);
            };
          }
          function copyAction(dest, src) {
            dest.name = src.name;
            dest.axis = src.axis;
            dest.edges = src.edges;
            return dest;
          }
          function createInteractStatic(scope) {
            const interact = (target, options) => {
              let interactable = scope.interactables.get(target, options);
              if (!interactable) {
                interactable = scope.interactables.new(target, options);
                interactable.events.global = interact.globalEvents;
              }
              return interactable;
            };
            interact.getPointerAverage = pointerAverage;
            interact.getTouchBBox = touchBBox;
            interact.getTouchDistance = touchDistance;
            interact.getTouchAngle = touchAngle;
            interact.getElementRect = getElementRect;
            interact.getElementClientRect = getElementClientRect;
            interact.matchesSelector = matchesSelector;
            interact.closest = domUtils_closest;
            interact.globalEvents = {};
            interact.version = "1.10.3";
            interact.scope = scope;
            interact.use = function(plugin, options) {
              this.scope.usePlugin(plugin, options);
              return this;
            };
            interact.isSet = function(target, options) {
              return !!this.scope.interactables.get(target, options && options.context);
            };
            interact.on = warnOnce(function on(type, listener, options) {
              if (is.string(type) && type.search(" ") !== -1) {
                type = type.trim().split(/ +/);
              }
              if (is.array(type)) {
                for (const eventType of type) {
                  this.on(eventType, listener, options);
                }
                return this;
              }
              if (is.object(type)) {
                for (const prop in type) {
                  this.on(prop, type[prop], listener);
                }
                return this;
              }
              if (isNonNativeEvent(type, this.scope.actions)) {
                if (!this.globalEvents[type]) {
                  this.globalEvents[type] = [listener];
                } else {
                  this.globalEvents[type].push(listener);
                }
              } else {
                this.scope.events.add(this.scope.document, type, listener, {
                  options
                });
              }
              return this;
            }, "The interact.on() method is being deprecated");
            interact.off = warnOnce(function off(type, listener, options) {
              if (is.string(type) && type.search(" ") !== -1) {
                type = type.trim().split(/ +/);
              }
              if (is.array(type)) {
                for (const eventType of type) {
                  this.off(eventType, listener, options);
                }
                return this;
              }
              if (is.object(type)) {
                for (const prop in type) {
                  this.off(prop, type[prop], listener);
                }
                return this;
              }
              if (isNonNativeEvent(type, this.scope.actions)) {
                let index;
                if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) {
                  this.globalEvents[type].splice(index, 1);
                }
              } else {
                this.scope.events.remove(this.scope.document, type, listener, options);
              }
              return this;
            }, "The interact.off() method is being deprecated");
            interact.debug = function() {
              return this.scope;
            };
            interact.supportsTouch = function() {
              return utils_browser.supportsTouch;
            };
            interact.supportsPointerEvent = function() {
              return utils_browser.supportsPointerEvent;
            };
            interact.stop = function() {
              for (const interaction of this.scope.interactions.list) {
                interaction.stop();
              }
              return this;
            };
            interact.pointerMoveTolerance = function(newValue) {
              if (is.number(newValue)) {
                this.scope.interactions.pointerMoveTolerance = newValue;
                return this;
              }
              return this.scope.interactions.pointerMoveTolerance;
            };
            interact.addDocument = function(doc, options) {
              this.scope.addDocument(doc, options);
            };
            interact.removeDocument = function(doc) {
              this.scope.removeDocument(doc);
            };
            return interact;
          }
          class PointerInfo {
            constructor(id, pointer, event, downTime, downTarget) {
              this.id = void 0;
              this.pointer = void 0;
              this.event = void 0;
              this.downTime = void 0;
              this.downTarget = void 0;
              this.id = id;
              this.pointer = pointer;
              this.event = event;
              this.downTime = downTime;
              this.downTarget = downTarget;
            }
          }
          let _ProxyValues;
          (function(_ProxyValues2) {
            _ProxyValues2["interactable"] = "";
            _ProxyValues2["element"] = "";
            _ProxyValues2["prepared"] = "";
            _ProxyValues2["pointerIsDown"] = "";
            _ProxyValues2["pointerWasMoved"] = "";
            _ProxyValues2["_proxy"] = "";
          })(_ProxyValues || (_ProxyValues = {}));
          let _ProxyMethods;
          (function(_ProxyMethods2) {
            _ProxyMethods2["start"] = "";
            _ProxyMethods2["move"] = "";
            _ProxyMethods2["end"] = "";
            _ProxyMethods2["stop"] = "";
            _ProxyMethods2["interacting"] = "";
          })(_ProxyMethods || (_ProxyMethods = {}));
          let idCounter = 0;
          class Interaction_Interaction {
            // current interactable being interacted with
            // the target element of the interactable
            // action that's ready to be fired on next move event
            // keep track of added pointers
            // pointerdown/mousedown/touchstart event
            // previous action event
            /** @internal */
            get pointerMoveTolerance() {
              return 1;
            }
            /**
             * @alias Interaction.prototype.move
             */
            /** */
            constructor({
              pointerType,
              scopeFire
            }) {
              this.interactable = null;
              this.element = null;
              this.rect = void 0;
              this._rects = void 0;
              this.edges = void 0;
              this._scopeFire = void 0;
              this.prepared = {
                name: null,
                axis: null,
                edges: null
              };
              this.pointerType = void 0;
              this.pointers = [];
              this.downEvent = null;
              this.downPointer = {};
              this._latestPointer = {
                pointer: null,
                event: null,
                eventTarget: null
              };
              this.prevEvent = null;
              this.pointerIsDown = false;
              this.pointerWasMoved = false;
              this._interacting = false;
              this._ending = false;
              this._stopped = true;
              this._proxy = null;
              this.simulation = null;
              this.doMove = warnOnce(function(signalArg) {
                this.move(signalArg);
              }, "The interaction.doMove() method has been renamed to interaction.move()");
              this.coords = {
                // Starting InteractEvent pointer coordinates
                start: newCoords(),
                // Previous native pointer move event coordinates
                prev: newCoords(),
                // current native pointer move event coordinates
                cur: newCoords(),
                // Change in coordinates and time of the pointer
                delta: newCoords(),
                // pointer velocity
                velocity: newCoords()
              };
              this._id = idCounter++;
              this._scopeFire = scopeFire;
              this.pointerType = pointerType;
              const that = this;
              this._proxy = {};
              for (const key in _ProxyValues) {
                Object.defineProperty(this._proxy, key, {
                  get() {
                    return that[key];
                  }
                });
              }
              for (const key in _ProxyMethods) {
                Object.defineProperty(this._proxy, key, {
                  value: (...args) => that[key](...args)
                });
              }
              this._scopeFire("interactions:new", {
                interaction: this
              });
            }
            pointerDown(pointer, event, eventTarget) {
              const pointerIndex = this.updatePointer(pointer, event, eventTarget, true);
              const pointerInfo = this.pointers[pointerIndex];
              this._scopeFire("interactions:down", {
                pointer,
                event,
                eventTarget,
                pointerIndex,
                pointerInfo,
                type: "down",
                interaction: this
              });
            }
            /**
             * ```js
             * interact(target)
             *   .draggable({
             *     // disable the default drag start by down->move
             *     manualStart: true
             *   })
             *   // start dragging after the user holds the pointer down
             *   .on('hold', function (event) {
             *     var interaction = event.interaction
             *
             *     if (!interaction.interacting()) {
             *       interaction.start({ name: 'drag' },
             *                         event.interactable,
             *                         event.currentTarget)
             *     }
             * })
             * ```
             *
             * Start an action with the given Interactable and Element as tartgets. The
             * action must be enabled for the target Interactable and an appropriate
             * number of pointers must be held down - 1 for drag/resize, 2 for gesture.
             *
             * Use it with `interactable.<action>able({ manualStart: false })` to always
             * [start actions manually](https://github.com/taye/interact.js/issues/114)
             *
             * @param {object} action   The action to be performed - drag, resize, etc.
             * @param {Interactable} target  The Interactable to target
             * @param {Element} element The DOM Element to target
             * @return {Boolean} Whether the interaction was successfully started
             */
            start(action, interactable, element) {
              if (this.interacting() || !this.pointerIsDown || this.pointers.length < (action.name === "gesture" ? 2 : 1) || !interactable.options[action.name].enabled) {
                return false;
              }
              copyAction(this.prepared, action);
              this.interactable = interactable;
              this.element = element;
              this.rect = interactable.getRect(element);
              this.edges = this.prepared.edges ? extend2({}, this.prepared.edges) : {
                left: true,
                right: true,
                top: true,
                bottom: true
              };
              this._stopped = false;
              this._interacting = this._doPhase({
                interaction: this,
                event: this.downEvent,
                phase: "start"
              }) && !this._stopped;
              return this._interacting;
            }
            pointerMove(pointer, event, eventTarget) {
              if (!this.simulation && !(this.modification && this.modification.endResult)) {
                this.updatePointer(pointer, event, eventTarget, false);
              }
              const duplicateMove = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
              let dx;
              let dy;
              if (this.pointerIsDown && !this.pointerWasMoved) {
                dx = this.coords.cur.client.x - this.coords.start.client.x;
                dy = this.coords.cur.client.y - this.coords.start.client.y;
                this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance;
              }
              const pointerIndex = this.getPointerIndex(pointer);
              const signalArg = {
                pointer,
                pointerIndex,
                pointerInfo: this.pointers[pointerIndex],
                event,
                type: "move",
                eventTarget,
                dx,
                dy,
                duplicate: duplicateMove,
                interaction: this
              };
              if (!duplicateMove) {
                setCoordVelocity(this.coords.velocity, this.coords.delta);
              }
              this._scopeFire("interactions:move", signalArg);
              if (!duplicateMove && !this.simulation) {
                if (this.interacting()) {
                  signalArg.type = null;
                  this.move(signalArg);
                }
                if (this.pointerWasMoved) {
                  copyCoords(this.coords.prev, this.coords.cur);
                }
              }
            }
            /**
             * ```js
             * interact(target)
             *   .draggable(true)
             *   .on('dragmove', function (event) {
             *     if (someCondition) {
             *       // change the snap settings
             *       event.interactable.draggable({ snap: { targets: [] }})
             *       // fire another move event with re-calculated snap
             *       event.interaction.move()
             *     }
             *   })
             * ```
             *
             * Force a move of the current action at the same coordinates. Useful if
             * snap/restrict has been changed and you want a movement with the new
             * settings.
             */
            move(signalArg) {
              if (!signalArg || !signalArg.event) {
                setZeroCoords(this.coords.delta);
              }
              signalArg = extend2({
                pointer: this._latestPointer.pointer,
                event: this._latestPointer.event,
                eventTarget: this._latestPointer.eventTarget,
                interaction: this
              }, signalArg || {});
              signalArg.phase = "move";
              this._doPhase(signalArg);
            }
            // End interact move events and stop auto-scroll unless simulation is running
            pointerUp(pointer, event, eventTarget, curEventTarget) {
              let pointerIndex = this.getPointerIndex(pointer);
              if (pointerIndex === -1) {
                pointerIndex = this.updatePointer(pointer, event, eventTarget, false);
              }
              const type = /cancel$/i.test(event.type) ? "cancel" : "up";
              this._scopeFire(`interactions:${type}`, {
                pointer,
                pointerIndex,
                pointerInfo: this.pointers[pointerIndex],
                event,
                eventTarget,
                type,
                curEventTarget,
                interaction: this
              });
              if (!this.simulation) {
                this.end(event);
              }
              this.removePointer(pointer, event);
            }
            documentBlur(event) {
              this.end(event);
              this._scopeFire("interactions:blur", {
                event,
                type: "blur",
                interaction: this
              });
            }
            /**
             * ```js
             * interact(target)
             *   .draggable(true)
             *   .on('move', function (event) {
             *     if (event.pageX > 1000) {
             *       // end the current action
             *       event.interaction.end()
             *       // stop all further listeners from being called
             *       event.stopImmediatePropagation()
             *     }
             *   })
             * ```
             *
             * @param {PointerEvent} [event]
             */
            end(event) {
              this._ending = true;
              event = event || this._latestPointer.event;
              let endPhaseResult;
              if (this.interacting()) {
                endPhaseResult = this._doPhase({
                  event,
                  interaction: this,
                  phase: "end"
                });
              }
              this._ending = false;
              if (endPhaseResult === true) {
                this.stop();
              }
            }
            currentAction() {
              return this._interacting ? this.prepared.name : null;
            }
            interacting() {
              return this._interacting;
            }
            /** */
            stop() {
              this._scopeFire("interactions:stop", {
                interaction: this
              });
              this.interactable = this.element = null;
              this._interacting = false;
              this._stopped = true;
              this.prepared.name = this.prevEvent = null;
            }
            getPointerIndex(pointer) {
              const pointerId = getPointerId(pointer);
              return this.pointerType === "mouse" || this.pointerType === "pen" ? this.pointers.length - 1 : findIndex(this.pointers, (curPointer) => curPointer.id === pointerId);
            }
            getPointerInfo(pointer) {
              return this.pointers[this.getPointerIndex(pointer)];
            }
            updatePointer(pointer, event, eventTarget, down) {
              const id = getPointerId(pointer);
              let pointerIndex = this.getPointerIndex(pointer);
              let pointerInfo = this.pointers[pointerIndex];
              down = down === false ? false : down || /(down|start)$/i.test(event.type);
              if (!pointerInfo) {
                pointerInfo = new PointerInfo(id, pointer, event, null, null);
                pointerIndex = this.pointers.length;
                this.pointers.push(pointerInfo);
              } else {
                pointerInfo.pointer = pointer;
              }
              setCoords(this.coords.cur, this.pointers.map((p) => p.pointer), this._now());
              setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur);
              if (down) {
                this.pointerIsDown = true;
                pointerInfo.downTime = this.coords.cur.timeStamp;
                pointerInfo.downTarget = eventTarget;
                utils_pointerExtend(this.downPointer, pointer);
                if (!this.interacting()) {
                  copyCoords(this.coords.start, this.coords.cur);
                  copyCoords(this.coords.prev, this.coords.cur);
                  this.downEvent = event;
                  this.pointerWasMoved = false;
                }
              }
              this._updateLatestPointer(pointer, event, eventTarget);
              this._scopeFire("interactions:update-pointer", {
                pointer,
                event,
                eventTarget,
                down,
                pointerInfo,
                pointerIndex,
                interaction: this
              });
              return pointerIndex;
            }
            removePointer(pointer, event) {
              const pointerIndex = this.getPointerIndex(pointer);
              if (pointerIndex === -1) return;
              const pointerInfo = this.pointers[pointerIndex];
              this._scopeFire("interactions:remove-pointer", {
                pointer,
                event,
                eventTarget: null,
                pointerIndex,
                pointerInfo,
                interaction: this
              });
              this.pointers.splice(pointerIndex, 1);
              this.pointerIsDown = false;
            }
            _updateLatestPointer(pointer, event, eventTarget) {
              this._latestPointer.pointer = pointer;
              this._latestPointer.event = event;
              this._latestPointer.eventTarget = eventTarget;
            }
            destroy() {
              this._latestPointer.pointer = null;
              this._latestPointer.event = null;
              this._latestPointer.eventTarget = null;
            }
            _createPreparedEvent(event, phase, preEnd, type) {
              return new InteractEvent_InteractEvent(this, event, this.prepared.name, phase, this.element, preEnd, type);
            }
            _fireEvent(iEvent) {
              this.interactable.fire(iEvent);
              if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {
                this.prevEvent = iEvent;
              }
            }
            _doPhase(signalArg) {
              const {
                event,
                phase,
                preEnd,
                type
              } = signalArg;
              const {
                rect
              } = this;
              if (rect && phase === "move") {
                addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource]);
                rect.width = rect.right - rect.left;
                rect.height = rect.bottom - rect.top;
              }
              const beforeResult = this._scopeFire(`interactions:before-action-${phase}`, signalArg);
              if (beforeResult === false) {
                return false;
              }
              const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type);
              this._scopeFire(`interactions:action-${phase}`, signalArg);
              if (phase === "start") {
                this.prevEvent = iEvent;
              }
              this._fireEvent(iEvent);
              this._scopeFire(`interactions:after-action-${phase}`, signalArg);
              return true;
            }
            _now() {
              return Date.now();
            }
          }
          var core_Interaction = Interaction_Interaction;
          function preventDefault(newValue) {
            if (/^(always|never|auto)$/.test(newValue)) {
              this.options.preventDefault = newValue;
              return this;
            }
            if (is.bool(newValue)) {
              this.options.preventDefault = newValue ? "always" : "never";
              return this;
            }
            return this.options.preventDefault;
          }
          function checkAndPreventDefault(interactable, scope, event) {
            const setting = interactable.options.preventDefault;
            if (setting === "never") return;
            if (setting === "always") {
              event.preventDefault();
              return;
            }
            if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {
              const doc = getWindow(event.target).document;
              const docOptions = scope.getDocOptions(doc);
              if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {
                return;
              }
            }
            if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {
              return;
            }
            if (is.element(event.target) && matchesSelector(event.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *")) {
              return;
            }
            event.preventDefault();
          }
          function onInteractionEvent({
            interaction,
            event
          }) {
            if (interaction.interactable) {
              interaction.interactable.checkAndPreventDefault(event);
            }
          }
          function interactablePreventDefault_install(scope) {
            const {
              Interactable
            } = scope;
            Interactable.prototype.preventDefault = preventDefault;
            Interactable.prototype.checkAndPreventDefault = function(event) {
              return checkAndPreventDefault(this, scope, event);
            };
            scope.interactions.docEvents.push({
              type: "dragstart",
              listener(event) {
                for (const interaction of scope.interactions.list) {
                  if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {
                    interaction.interactable.checkAndPreventDefault(event);
                    return;
                  }
                }
              }
            });
          }
          var interactablePreventDefault = {
            id: "core/interactablePreventDefault",
            install: interactablePreventDefault_install,
            listeners: ["down", "move", "up", "cancel"].reduce((acc, eventType) => {
              acc[`interactions:${eventType}`] = onInteractionEvent;
              return acc;
            }, {})
          };
          const finder = {
            methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"],
            search(details) {
              for (const method of finder.methodOrder) {
                const interaction = finder[method](details);
                if (interaction) {
                  return interaction;
                }
              }
              return null;
            },
            // try to resume simulation with a new pointer
            simulationResume({
              pointerType,
              eventType,
              eventTarget,
              scope
            }) {
              if (!/down|start/i.test(eventType)) {
                return null;
              }
              for (const interaction of scope.interactions.list) {
                let element = eventTarget;
                if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) {
                  while (element) {
                    if (element === interaction.element) {
                      return interaction;
                    }
                    element = parentNode(element);
                  }
                }
              }
              return null;
            },
            // if it's a mouse or pen interaction
            mouseOrPen({
              pointerId,
              pointerType,
              eventType,
              scope
            }) {
              if (pointerType !== "mouse" && pointerType !== "pen") {
                return null;
              }
              let firstNonActive;
              for (const interaction of scope.interactions.list) {
                if (interaction.pointerType === pointerType) {
                  if (interaction.simulation && !hasPointerId(interaction, pointerId)) {
                    continue;
                  }
                  if (interaction.interacting()) {
                    return interaction;
                  } else if (!firstNonActive) {
                    firstNonActive = interaction;
                  }
                }
              }
              if (firstNonActive) {
                return firstNonActive;
              }
              for (const interaction of scope.interactions.list) {
                if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {
                  return interaction;
                }
              }
              return null;
            },
            // get interaction that has this pointer
            hasPointer({
              pointerId,
              scope
            }) {
              for (const interaction of scope.interactions.list) {
                if (hasPointerId(interaction, pointerId)) {
                  return interaction;
                }
              }
              return null;
            },
            // get first idle interaction with a matching pointerType
            idle({
              pointerType,
              scope
            }) {
              for (const interaction of scope.interactions.list) {
                if (interaction.pointers.length === 1) {
                  const target = interaction.interactable;
                  if (target && !(target.options.gesture && target.options.gesture.enabled)) {
                    continue;
                  }
                } else if (interaction.pointers.length >= 2) {
                  continue;
                }
                if (!interaction.interacting() && pointerType === interaction.pointerType) {
                  return interaction;
                }
              }
              return null;
            }
          };
          function hasPointerId(interaction, pointerId) {
            return interaction.pointers.some(({
              id
            }) => id === pointerId);
          }
          var interactionFinder = finder;
          const methodNames = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"];
          function interactions_install(scope) {
            const listeners = {};
            for (const method of methodNames) {
              listeners[method] = doOnInteractions(method, scope);
            }
            const pEventTypes = utils_browser.pEventTypes;
            let docEvents;
            if (utils_domObjects.PointerEvent) {
              docEvents = [{
                type: pEventTypes.down,
                listener: releasePointersOnRemovedEls
              }, {
                type: pEventTypes.down,
                listener: listeners.pointerDown
              }, {
                type: pEventTypes.move,
                listener: listeners.pointerMove
              }, {
                type: pEventTypes.up,
                listener: listeners.pointerUp
              }, {
                type: pEventTypes.cancel,
                listener: listeners.pointerUp
              }];
            } else {
              docEvents = [{
                type: "mousedown",
                listener: listeners.pointerDown
              }, {
                type: "mousemove",
                listener: listeners.pointerMove
              }, {
                type: "mouseup",
                listener: listeners.pointerUp
              }, {
                type: "touchstart",
                listener: releasePointersOnRemovedEls
              }, {
                type: "touchstart",
                listener: listeners.pointerDown
              }, {
                type: "touchmove",
                listener: listeners.pointerMove
              }, {
                type: "touchend",
                listener: listeners.pointerUp
              }, {
                type: "touchcancel",
                listener: listeners.pointerUp
              }];
            }
            docEvents.push({
              type: "blur",
              listener(event) {
                for (const interaction of scope.interactions.list) {
                  interaction.documentBlur(event);
                }
              }
            });
            scope.prevTouchTime = 0;
            scope.Interaction = class extends core_Interaction {
              get pointerMoveTolerance() {
                return scope.interactions.pointerMoveTolerance;
              }
              set pointerMoveTolerance(value) {
                scope.interactions.pointerMoveTolerance = value;
              }
              _now() {
                return scope.now();
              }
            };
            scope.interactions = {
              // all active and idle interactions
              list: [],
              new(options) {
                options.scopeFire = (name, arg) => scope.fire(name, arg);
                const interaction = new scope.Interaction(options);
                scope.interactions.list.push(interaction);
                return interaction;
              },
              listeners,
              docEvents,
              pointerMoveTolerance: 1
            };
            function releasePointersOnRemovedEls() {
              for (const interaction of scope.interactions.list) {
                if (!interaction.pointerIsDown || interaction.pointerType !== "touch" || interaction._interacting) {
                  continue;
                }
                for (const pointer of interaction.pointers) {
                  if (!scope.documents.some(({
                    doc
                  }) => nodeContains(doc, pointer.downTarget))) {
                    interaction.removePointer(pointer.pointer, pointer.event);
                  }
                }
              }
            }
            scope.usePlugin(interactablePreventDefault);
          }
          function doOnInteractions(method, scope) {
            return function(event) {
              const interactions = scope.interactions.list;
              const pointerType = getPointerType(event);
              const [eventTarget, curEventTarget] = getEventTargets(event);
              const matches = [];
              if (/^touch/.test(event.type)) {
                scope.prevTouchTime = scope.now();
                for (const changedTouch of event.changedTouches) {
                  const pointer = changedTouch;
                  const pointerId = getPointerId(pointer);
                  const searchDetails = {
                    pointer,
                    pointerId,
                    pointerType,
                    eventType: event.type,
                    eventTarget,
                    curEventTarget,
                    scope
                  };
                  const interaction = getInteraction(searchDetails);
                  matches.push([searchDetails.pointer, searchDetails.eventTarget, searchDetails.curEventTarget, interaction]);
                }
              } else {
                let invalidPointer = false;
                if (!utils_browser.supportsPointerEvent && /mouse/.test(event.type)) {
                  for (let i = 0; i < interactions.length && !invalidPointer; i++) {
                    invalidPointer = interactions[i].pointerType !== "mouse" && interactions[i].pointerIsDown;
                  }
                  invalidPointer = invalidPointer || scope.now() - scope.prevTouchTime < 500 || // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated
                  event.timeStamp === 0;
                }
                if (!invalidPointer) {
                  const searchDetails = {
                    pointer: event,
                    pointerId: getPointerId(event),
                    pointerType,
                    eventType: event.type,
                    curEventTarget,
                    eventTarget,
                    scope
                  };
                  const interaction = getInteraction(searchDetails);
                  matches.push([searchDetails.pointer, searchDetails.eventTarget, searchDetails.curEventTarget, interaction]);
                }
              }
              for (const [pointer, eventTarget2, curEventTarget2, interaction] of matches) {
                interaction[method](pointer, event, eventTarget2, curEventTarget2);
              }
            };
          }
          function getInteraction(searchDetails) {
            const {
              pointerType,
              scope
            } = searchDetails;
            const foundInteraction = interactionFinder.search(searchDetails);
            const signalArg = {
              interaction: foundInteraction,
              searchDetails
            };
            scope.fire("interactions:find", signalArg);
            return signalArg.interaction || scope.interactions.new({
              pointerType
            });
          }
          function onDocSignal({
            doc,
            scope,
            options
          }, eventMethodName) {
            const {
              interactions: {
                docEvents
              },
              events: events2
            } = scope;
            const eventMethod = events2[eventMethodName];
            if (scope.browser.isIOS && !options.events) {
              options.events = {
                passive: false
              };
            }
            for (const eventType in events2.delegatedEvents) {
              eventMethod(doc, eventType, events2.delegateListener);
              eventMethod(doc, eventType, events2.delegateUseCapture, true);
            }
            const eventOptions = options && options.events;
            for (const {
              type,
              listener
            } of docEvents) {
              eventMethod(doc, type, listener, eventOptions);
            }
          }
          const interactions_interactions = {
            id: "core/interactions",
            install: interactions_install,
            listeners: {
              "scope:add-document": (arg) => onDocSignal(arg, "add"),
              "scope:remove-document": (arg) => onDocSignal(arg, "remove"),
              "interactable:unset": ({
                interactable
              }, scope) => {
                for (let i = scope.interactions.list.length - 1; i >= 0; i--) {
                  const interaction = scope.interactions.list[i];
                  if (interaction.interactable !== interactable) {
                    continue;
                  }
                  interaction.stop();
                  scope.fire("interactions:destroy", {
                    interaction
                  });
                  interaction.destroy();
                  if (scope.interactions.list.length > 2) {
                    scope.interactions.list.splice(i, 1);
                  }
                }
              }
            },
            onDocSignal,
            doOnInteractions,
            methodNames
          };
          var core_interactions = interactions_interactions;
          class scope_Scope {
            // main window
            // main document
            // main window
            // all documents being listened to
            constructor() {
              this.id = `__interact_scope_${Math.floor(Math.random() * 100)}`;
              this.isInitialized = false;
              this.listenerMaps = [];
              this.browser = utils_browser;
              this.defaults = clone(defaultOptions_defaults);
              this.Eventable = Eventable_Eventable;
              this.actions = {
                map: {},
                phases: {
                  start: true,
                  move: true,
                  end: true
                },
                methodDict: {},
                phaselessTypes: {}
              };
              this.interactStatic = createInteractStatic(this);
              this.InteractEvent = InteractEvent_InteractEvent;
              this.Interactable = void 0;
              this.interactables = new InteractableSet_InteractableSet(this);
              this._win = void 0;
              this.document = void 0;
              this.window = void 0;
              this.documents = [];
              this._plugins = {
                list: [],
                map: {}
              };
              this.onWindowUnload = (event) => this.removeDocument(event.target);
              const scope = this;
              this.Interactable = class extends Interactable_Interactable {
                get _defaults() {
                  return scope.defaults;
                }
                set(options) {
                  super.set(options);
                  scope.fire("interactable:set", {
                    options,
                    interactable: this
                  });
                  return this;
                }
                unset() {
                  super.unset();
                  scope.interactables.list.splice(scope.interactables.list.indexOf(this), 1);
                  scope.fire("interactable:unset", {
                    interactable: this
                  });
                }
              };
            }
            addListeners(map, id) {
              this.listenerMaps.push({
                id,
                map
              });
            }
            fire(name, arg) {
              for (const {
                map: {
                  [name]: listener
                }
              } of this.listenerMaps) {
                if (!!listener && listener(arg, this, name) === false) {
                  return false;
                }
              }
            }
            init(window2) {
              return this.isInitialized ? this : initScope(this, window2);
            }
            pluginIsInstalled(plugin) {
              return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1;
            }
            usePlugin(plugin, options) {
              if (!this.isInitialized) {
                return this;
              }
              if (this.pluginIsInstalled(plugin)) {
                return this;
              }
              if (plugin.id) {
                this._plugins.map[plugin.id] = plugin;
              }
              this._plugins.list.push(plugin);
              if (plugin.install) {
                plugin.install(this, options);
              }
              if (plugin.listeners && plugin.before) {
                let index = 0;
                const len = this.listenerMaps.length;
                const before = plugin.before.reduce((acc, id) => {
                  acc[id] = true;
                  acc[pluginIdRoot(id)] = true;
                  return acc;
                }, {});
                for (; index < len; index++) {
                  const otherId = this.listenerMaps[index].id;
                  if (before[otherId] || before[pluginIdRoot(otherId)]) {
                    break;
                  }
                }
                this.listenerMaps.splice(index, 0, {
                  id: plugin.id,
                  map: plugin.listeners
                });
              } else if (plugin.listeners) {
                this.listenerMaps.push({
                  id: plugin.id,
                  map: plugin.listeners
                });
              }
              return this;
            }
            addDocument(doc, options) {
              if (this.getDocIndex(doc) !== -1) {
                return false;
              }
              const window2 = getWindow(doc);
              options = options ? extend2({}, options) : {};
              this.documents.push({
                doc,
                options
              });
              this.events.documents.push(doc);
              if (doc !== this.document) {
                this.events.add(window2, "unload", this.onWindowUnload);
              }
              this.fire("scope:add-document", {
                doc,
                window: window2,
                scope: this,
                options
              });
            }
            removeDocument(doc) {
              const index = this.getDocIndex(doc);
              const window2 = getWindow(doc);
              const options = this.documents[index].options;
              this.events.remove(window2, "unload", this.onWindowUnload);
              this.documents.splice(index, 1);
              this.events.documents.splice(index, 1);
              this.fire("scope:remove-document", {
                doc,
                window: window2,
                scope: this,
                options
              });
            }
            getDocIndex(doc) {
              for (let i = 0; i < this.documents.length; i++) {
                if (this.documents[i].doc === doc) {
                  return i;
                }
              }
              return -1;
            }
            getDocOptions(doc) {
              const docIndex = this.getDocIndex(doc);
              return docIndex === -1 ? null : this.documents[docIndex].options;
            }
            now() {
              return (this.window.Date || Date).now();
            }
          }
          function initScope(scope, window2) {
            scope.isInitialized = true;
            window_init(window2);
            utils_domObjects.init(window2);
            utils_browser.init(window2);
            raf.init(window2);
            scope.window = window2;
            scope.document = window2.document;
            scope.usePlugin(core_interactions);
            scope.usePlugin(events);
            return scope;
          }
          function pluginIdRoot(id) {
            return id && id.replace(/\/.*$/, "");
          }
          const interact_scope = new scope_Scope();
          const interact_interact = interact_scope.interactStatic;
          var _interactjs_interact = interact_interact;
          const interact_init = (win2) => interact_scope.init(win2);
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          function InteractableMethods_install(scope) {
            const {
              /** @lends Interactable */
              Interactable
              // tslint:disable-line no-shadowed-variable
            } = scope;
            Interactable.prototype.getAction = function getAction(pointer, event, interaction, element) {
              const action = defaultActionChecker(this, event, interaction, element, scope);
              if (this.options.actionChecker) {
                return this.options.actionChecker(pointer, event, action, this, element, interaction);
              }
              return action;
            };
            Interactable.prototype.ignoreFrom = warnOnce(function(newValue) {
              return this._backCompatOption("ignoreFrom", newValue);
            }, "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).");
            Interactable.prototype.allowFrom = warnOnce(function(newValue) {
              return this._backCompatOption("allowFrom", newValue);
            }, "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).");
            Interactable.prototype.actionChecker = actionChecker;
            Interactable.prototype.styleCursor = styleCursor;
          }
          function defaultActionChecker(interactable, event, interaction, element, scope) {
            const rect = interactable.getRect(element);
            const buttons = event.buttons || {
              0: 1,
              1: 4,
              3: 8,
              4: 16
            }[event.button];
            const arg = {
              action: null,
              interactable,
              interaction,
              element,
              rect,
              buttons
            };
            scope.fire("auto-start:check", arg);
            return arg.action;
          }
          function styleCursor(newValue) {
            if (is.bool(newValue)) {
              this.options.styleCursor = newValue;
              return this;
            }
            if (newValue === null) {
              delete this.options.styleCursor;
              return this;
            }
            return this.options.styleCursor;
          }
          function actionChecker(checker) {
            if (is.func(checker)) {
              this.options.actionChecker = checker;
              return this;
            }
            if (checker === null) {
              delete this.options.actionChecker;
              return this;
            }
            return this.options.actionChecker;
          }
          var InteractableMethods = {
            id: "auto-start/interactableMethods",
            install: InteractableMethods_install
          };
          function base_install(scope) {
            const {
              interactStatic: interact,
              defaults
            } = scope;
            scope.usePlugin(InteractableMethods);
            defaults.base.actionChecker = null;
            defaults.base.styleCursor = true;
            extend2(defaults.perAction, {
              manualStart: false,
              max: Infinity,
              maxPerElement: 1,
              allowFrom: null,
              ignoreFrom: null,
              // only allow left button by default
              // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value
              mouseButtons: 1
            });
            interact.maxInteractions = (newValue) => maxInteractions(newValue, scope);
            scope.autoStart = {
              // Allow this many interactions to happen simultaneously
              maxInteractions: Infinity,
              withinInteractionLimit,
              cursorElement: null
            };
          }
          function prepareOnDown({
            interaction,
            pointer,
            event,
            eventTarget
          }, scope) {
            if (interaction.interacting()) return;
            const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
            prepare(interaction, actionInfo, scope);
          }
          function prepareOnMove({
            interaction,
            pointer,
            event,
            eventTarget
          }, scope) {
            if (interaction.pointerType !== "mouse" || interaction.pointerIsDown || interaction.interacting()) return;
            const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
            prepare(interaction, actionInfo, scope);
          }
          function startOnMove(arg, scope) {
            const {
              interaction
            } = arg;
            if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) {
              return;
            }
            scope.fire("autoStart:before-start", arg);
            const {
              interactable
            } = interaction;
            const actionName = interaction.prepared.name;
            if (actionName && interactable) {
              if (interactable.options[actionName].manualStart || !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)) {
                interaction.stop();
              } else {
                interaction.start(interaction.prepared, interactable, interaction.element);
                setInteractionCursor(interaction, scope);
              }
            }
          }
          function clearCursorOnStop({
            interaction
          }, scope) {
            const {
              interactable
            } = interaction;
            if (interactable && interactable.options.styleCursor) {
              setCursor(interaction.element, "", scope);
            }
          }
          function validateAction(action, interactable, element, eventTarget, scope) {
            if (interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && withinInteractionLimit(interactable, element, action, scope)) {
              return action;
            }
            return null;
          }
          function validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope) {
            for (let i = 0, len = matches.length; i < len; i++) {
              const match = matches[i];
              const matchElement = matchElements[i];
              const matchAction = match.getAction(pointer, event, interaction, matchElement);
              if (!matchAction) {
                continue;
              }
              const action = validateAction(matchAction, match, matchElement, eventTarget, scope);
              if (action) {
                return {
                  action,
                  interactable: match,
                  element: matchElement
                };
              }
            }
            return {
              action: null,
              interactable: null,
              element: null
            };
          }
          function getActionInfo(interaction, pointer, event, eventTarget, scope) {
            let matches = [];
            let matchElements = [];
            let element = eventTarget;
            function pushMatches(interactable) {
              matches.push(interactable);
              matchElements.push(element);
            }
            while (is.element(element)) {
              matches = [];
              matchElements = [];
              scope.interactables.forEachMatch(element, pushMatches);
              const actionInfo = validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope);
              if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {
                return actionInfo;
              }
              element = parentNode(element);
            }
            return {
              action: null,
              interactable: null,
              element: null
            };
          }
          function prepare(interaction, {
            action,
            interactable,
            element
          }, scope) {
            action = action || {
              name: null
            };
            interaction.interactable = interactable;
            interaction.element = element;
            copyAction(interaction.prepared, action);
            interaction.rect = interactable && action.name ? interactable.getRect(element) : null;
            setInteractionCursor(interaction, scope);
            scope.fire("autoStart:prepared", {
              interaction
            });
          }
          function withinInteractionLimit(interactable, element, action, scope) {
            const options = interactable.options;
            const maxActions = options[action.name].max;
            const maxPerElement = options[action.name].maxPerElement;
            const autoStartMax = scope.autoStart.maxInteractions;
            let activeInteractions = 0;
            let interactableCount = 0;
            let elementCount = 0;
            if (!(maxActions && maxPerElement && autoStartMax)) {
              return false;
            }
            for (const interaction of scope.interactions.list) {
              const otherAction = interaction.prepared.name;
              if (!interaction.interacting()) {
                continue;
              }
              activeInteractions++;
              if (activeInteractions >= autoStartMax) {
                return false;
              }
              if (interaction.interactable !== interactable) {
                continue;
              }
              interactableCount += otherAction === action.name ? 1 : 0;
              if (interactableCount >= maxActions) {
                return false;
              }
              if (interaction.element === element) {
                elementCount++;
                if (otherAction === action.name && elementCount >= maxPerElement) {
                  return false;
                }
              }
            }
            return autoStartMax > 0;
          }
          function maxInteractions(newValue, scope) {
            if (is.number(newValue)) {
              scope.autoStart.maxInteractions = newValue;
              return this;
            }
            return scope.autoStart.maxInteractions;
          }
          function setCursor(element, cursor, scope) {
            const {
              cursorElement: prevCursorElement
            } = scope.autoStart;
            if (prevCursorElement && prevCursorElement !== element) {
              prevCursorElement.style.cursor = "";
            }
            element.ownerDocument.documentElement.style.cursor = cursor;
            element.style.cursor = cursor;
            scope.autoStart.cursorElement = cursor ? element : null;
          }
          function setInteractionCursor(interaction, scope) {
            const {
              interactable,
              element,
              prepared
            } = interaction;
            if (!(interaction.pointerType === "mouse" && interactable && interactable.options.styleCursor)) {
              if (scope.autoStart.cursorElement) {
                setCursor(scope.autoStart.cursorElement, "", scope);
              }
              return;
            }
            let cursor = "";
            if (prepared.name) {
              const cursorChecker = interactable.options[prepared.name].cursorChecker;
              if (is.func(cursorChecker)) {
                cursor = cursorChecker(prepared, interactable, element, interaction._interacting);
              } else {
                cursor = scope.actions.map[prepared.name].getCursor(prepared);
              }
            }
            setCursor(interaction.element, cursor || "", scope);
          }
          const autoStart = {
            id: "auto-start/base",
            before: ["actions"],
            install: base_install,
            listeners: {
              "interactions:down": prepareOnDown,
              "interactions:move": (arg, scope) => {
                prepareOnMove(arg, scope);
                startOnMove(arg, scope);
              },
              "interactions:stop": clearCursorOnStop
            },
            maxInteractions,
            withinInteractionLimit,
            validateAction
          };
          var base = autoStart;
          function beforeStart({
            interaction,
            eventTarget,
            dx,
            dy
          }, scope) {
            if (interaction.prepared.name !== "drag") return;
            const absX = Math.abs(dx);
            const absY = Math.abs(dy);
            const targetOptions = interaction.interactable.options.drag;
            const startAxis = targetOptions.startAxis;
            const currentAxis = absX > absY ? "x" : absX < absY ? "y" : "xy";
            interaction.prepared.axis = targetOptions.lockAxis === "start" ? currentAxis[0] : (
              // always lock to one axis even if currentAxis === 'xy'
              targetOptions.lockAxis
            );
            if (currentAxis !== "xy" && startAxis !== "xy" && startAxis !== currentAxis) {
              ;
              interaction.prepared.name = null;
              let element = eventTarget;
              const getDraggable = function(interactable) {
                if (interactable === interaction.interactable) return;
                const options = interaction.interactable.options.drag;
                if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {
                  const action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);
                  if (action && action.name === "drag" && checkStartAxis(currentAxis, interactable) && base.validateAction(action, interactable, element, eventTarget, scope)) {
                    return interactable;
                  }
                }
              };
              while (is.element(element)) {
                const interactable = scope.interactables.forEachMatch(element, getDraggable);
                if (interactable) {
                  ;
                  interaction.prepared.name = "drag";
                  interaction.interactable = interactable;
                  interaction.element = element;
                  break;
                }
                element = parentNode(element);
              }
            }
          }
          function checkStartAxis(startAxis, interactable) {
            if (!interactable) {
              return false;
            }
            const thisAxis = interactable.options.drag.startAxis;
            return startAxis === "xy" || thisAxis === "xy" || thisAxis === startAxis;
          }
          var dragAxis = {
            id: "auto-start/dragAxis",
            listeners: {
              "autoStart:before-start": beforeStart
            }
          };
          function hold_install(scope) {
            const {
              defaults
            } = scope;
            scope.usePlugin(base);
            defaults.perAction.hold = 0;
            defaults.perAction.delay = 0;
          }
          function getHoldDuration(interaction) {
            const actionName = interaction.prepared && interaction.prepared.name;
            if (!actionName) {
              return null;
            }
            const options = interaction.interactable.options;
            return options[actionName].hold || options[actionName].delay;
          }
          const hold = {
            id: "auto-start/hold",
            install: hold_install,
            listeners: {
              "interactions:new": ({
                interaction
              }) => {
                interaction.autoStartHoldTimer = null;
              },
              "autoStart:prepared": ({
                interaction
              }) => {
                const hold2 = getHoldDuration(interaction);
                if (hold2 > 0) {
                  interaction.autoStartHoldTimer = setTimeout(() => {
                    interaction.start(interaction.prepared, interaction.interactable, interaction.element);
                  }, hold2);
                }
              },
              "interactions:move": ({
                interaction,
                duplicate
              }) => {
                if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {
                  clearTimeout(interaction.autoStartHoldTimer);
                  interaction.autoStartHoldTimer = null;
                }
              },
              // prevent regular down->move autoStart
              "autoStart:before-start": ({
                interaction
              }) => {
                const holdDuration = getHoldDuration(interaction);
                if (holdDuration > 0) {
                  interaction.prepared.name = null;
                }
              }
            },
            getHoldDuration
          };
          var auto_start_hold = hold;
          var auto_start_plugin = {
            id: "auto-start",
            install(scope) {
              scope.usePlugin(base);
              scope.usePlugin(auto_start_hold);
              scope.usePlugin(dragAxis);
            }
          };
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(auto_start_plugin);
          function plugin_install(scope) {
            const {
              actions,
              Interactable,
              defaults
            } = scope;
            Interactable.prototype.draggable = drag.draggable;
            actions.map.drag = drag;
            actions.methodDict.drag = "draggable";
            defaults.actions.drag = drag.defaults;
          }
          function beforeMove({
            interaction
          }) {
            if (interaction.prepared.name !== "drag") return;
            const axis = interaction.prepared.axis;
            if (axis === "x") {
              interaction.coords.cur.page.y = interaction.coords.start.page.y;
              interaction.coords.cur.client.y = interaction.coords.start.client.y;
              interaction.coords.velocity.client.y = 0;
              interaction.coords.velocity.page.y = 0;
            } else if (axis === "y") {
              interaction.coords.cur.page.x = interaction.coords.start.page.x;
              interaction.coords.cur.client.x = interaction.coords.start.client.x;
              interaction.coords.velocity.client.x = 0;
              interaction.coords.velocity.page.x = 0;
            }
          }
          function move({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "drag") return;
            const axis = interaction.prepared.axis;
            if (axis === "x" || axis === "y") {
              const opposite = axis === "x" ? "y" : "x";
              iEvent.page[opposite] = interaction.coords.start.page[opposite];
              iEvent.client[opposite] = interaction.coords.start.client[opposite];
              iEvent.delta[opposite] = 0;
            }
          }
          const plugin_draggable = function draggable(options) {
            if (is.object(options)) {
              this.options.drag.enabled = options.enabled !== false;
              this.setPerAction("drag", options);
              this.setOnEvents("drag", options);
              if (/^(xy|x|y|start)$/.test(options.lockAxis)) {
                this.options.drag.lockAxis = options.lockAxis;
              }
              if (/^(xy|x|y)$/.test(options.startAxis)) {
                this.options.drag.startAxis = options.startAxis;
              }
              return this;
            }
            if (is.bool(options)) {
              this.options.drag.enabled = options;
              return this;
            }
            return this.options.drag;
          };
          const drag = {
            id: "actions/drag",
            install: plugin_install,
            listeners: {
              "interactions:before-action-move": beforeMove,
              "interactions:action-resume": beforeMove,
              // dragmove
              "interactions:action-move": move,
              "auto-start:check": (arg) => {
                const {
                  interaction,
                  interactable,
                  buttons
                } = arg;
                const dragOptions = interactable.options.drag;
                if (!(dragOptions && dragOptions.enabled) || // check mouseButton setting if the pointer is down
                interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & interactable.options.drag.mouseButtons) === 0) {
                  return void 0;
                }
                arg.action = {
                  name: "drag",
                  axis: dragOptions.lockAxis === "start" ? dragOptions.startAxis : dragOptions.lockAxis
                };
                return false;
              }
            },
            draggable: plugin_draggable,
            beforeMove,
            move,
            defaults: {
              startAxis: "xy",
              lockAxis: "xy"
            },
            getCursor() {
              return "move";
            }
          };
          var drag_plugin = drag;
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(drag_plugin);
          function resize_plugin_install(scope) {
            const {
              actions,
              browser: browser2,
              /** @lends Interactable */
              Interactable,
              // tslint:disable-line no-shadowed-variable
              defaults
            } = scope;
            resize.cursors = initCursors(browser2);
            resize.defaultMargin = browser2.supportsTouch || browser2.supportsPointerEvent ? 20 : 10;
            Interactable.prototype.resizable = function(options) {
              return resizable(this, options, scope);
            };
            actions.map.resize = resize;
            actions.methodDict.resize = "resizable";
            defaults.actions.resize = resize.defaults;
          }
          function resizeChecker(arg) {
            const {
              interaction,
              interactable,
              element,
              rect,
              buttons
            } = arg;
            if (!rect) {
              return void 0;
            }
            const page = extend2({}, interaction.coords.cur.page);
            const resizeOptions = interactable.options.resize;
            if (!(resizeOptions && resizeOptions.enabled) || // check mouseButton setting if the pointer is down
            interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & resizeOptions.mouseButtons) === 0) {
              return void 0;
            }
            if (is.object(resizeOptions.edges)) {
              const resizeEdges = {
                left: false,
                right: false,
                top: false,
                bottom: false
              };
              for (const edge in resizeEdges) {
                resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._latestPointer.eventTarget, element, rect, resizeOptions.margin || resize.defaultMargin);
              }
              resizeEdges.left = resizeEdges.left && !resizeEdges.right;
              resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;
              if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {
                arg.action = {
                  name: "resize",
                  edges: resizeEdges
                };
              }
            } else {
              const right = resizeOptions.axis !== "y" && page.x > rect.right - resize.defaultMargin;
              const bottom = resizeOptions.axis !== "x" && page.y > rect.bottom - resize.defaultMargin;
              if (right || bottom) {
                arg.action = {
                  name: "resize",
                  axes: (right ? "x" : "") + (bottom ? "y" : "")
                };
              }
            }
            return arg.action ? false : void 0;
          }
          function resizable(interactable, options, scope) {
            if (is.object(options)) {
              interactable.options.resize.enabled = options.enabled !== false;
              interactable.setPerAction("resize", options);
              interactable.setOnEvents("resize", options);
              if (is.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {
                interactable.options.resize.axis = options.axis;
              } else if (options.axis === null) {
                interactable.options.resize.axis = scope.defaults.actions.resize.axis;
              }
              if (is.bool(options.preserveAspectRatio)) {
                interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio;
              } else if (is.bool(options.square)) {
                interactable.options.resize.square = options.square;
              }
              return interactable;
            }
            if (is.bool(options)) {
              interactable.options.resize.enabled = options;
              return interactable;
            }
            return interactable.options.resize;
          }
          function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {
            if (!value) {
              return false;
            }
            if (value === true) {
              const width = is.number(rect.width) ? rect.width : rect.right - rect.left;
              const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top;
              margin = Math.min(margin, Math.abs((name === "left" || name === "right" ? width : height) / 2));
              if (width < 0) {
                if (name === "left") {
                  name = "right";
                } else if (name === "right") {
                  name = "left";
                }
              }
              if (height < 0) {
                if (name === "top") {
                  name = "bottom";
                } else if (name === "bottom") {
                  name = "top";
                }
              }
              if (name === "left") {
                return page.x < (width >= 0 ? rect.left : rect.right) + margin;
              }
              if (name === "top") {
                return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;
              }
              if (name === "right") {
                return page.x > (width >= 0 ? rect.right : rect.left) - margin;
              }
              if (name === "bottom") {
                return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;
              }
            }
            if (!is.element(element)) {
              return false;
            }
            return is.element(value) ? (
              // the value is an element to use as a resize handle
              value === element
            ) : (
              // otherwise check if element matches value as selector
              matchesUpTo(element, value, interactableElement)
            );
          }
          function initCursors(browser2) {
            return browser2.isIe9 ? {
              x: "e-resize",
              y: "s-resize",
              xy: "se-resize",
              top: "n-resize",
              left: "w-resize",
              bottom: "s-resize",
              right: "e-resize",
              topleft: "se-resize",
              bottomright: "se-resize",
              topright: "ne-resize",
              bottomleft: "ne-resize"
            } : {
              x: "ew-resize",
              y: "ns-resize",
              xy: "nwse-resize",
              top: "ns-resize",
              left: "ew-resize",
              bottom: "ns-resize",
              right: "ew-resize",
              topleft: "nwse-resize",
              bottomright: "nwse-resize",
              topright: "nesw-resize",
              bottomleft: "nesw-resize"
            };
          }
          function start({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) {
              return;
            }
            const resizeEvent = iEvent;
            const rect = interaction.rect;
            interaction._rects = {
              start: extend2({}, rect),
              corrected: extend2({}, rect),
              previous: extend2({}, rect),
              delta: {
                left: 0,
                right: 0,
                width: 0,
                top: 0,
                bottom: 0,
                height: 0
              }
            };
            resizeEvent.edges = interaction.prepared.edges;
            resizeEvent.rect = interaction._rects.corrected;
            resizeEvent.deltaRect = interaction._rects.delta;
          }
          function plugin_move({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) return;
            const resizeEvent = iEvent;
            const resizeOptions = interaction.interactable.options.resize;
            const invert = resizeOptions.invert;
            const invertible = invert === "reposition" || invert === "negate";
            const current = interaction.rect;
            const {
              start: startRect,
              corrected,
              delta: deltaRect,
              previous
            } = interaction._rects;
            extend2(previous, corrected);
            if (invertible) {
              extend2(corrected, current);
              if (invert === "reposition") {
                if (corrected.top > corrected.bottom) {
                  const swap = corrected.top;
                  corrected.top = corrected.bottom;
                  corrected.bottom = swap;
                }
                if (corrected.left > corrected.right) {
                  const swap = corrected.left;
                  corrected.left = corrected.right;
                  corrected.right = swap;
                }
              }
            } else {
              corrected.top = Math.min(current.top, startRect.bottom);
              corrected.bottom = Math.max(current.bottom, startRect.top);
              corrected.left = Math.min(current.left, startRect.right);
              corrected.right = Math.max(current.right, startRect.left);
            }
            corrected.width = corrected.right - corrected.left;
            corrected.height = corrected.bottom - corrected.top;
            for (const edge in corrected) {
              deltaRect[edge] = corrected[edge] - previous[edge];
            }
            resizeEvent.edges = interaction.prepared.edges;
            resizeEvent.rect = corrected;
            resizeEvent.deltaRect = deltaRect;
          }
          function end({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) return;
            const resizeEvent = iEvent;
            resizeEvent.edges = interaction.prepared.edges;
            resizeEvent.rect = interaction._rects.corrected;
            resizeEvent.deltaRect = interaction._rects.delta;
          }
          function updateEventAxes({
            iEvent,
            interaction
          }) {
            if (interaction.prepared.name !== "resize" || !interaction.resizeAxes) return;
            const options = interaction.interactable.options;
            const resizeEvent = iEvent;
            if (options.resize.square) {
              if (interaction.resizeAxes === "y") {
                resizeEvent.delta.x = resizeEvent.delta.y;
              } else {
                resizeEvent.delta.y = resizeEvent.delta.x;
              }
              resizeEvent.axes = "xy";
            } else {
              resizeEvent.axes = interaction.resizeAxes;
              if (interaction.resizeAxes === "x") {
                resizeEvent.delta.y = 0;
              } else if (interaction.resizeAxes === "y") {
                resizeEvent.delta.x = 0;
              }
            }
          }
          const resize = {
            id: "actions/resize",
            before: ["actions/drag"],
            install: resize_plugin_install,
            listeners: {
              "interactions:new": ({
                interaction
              }) => {
                interaction.resizeAxes = "xy";
              },
              "interactions:action-start": (arg) => {
                start(arg);
                updateEventAxes(arg);
              },
              "interactions:action-move": (arg) => {
                plugin_move(arg);
                updateEventAxes(arg);
              },
              "interactions:action-end": end,
              "auto-start:check": resizeChecker
            },
            defaults: {
              square: false,
              preserveAspectRatio: false,
              axis: "xy",
              // use default margin
              margin: NaN,
              // object with props left, right, top, bottom which are
              // true/false values to resize when the pointer is over that edge,
              // CSS selectors to match the handles for each direction
              // or the Elements for each handle
              edges: null,
              // a value of 'none' will limit the resize rect to a minimum of 0x0
              // 'negate' will alow the rect to have negative width/height
              // 'reposition' will keep the width/height positive by swapping
              // the top and bottom edges and/or swapping the left and right edges
              invert: "none"
            },
            cursors: null,
            getCursor({
              edges,
              axis,
              name
            }) {
              const cursors = resize.cursors;
              let result = null;
              if (axis) {
                result = cursors[name + axis];
              } else if (edges) {
                let cursorKey = "";
                for (const edge of ["top", "bottom", "left", "right"]) {
                  if (edges[edge]) {
                    cursorKey += edge;
                  }
                }
                result = cursors[cursorKey];
              }
              return result;
            },
            defaultMargin: null
          };
          var resize_plugin = resize;
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(resize_plugin);
          var edgeTarget = () => {
          };
          var snappers_elements = () => {
          };
          var grid = (grid2) => {
            const coordFields = [["x", "y"], ["left", "top"], ["right", "bottom"], ["width", "height"]].filter(([xField, yField]) => xField in grid2 || yField in grid2);
            const gridFunc = (x, y) => {
              const {
                range,
                limits = {
                  left: -Infinity,
                  right: Infinity,
                  top: -Infinity,
                  bottom: Infinity
                },
                offset = {
                  x: 0,
                  y: 0
                }
              } = grid2;
              const result = {
                range,
                grid: grid2,
                x: null,
                y: null
              };
              for (const [xField, yField] of coordFields) {
                const gridx = Math.round((x - offset.x) / grid2[xField]);
                const gridy = Math.round((y - offset.y) / grid2[yField]);
                result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * grid2[xField] + offset.x));
                result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * grid2[yField] + offset.y));
              }
              return result;
            };
            gridFunc.grid = grid2;
            gridFunc.coordFields = coordFields;
            return gridFunc;
          };
          const snappersPlugin = {
            id: "snappers",
            install(scope) {
              const {
                interactStatic: interact
              } = scope;
              interact.snappers = extend2(interact.snappers || {}, all_namespaceObject);
              interact.createSnapGrid = interact.snappers.grid;
            }
          };
          var snappers_plugin = snappersPlugin;
          class Modification_Modification {
            constructor(interaction) {
              this.states = [];
              this.startOffset = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
              };
              this.startDelta = void 0;
              this.result = void 0;
              this.endResult = void 0;
              this.edges = void 0;
              this.interaction = void 0;
              this.interaction = interaction;
              this.result = createResult();
            }
            start({
              phase
            }, pageCoords) {
              const {
                interaction
              } = this;
              const modifierList = getModifierList(interaction);
              this.prepareStates(modifierList);
              this.edges = extend2({}, interaction.edges);
              this.startOffset = getRectOffset(interaction.rect, pageCoords);
              this.startDelta = {
                x: 0,
                y: 0
              };
              const arg = this.fillArg({
                phase,
                pageCoords,
                preEnd: false
              });
              this.result = createResult();
              this.startAll(arg);
              const result = this.result = this.setAll(arg);
              return result;
            }
            fillArg(arg) {
              const {
                interaction
              } = this;
              arg.interaction = interaction;
              arg.interactable = interaction.interactable;
              arg.element = interaction.element;
              arg.rect = arg.rect || interaction.rect;
              arg.edges = this.edges;
              arg.startOffset = this.startOffset;
              return arg;
            }
            startAll(arg) {
              for (const state of this.states) {
                if (state.methods.start) {
                  arg.state = state;
                  state.methods.start(arg);
                }
              }
            }
            setAll(arg) {
              const {
                phase,
                preEnd,
                skipModifiers,
                rect: unmodifiedRect
              } = arg;
              arg.coords = extend2({}, arg.pageCoords);
              arg.rect = extend2({}, unmodifiedRect);
              const states = skipModifiers ? this.states.slice(skipModifiers) : this.states;
              const newResult = createResult(arg.coords, arg.rect);
              for (const state of states) {
                var _state$methods;
                const {
                  options
                } = state;
                const lastModifierCoords = extend2({}, arg.coords);
                let returnValue = null;
                if ((_state$methods = state.methods) != null && _state$methods.set && this.shouldDo(options, preEnd, phase)) {
                  arg.state = state;
                  returnValue = state.methods.set(arg);
                  addEdges(this.interaction.edges, arg.rect, {
                    x: arg.coords.x - lastModifierCoords.x,
                    y: arg.coords.y - lastModifierCoords.y
                  });
                }
                newResult.eventProps.push(returnValue);
              }
              newResult.delta.x = arg.coords.x - arg.pageCoords.x;
              newResult.delta.y = arg.coords.y - arg.pageCoords.y;
              newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left;
              newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right;
              newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top;
              newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom;
              const prevCoords = this.result.coords;
              const prevRect = this.result.rect;
              if (prevCoords && prevRect) {
                const rectChanged = newResult.rect.left !== prevRect.left || newResult.rect.right !== prevRect.right || newResult.rect.top !== prevRect.top || newResult.rect.bottom !== prevRect.bottom;
                newResult.changed = rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y;
              }
              return newResult;
            }
            applyToInteraction(arg) {
              const {
                interaction
              } = this;
              const {
                phase
              } = arg;
              const curCoords = interaction.coords.cur;
              const startCoords = interaction.coords.start;
              const {
                result,
                startDelta
              } = this;
              const curDelta = result.delta;
              if (phase === "start") {
                extend2(this.startDelta, result.delta);
              }
              for (const [coordsSet, delta] of [[startCoords, startDelta], [curCoords, curDelta]]) {
                coordsSet.page.x += delta.x;
                coordsSet.page.y += delta.y;
                coordsSet.client.x += delta.x;
                coordsSet.client.y += delta.y;
              }
              const {
                rectDelta
              } = this.result;
              const rect = arg.rect || interaction.rect;
              rect.left += rectDelta.left;
              rect.right += rectDelta.right;
              rect.top += rectDelta.top;
              rect.bottom += rectDelta.bottom;
              rect.width = rect.right - rect.left;
              rect.height = rect.bottom - rect.top;
            }
            setAndApply(arg) {
              const {
                interaction
              } = this;
              const {
                phase,
                preEnd,
                skipModifiers
              } = arg;
              const result = this.setAll(this.fillArg({
                preEnd,
                phase,
                pageCoords: arg.modifiedCoords || interaction.coords.cur.page
              }));
              this.result = result;
              if (!result.changed && (!skipModifiers || skipModifiers < this.states.length) && interaction.interacting()) {
                return false;
              }
              if (arg.modifiedCoords) {
                const {
                  page
                } = interaction.coords.cur;
                const adjustment = {
                  x: arg.modifiedCoords.x - page.x,
                  y: arg.modifiedCoords.y - page.y
                };
                result.coords.x += adjustment.x;
                result.coords.y += adjustment.y;
                result.delta.x += adjustment.x;
                result.delta.y += adjustment.y;
              }
              this.applyToInteraction(arg);
            }
            beforeEnd(arg) {
              const {
                interaction,
                event
              } = arg;
              const states = this.states;
              if (!states || !states.length) {
                return;
              }
              let doPreend = false;
              for (const state of states) {
                arg.state = state;
                const {
                  options,
                  methods
                } = state;
                const endPosition = methods.beforeEnd && methods.beforeEnd(arg);
                if (endPosition) {
                  this.endResult = endPosition;
                  return false;
                }
                doPreend = doPreend || !doPreend && this.shouldDo(options, true, arg.phase, true);
              }
              if (doPreend) {
                interaction.move({
                  event,
                  preEnd: true
                });
              }
            }
            stop(arg) {
              const {
                interaction
              } = arg;
              if (!this.states || !this.states.length) {
                return;
              }
              const modifierArg = extend2({
                states: this.states,
                interactable: interaction.interactable,
                element: interaction.element,
                rect: null
              }, arg);
              this.fillArg(modifierArg);
              for (const state of this.states) {
                modifierArg.state = state;
                if (state.methods.stop) {
                  state.methods.stop(modifierArg);
                }
              }
              this.states = null;
              this.endResult = null;
            }
            prepareStates(modifierList) {
              this.states = [];
              for (let index = 0; index < modifierList.length; index++) {
                const {
                  options,
                  methods,
                  name
                } = modifierList[index];
                this.states.push({
                  options,
                  methods,
                  index,
                  name
                });
              }
              return this.states;
            }
            restoreInteractionCoords({
              interaction: {
                coords,
                rect,
                modification
              }
            }) {
              if (!modification.result) return;
              const {
                startDelta
              } = modification;
              const {
                delta: curDelta,
                rectDelta
              } = modification.result;
              const coordsAndDeltas = [[coords.start, startDelta], [coords.cur, curDelta]];
              for (const [coordsSet, delta] of coordsAndDeltas) {
                coordsSet.page.x -= delta.x;
                coordsSet.page.y -= delta.y;
                coordsSet.client.x -= delta.x;
                coordsSet.client.y -= delta.y;
              }
              rect.left -= rectDelta.left;
              rect.right -= rectDelta.right;
              rect.top -= rectDelta.top;
              rect.bottom -= rectDelta.bottom;
            }
            shouldDo(options, preEnd, phase, requireEndOnly) {
              if (
                // ignore disabled modifiers
                !options || options.enabled === false || // check if we require endOnly option to fire move before end
                requireEndOnly && !options.endOnly || // don't apply endOnly modifiers when not ending
                options.endOnly && !preEnd || // check if modifier should run be applied on start
                phase === "start" && !options.setStart
              ) {
                return false;
              }
              return true;
            }
            copyFrom(other) {
              this.startOffset = other.startOffset;
              this.startDelta = other.startDelta;
              this.edges = other.edges;
              this.states = other.states.map((s) => clone(s));
              this.result = createResult(extend2({}, other.result.coords), extend2({}, other.result.rect));
            }
            destroy() {
              for (const prop in this) {
                this[prop] = null;
              }
            }
          }
          function createResult(coords, rect) {
            return {
              rect,
              coords,
              delta: {
                x: 0,
                y: 0
              },
              rectDelta: {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
              },
              eventProps: [],
              changed: true
            };
          }
          function getModifierList(interaction) {
            const actionOptions = interaction.interactable.options[interaction.prepared.name];
            const actionModifiers = actionOptions.modifiers;
            if (actionModifiers && actionModifiers.length) {
              return actionModifiers;
            }
            return ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map((type) => {
              const options = actionOptions[type];
              return options && options.enabled && {
                options,
                methods: options._methods
              };
            }).filter((m) => !!m);
          }
          function getRectOffset(rect, coords) {
            return rect ? {
              left: coords.x - rect.left,
              top: coords.y - rect.top,
              right: rect.right - coords.x,
              bottom: rect.bottom - coords.y
            } : {
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
            };
          }
          function makeModifier(module3, name) {
            const {
              defaults
            } = module3;
            const methods = {
              start: module3.start,
              set: module3.set,
              beforeEnd: module3.beforeEnd,
              stop: module3.stop
            };
            const modifier = (_options) => {
              const options = _options || {};
              options.enabled = options.enabled !== false;
              for (const prop in defaults) {
                if (!(prop in options)) {
                  ;
                  options[prop] = defaults[prop];
                }
              }
              const m = {
                options,
                methods,
                name,
                enable: () => {
                  options.enabled = true;
                  return m;
                },
                disable: () => {
                  options.enabled = false;
                  return m;
                }
              };
              return m;
            };
            if (name && typeof name === "string") {
              modifier._defaults = defaults;
              modifier._methods = methods;
            }
            return modifier;
          }
          function addEventModifiers({
            iEvent,
            interaction
          }) {
            const result = interaction.modification.result;
            if (result) {
              iEvent.modifiers = result.eventProps;
            }
          }
          const modifiersBase = {
            id: "modifiers/base",
            before: ["actions"],
            install: (scope) => {
              scope.defaults.perAction.modifiers = [];
            },
            listeners: {
              "interactions:new": ({
                interaction
              }) => {
                interaction.modification = new Modification_Modification(interaction);
              },
              "interactions:before-action-start": (arg) => {
                const modification = arg.interaction.modification;
                modification.start(arg, arg.interaction.coords.start.page);
                arg.interaction.edges = modification.edges;
                modification.applyToInteraction(arg);
              },
              "interactions:before-action-move": (arg) => arg.interaction.modification.setAndApply(arg),
              "interactions:before-action-end": (arg) => arg.interaction.modification.beforeEnd(arg),
              "interactions:action-start": addEventModifiers,
              "interactions:action-move": addEventModifiers,
              "interactions:action-end": addEventModifiers,
              "interactions:after-action-start": (arg) => arg.interaction.modification.restoreInteractionCoords(arg),
              "interactions:after-action-move": (arg) => arg.interaction.modification.restoreInteractionCoords(arg),
              "interactions:stop": (arg) => arg.interaction.modification.stop(arg)
            }
          };
          var modifiers_base = modifiersBase;
          const aspectRatio = {
            start(arg) {
              const {
                state,
                rect,
                edges: originalEdges,
                pageCoords: coords
              } = arg;
              let {
                ratio
              } = state.options;
              const {
                equalDelta,
                modifiers
              } = state.options;
              if (ratio === "preserve") {
                ratio = rect.width / rect.height;
              }
              state.startCoords = extend2({}, coords);
              state.startRect = extend2({}, rect);
              state.ratio = ratio;
              state.equalDelta = equalDelta;
              const linkedEdges = state.linkedEdges = {
                top: originalEdges.top || originalEdges.left && !originalEdges.bottom,
                left: originalEdges.left || originalEdges.top && !originalEdges.right,
                bottom: originalEdges.bottom || originalEdges.right && !originalEdges.top,
                right: originalEdges.right || originalEdges.bottom && !originalEdges.left
              };
              state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right);
              if (state.equalDelta) {
                state.edgeSign = (linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1);
              } else {
                const negativeSecondaryEdge = state.xIsPrimaryAxis ? linkedEdges.top : linkedEdges.left;
                state.edgeSign = negativeSecondaryEdge ? -1 : 1;
              }
              extend2(arg.edges, linkedEdges);
              if (!modifiers || !modifiers.length) return;
              const subModification = new Modification_Modification(arg.interaction);
              subModification.copyFrom(arg.interaction.modification);
              subModification.prepareStates(modifiers);
              state.subModification = subModification;
              subModification.startAll({
                ...arg
              });
            },
            set(arg) {
              const {
                state,
                rect,
                coords
              } = arg;
              const initialCoords = extend2({}, coords);
              const aspectMethod = state.equalDelta ? setEqualDelta : setRatio;
              aspectMethod(state, state.xIsPrimaryAxis, coords, rect);
              if (!state.subModification) {
                return null;
              }
              const correctedRect = extend2({}, rect);
              addEdges(state.linkedEdges, correctedRect, {
                x: coords.x - initialCoords.x,
                y: coords.y - initialCoords.y
              });
              const result = state.subModification.setAll({
                ...arg,
                rect: correctedRect,
                edges: state.linkedEdges,
                pageCoords: coords,
                prevCoords: coords,
                prevRect: correctedRect
              });
              const {
                delta
              } = result;
              if (result.changed) {
                const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y);
                aspectMethod(state, xIsCriticalAxis, result.coords, result.rect);
                extend2(coords, result.coords);
              }
              return result.eventProps;
            },
            defaults: {
              ratio: "preserve",
              equalDelta: false,
              modifiers: [],
              enabled: false
            }
          };
          function setEqualDelta({
            startCoords,
            edgeSign
          }, xIsPrimaryAxis, coords) {
            if (xIsPrimaryAxis) {
              coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign;
            } else {
              coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign;
            }
          }
          function setRatio({
            startRect,
            startCoords,
            ratio,
            edgeSign
          }, xIsPrimaryAxis, coords, rect) {
            if (xIsPrimaryAxis) {
              const newHeight = rect.width / ratio;
              coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign;
            } else {
              const newWidth = rect.height * ratio;
              coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign;
            }
          }
          var modifiers_aspectRatio = makeModifier(aspectRatio, "aspectRatio");
          const noop = () => {
          };
          noop._defaults = {};
          var modifiers_noop = noop;
          function pointer_start({
            rect,
            startOffset,
            state,
            interaction,
            pageCoords
          }) {
            const {
              options
            } = state;
            const {
              elementRect
            } = options;
            const offset = extend2({
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
            }, options.offset || {});
            if (rect && elementRect) {
              const restriction = getRestrictionRect(options.restriction, interaction, pageCoords);
              if (restriction) {
                const widthDiff = restriction.right - restriction.left - rect.width;
                const heightDiff = restriction.bottom - restriction.top - rect.height;
                if (widthDiff < 0) {
                  offset.left += widthDiff;
                  offset.right += widthDiff;
                }
                if (heightDiff < 0) {
                  offset.top += heightDiff;
                  offset.bottom += heightDiff;
                }
              }
              offset.left += startOffset.left - rect.width * elementRect.left;
              offset.top += startOffset.top - rect.height * elementRect.top;
              offset.right += startOffset.right - rect.width * (1 - elementRect.right);
              offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom);
            }
            state.offset = offset;
          }
          function set({
            coords,
            interaction,
            state
          }) {
            const {
              options,
              offset
            } = state;
            const restriction = getRestrictionRect(options.restriction, interaction, coords);
            if (!restriction) return;
            const rect = xywhToTlbr(restriction);
            coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left);
            coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top);
          }
          function getRestrictionRect(value, interaction, coords) {
            if (is.func(value)) {
              return resolveRectLike(value, interaction.interactable, interaction.element, [coords.x, coords.y, interaction]);
            } else {
              return resolveRectLike(value, interaction.interactable, interaction.element);
            }
          }
          const pointer_defaults = {
            restriction: null,
            elementRect: null,
            offset: null,
            endOnly: false,
            enabled: false
          };
          const restrict = {
            start: pointer_start,
            set,
            defaults: pointer_defaults
          };
          var restrict_pointer = makeModifier(restrict, "restrict");
          const noInner = {
            top: Infinity,
            left: Infinity,
            bottom: -Infinity,
            right: -Infinity
          };
          const noOuter = {
            top: -Infinity,
            left: -Infinity,
            bottom: Infinity,
            right: Infinity
          };
          function edges_start({
            interaction,
            startOffset,
            state
          }) {
            const {
              options
            } = state;
            let offset;
            if (options) {
              const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page);
              offset = rectToXY(offsetRect);
            }
            offset = offset || {
              x: 0,
              y: 0
            };
            state.offset = {
              top: offset.y + startOffset.top,
              left: offset.x + startOffset.left,
              bottom: offset.y - startOffset.bottom,
              right: offset.x - startOffset.right
            };
          }
          function edges_set({
            coords,
            edges,
            interaction,
            state
          }) {
            const {
              offset,
              options
            } = state;
            if (!edges) {
              return;
            }
            const page = extend2({}, coords);
            const inner = getRestrictionRect(options.inner, interaction, page) || {};
            const outer = getRestrictionRect(options.outer, interaction, page) || {};
            fixRect(inner, noInner);
            fixRect(outer, noOuter);
            if (edges.top) {
              coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top);
            } else if (edges.bottom) {
              coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom);
            }
            if (edges.left) {
              coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left);
            } else if (edges.right) {
              coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right);
            }
          }
          function fixRect(rect, defaults) {
            for (const edge of ["top", "left", "bottom", "right"]) {
              if (!(edge in rect)) {
                rect[edge] = defaults[edge];
              }
            }
            return rect;
          }
          const edges_defaults = {
            inner: null,
            outer: null,
            offset: null,
            endOnly: false,
            enabled: false
          };
          const restrictEdges = {
            noInner,
            noOuter,
            start: edges_start,
            set: edges_set,
            defaults: edges_defaults
          };
          var restrict_edges = makeModifier(restrictEdges, "restrictEdges");
          const rect_defaults = extend2({
            get elementRect() {
              return {
                top: 0,
                left: 0,
                bottom: 1,
                right: 1
              };
            },
            set elementRect(_) {
            }
          }, restrict.defaults);
          const restrictRect = {
            start: restrict.start,
            set: restrict.set,
            defaults: rect_defaults
          };
          var restrict_rect = makeModifier(restrictRect, "restrictRect");
          const noMin = {
            width: -Infinity,
            height: -Infinity
          };
          const noMax = {
            width: Infinity,
            height: Infinity
          };
          function size_start(arg) {
            return restrictEdges.start(arg);
          }
          function size_set(arg) {
            const {
              interaction,
              state,
              rect,
              edges
            } = arg;
            const {
              options
            } = state;
            if (!edges) {
              return;
            }
            const minSize = tlbrToXywh(getRestrictionRect(options.min, interaction, arg.coords)) || noMin;
            const maxSize = tlbrToXywh(getRestrictionRect(options.max, interaction, arg.coords)) || noMax;
            state.options = {
              endOnly: options.endOnly,
              inner: extend2({}, restrictEdges.noInner),
              outer: extend2({}, restrictEdges.noOuter)
            };
            if (edges.top) {
              state.options.inner.top = rect.bottom - minSize.height;
              state.options.outer.top = rect.bottom - maxSize.height;
            } else if (edges.bottom) {
              state.options.inner.bottom = rect.top + minSize.height;
              state.options.outer.bottom = rect.top + maxSize.height;
            }
            if (edges.left) {
              state.options.inner.left = rect.right - minSize.width;
              state.options.outer.left = rect.right - maxSize.width;
            } else if (edges.right) {
              state.options.inner.right = rect.left + minSize.width;
              state.options.outer.right = rect.left + maxSize.width;
            }
            restrictEdges.set(arg);
            state.options = options;
          }
          const size_defaults = {
            min: null,
            max: null,
            endOnly: false,
            enabled: false
          };
          const restrictSize = {
            start: size_start,
            set: size_set,
            defaults: size_defaults
          };
          var size = makeModifier(restrictSize, "restrictSize");
          function snap_pointer_start(arg) {
            const {
              interaction,
              interactable,
              element,
              rect,
              state,
              startOffset
            } = arg;
            const {
              options
            } = state;
            const origin = options.offsetWithOrigin ? getOrigin(arg) : {
              x: 0,
              y: 0
            };
            let snapOffset;
            if (options.offset === "startCoords") {
              snapOffset = {
                x: interaction.coords.start.page.x,
                y: interaction.coords.start.page.y
              };
            } else {
              const offsetRect = resolveRectLike(options.offset, interactable, element, [interaction]);
              snapOffset = rectToXY(offsetRect) || {
                x: 0,
                y: 0
              };
              snapOffset.x += origin.x;
              snapOffset.y += origin.y;
            }
            const {
              relativePoints
            } = options;
            state.offsets = rect && relativePoints && relativePoints.length ? relativePoints.map((relativePoint, index) => ({
              index,
              relativePoint,
              x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,
              y: startOffset.top - rect.height * relativePoint.y + snapOffset.y
            })) : [{
              index: 0,
              relativePoint: null,
              x: snapOffset.x,
              y: snapOffset.y
            }];
          }
          function pointer_set(arg) {
            const {
              interaction,
              coords,
              state
            } = arg;
            const {
              options,
              offsets
            } = state;
            const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name);
            const page = extend2({}, coords);
            const targets = [];
            if (!options.offsetWithOrigin) {
              page.x -= origin.x;
              page.y -= origin.y;
            }
            for (const offset of offsets) {
              const relativeX = page.x - offset.x;
              const relativeY = page.y - offset.y;
              for (let index = 0, len = options.targets.length; index < len; index++) {
                const snapTarget = options.targets[index];
                let target;
                if (is.func(snapTarget)) {
                  target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index);
                } else {
                  target = snapTarget;
                }
                if (!target) {
                  continue;
                }
                targets.push({
                  x: (is.number(target.x) ? target.x : relativeX) + offset.x,
                  y: (is.number(target.y) ? target.y : relativeY) + offset.y,
                  range: is.number(target.range) ? target.range : options.range,
                  source: snapTarget,
                  index,
                  offset
                });
              }
            }
            const closest = {
              target: null,
              inRange: false,
              distance: 0,
              range: 0,
              delta: {
                x: 0,
                y: 0
              }
            };
            for (const target of targets) {
              const range = target.range;
              const dx = target.x - page.x;
              const dy = target.y - page.y;
              const distance = hypot(dx, dy);
              let inRange = distance <= range;
              if (range === Infinity && closest.inRange && closest.range !== Infinity) {
                inRange = false;
              }
              if (!closest.target || (inRange ? (
                // is the closest target in range?
                closest.inRange && range !== Infinity ? (
                  // the pointer is relatively deeper in this target
                  distance / range < closest.distance / closest.range
                ) : (
                  // this target has Infinite range and the closest doesn't
                  range === Infinity && closest.range !== Infinity || // OR this target is closer that the previous closest
                  distance < closest.distance
                )
              ) : (
                // The other is not in range and the pointer is closer to this target
                !closest.inRange && distance < closest.distance
              ))) {
                closest.target = target;
                closest.distance = distance;
                closest.range = range;
                closest.inRange = inRange;
                closest.delta.x = dx;
                closest.delta.y = dy;
              }
            }
            if (closest.inRange) {
              coords.x = closest.target.x;
              coords.y = closest.target.y;
            }
            state.closest = closest;
            return closest;
          }
          function getOrigin(arg) {
            const {
              element
            } = arg.interaction;
            const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin, null, null, [element]));
            const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name);
            return origin;
          }
          const snap_pointer_defaults = {
            range: Infinity,
            targets: null,
            offset: null,
            offsetWithOrigin: true,
            origin: null,
            relativePoints: null,
            endOnly: false,
            enabled: false
          };
          const snap = {
            start: snap_pointer_start,
            set: pointer_set,
            defaults: snap_pointer_defaults
          };
          var snap_pointer = makeModifier(snap, "snap");
          function snap_size_start(arg) {
            const {
              state,
              edges
            } = arg;
            const {
              options
            } = state;
            if (!edges) {
              return null;
            }
            arg.state = {
              options: {
                targets: null,
                relativePoints: [{
                  x: edges.left ? 0 : 1,
                  y: edges.top ? 0 : 1
                }],
                offset: options.offset || "self",
                origin: {
                  x: 0,
                  y: 0
                },
                range: options.range
              }
            };
            state.targetFields = state.targetFields || [["width", "height"], ["x", "y"]];
            snap.start(arg);
            state.offsets = arg.state.offsets;
            arg.state = state;
          }
          function snap_size_set(arg) {
            const {
              interaction,
              state,
              coords
            } = arg;
            const {
              options,
              offsets
            } = state;
            const relative = {
              x: coords.x - offsets[0].x,
              y: coords.y - offsets[0].y
            };
            state.options = extend2({}, options);
            state.options.targets = [];
            for (const snapTarget of options.targets || []) {
              let target;
              if (is.func(snapTarget)) {
                target = snapTarget(relative.x, relative.y, interaction);
              } else {
                target = snapTarget;
              }
              if (!target) {
                continue;
              }
              for (const [xField, yField] of state.targetFields) {
                if (xField in target || yField in target) {
                  target.x = target[xField];
                  target.y = target[yField];
                  break;
                }
              }
              state.options.targets.push(target);
            }
            const returnValue = snap.set(arg);
            state.options = options;
            return returnValue;
          }
          const snap_size_defaults = {
            range: Infinity,
            targets: null,
            offset: null,
            endOnly: false,
            enabled: false
          };
          const snapSize = {
            start: snap_size_start,
            set: snap_size_set,
            defaults: snap_size_defaults
          };
          var snap_size = makeModifier(snapSize, "snapSize");
          function snap_edges_start(arg) {
            const {
              edges
            } = arg;
            if (!edges) {
              return null;
            }
            arg.state.targetFields = arg.state.targetFields || [[edges.left ? "left" : "right", edges.top ? "top" : "bottom"]];
            return snapSize.start(arg);
          }
          const snapEdges = {
            start: snap_edges_start,
            set: snapSize.set,
            defaults: extend2(clone(snapSize.defaults), {
              targets: null,
              range: null,
              offset: {
                x: 0,
                y: 0
              }
            })
          };
          var snap_edges = makeModifier(snapEdges, "snapEdges");
          var modifiers_all = {
            aspectRatio: modifiers_aspectRatio,
            restrictEdges: restrict_edges,
            restrict: restrict_pointer,
            restrictRect: restrict_rect,
            restrictSize: size,
            snapEdges: snap_edges,
            snap: snap_pointer,
            snapSize: snap_size,
            spring: modifiers_noop,
            avoid: modifiers_noop,
            transform: modifiers_noop,
            rubberband: modifiers_noop
          };
          const plugin_modifiers = {
            id: "modifiers",
            install(scope) {
              const {
                interactStatic: interact
              } = scope;
              scope.usePlugin(modifiers_base);
              scope.usePlugin(snappers_plugin);
              interact.modifiers = modifiers_all;
              for (const type in modifiers_all) {
                const {
                  _defaults,
                  _methods
                } = modifiers_all[type];
                _defaults._methods = _methods;
                scope.defaults.perAction[type] = _defaults;
              }
            }
          };
          var modifiers_plugin = plugin_modifiers;
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(modifiers_plugin);
          var CheckName;
          (function(CheckName2) {
            CheckName2["touchAction"] = "touchAction";
            CheckName2["boxSizing"] = "boxSizing";
            CheckName2["noListeners"] = "noListeners";
          })(CheckName || (CheckName = {}));
          const prefix = "[interact.js] ";
          const links = {
            touchAction: "https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action",
            boxSizing: "https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing"
          };
          const isProduction = false;
          function dev_tools_plugin_install(scope, {
            logger
          } = {}) {
            const {
              Interactable,
              defaults
            } = scope;
            scope.logger = logger || console;
            defaults.base.devTools = {
              ignore: {}
            };
            Interactable.prototype.devTools = function(options) {
              if (options) {
                extend2(this.options.devTools, options);
                return this;
              }
              return this.options.devTools;
            };
          }
          const checks = [{
            name: CheckName.touchAction,
            perform({
              element
            }) {
              return !parentHasStyle(element, "touchAction", /pan-|pinch|none/);
            },
            getInfo({
              element
            }) {
              return [element, links.touchAction];
            },
            text: 'Consider adding CSS "touch-action: none" to this element\n'
          }, {
            name: CheckName.boxSizing,
            perform(interaction) {
              const {
                element
              } = interaction;
              return interaction.prepared.name === "resize" && element instanceof utils_domObjects.HTMLElement && !hasStyle(element, "boxSizing", /border-box/);
            },
            text: 'Consider adding CSS "box-sizing: border-box" to this resizable element',
            getInfo({
              element
            }) {
              return [element, links.boxSizing];
            }
          }, {
            name: CheckName.noListeners,
            perform(interaction) {
              const actionName = interaction.prepared.name;
              const moveListeners = interaction.interactable.events.types[`${actionName}move`] || [];
              return !moveListeners.length;
            },
            getInfo(interaction) {
              return [interaction.prepared.name, interaction.interactable];
            },
            text: "There are no listeners set for this action"
          }];
          function hasStyle(element, prop, styleRe) {
            const value = element.style[prop] || win.getComputedStyle(element)[prop];
            return styleRe.test((value || "").toString());
          }
          function parentHasStyle(element, prop, styleRe) {
            let parent = element;
            while (is.element(parent)) {
              if (hasStyle(parent, prop, styleRe)) {
                return true;
              }
              parent = parentNode(parent);
            }
            return false;
          }
          const plugin_id = "dev-tools";
          const defaultExport = isProduction ? {
            id: plugin_id,
            install: () => {
            }
          } : {
            id: plugin_id,
            install: dev_tools_plugin_install,
            listeners: {
              "interactions:action-start": ({
                interaction
              }, scope) => {
                for (const check of checks) {
                  const options = interaction.interactable && interaction.interactable.options;
                  if (!(options && options.devTools && options.devTools.ignore[check.name]) && check.perform(interaction)) {
                    scope.logger.warn(prefix + check.text, ...check.getInfo(interaction));
                  }
                }
              }
            },
            checks,
            CheckName,
            links,
            prefix
          };
          var dev_tools_plugin = defaultExport;
          if (typeof window === "object" && !!window) {
            interact_init(window);
          }
          _interactjs_interact.use(dev_tools_plugin);
          var GridItemvue_type_script_lang_js = {
            name: "GridItem",
            props: {
              /*cols: {
               type: Number,
               required: true
               },*/
              /*containerWidth: {
               type: Number,
               required: true
                 },
               rowHeight: {
               type: Number,
               required: true
               },
               margin: {
               type: Array,
               required: true
               },
               maxRows: {
               type: Number,
               required: true
               },*/
              isDraggable: {
                type: Boolean,
                required: false,
                default: null
              },
              isResizable: {
                type: Boolean,
                required: false,
                default: null
              },
              /*useCssTransforms: {
               type: Boolean,
               required: true
               },
               */
              static: {
                type: Boolean,
                required: false,
                default: false
              },
              minH: {
                type: Number,
                required: false,
                default: 1
              },
              minW: {
                type: Number,
                required: false,
                default: 1
              },
              maxH: {
                type: Number,
                required: false,
                default: Infinity
              },
              maxW: {
                type: Number,
                required: false,
                default: Infinity
              },
              x: {
                type: Number,
                required: true
              },
              y: {
                type: Number,
                required: true
              },
              w: {
                type: Number,
                required: true
              },
              h: {
                type: Number,
                required: true
              },
              i: {
                required: true
              },
              dragIgnoreFrom: {
                type: String,
                required: false,
                default: "a, button"
              },
              dragAllowFrom: {
                type: String,
                required: false,
                default: null
              },
              resizeIgnoreFrom: {
                type: String,
                required: false,
                default: "a, button"
              },
              preserveAspectRatio: {
                type: Boolean,
                required: false,
                default: false
              }
            },
            emits: ["resize", "resized", "resizeEvent", "move", "moved", "dragEvent", "container-resized"],
            inject: ["layout"],
            data: function data() {
              return {
                cols: 1,
                containerWidth: 100,
                rowHeight: 30,
                margin: [10, 10],
                maxRows: Infinity,
                draggable: null,
                resizable: null,
                useCssTransforms: true,
                useStyleCursor: true,
                isDragging: false,
                dragging: null,
                isResizing: false,
                resizing: null,
                lastX: NaN,
                lastY: NaN,
                lastW: NaN,
                lastH: NaN,
                style: {},
                rtl: false,
                dragEventSet: false,
                resizeEventSet: false,
                previousW: null,
                previousH: null,
                previousX: null,
                previousY: null,
                innerX: this.x,
                innerY: this.y,
                innerW: this.w,
                innerH: this.h
              };
            },
            created: function created() {
              var _this = this;
              var self2 = this;
              self2.updateWidthHandler = function(width) {
                self2.updateWidth(width[0]);
              };
              self2.compactHandler = function(layout) {
                self2.compact(layout[0]);
              };
              self2.setDraggableHandler = function(isDraggable) {
                if (self2.isDraggable === null) {
                  self2.draggable = isDraggable[0];
                }
              };
              self2.setResizableHandler = function(isResizable) {
                if (self2.isResizable === null) {
                  self2.resizable = isResizable[0];
                }
              };
              self2.setRowHeightHandler = function(rowHeight) {
                self2.rowHeight = rowHeight[0];
              };
              self2.setMaxRowsHandler = function(maxRows) {
                self2.maxRows = maxRows[0];
              };
              self2.directionchangeHandler = function() {
                _this.rtl = Object(DOM[
                  "b"
                  /* getDocumentDir */
                ])() === "rtl";
                _this.compact();
              };
              self2.setColNum = function(colNum) {
                self2.cols = parseInt(colNum[0]);
              };
              mitt[
                "a"
                /* default */
              ].$on("updateWidth", self2.updateWidthHandler);
              mitt[
                "a"
                /* default */
              ].$on("compact", self2.compactHandler);
              mitt[
                "a"
                /* default */
              ].$on("setDraggable", self2.setDraggableHandler);
              mitt[
                "a"
                /* default */
              ].$on("setResizable", self2.setResizableHandler);
              mitt[
                "a"
                /* default */
              ].$on("setRowHeight", self2.setRowHeightHandler);
              mitt[
                "a"
                /* default */
              ].$on("setMaxRows", self2.setMaxRowsHandler);
              mitt[
                "a"
                /* default */
              ].$on("directionchange", self2.directionchangeHandler);
              mitt[
                "a"
                /* default */
              ].$on("setColNum", self2.setColNum);
              this.rtl = Object(DOM[
                "b"
                /* getDocumentDir */
              ])() === "rtl";
            },
            beforeUnmount: function beforeUnmount() {
              var self2 = this;
              mitt[
                "a"
                /* default */
              ].$off("updateWidth", self2.updateWidthHandler);
              mitt[
                "a"
                /* default */
              ].$off("compact", self2.compactHandler);
              mitt[
                "a"
                /* default */
              ].$off("setDraggable", self2.setDraggableHandler);
              mitt[
                "a"
                /* default */
              ].$off("setResizable", self2.setResizableHandler);
              mitt[
                "a"
                /* default */
              ].$off("setRowHeight", self2.setRowHeightHandler);
              mitt[
                "a"
                /* default */
              ].$off("setMaxRows", self2.setMaxRowsHandler);
              mitt[
                "a"
                /* default */
              ].$off("directionchange", self2.directionchangeHandler);
              mitt[
                "a"
                /* default */
              ].$off("setColNum", self2.setColNum);
              if (this.interactObj) {
                this.interactObj.unset();
              }
            },
            mounted: function mounted() {
              if (this.layout.responsive && this.layout.lastBreakpoint) {
                this.cols = Object(responsiveUtils[
                  "c"
                  /* getColsFromBreakpoint */
                ])(this.layout.lastBreakpoint, this.layout.cols);
              } else {
                this.cols = this.layout.colNum;
              }
              this.rowHeight = this.layout.rowHeight;
              this.containerWidth = this.layout.width !== null ? this.layout.width : 100;
              this.margin = this.layout.margin !== void 0 ? this.layout.margin : [10, 10];
              this.maxRows = this.layout.maxRows;
              if (this.isDraggable === null) {
                this.draggable = this.layout.isDraggable;
              } else {
                this.draggable = this.isDraggable;
              }
              if (this.isResizable === null) {
                this.resizable = this.layout.isResizable;
              } else {
                this.resizable = this.isResizable;
              }
              this.useCssTransforms = this.layout.useCssTransforms;
              this.useStyleCursor = this.layout.useStyleCursor;
              this.createStyle();
            },
            watch: {
              isDraggable: function isDraggable() {
                this.draggable = this.isDraggable;
              },
              static: function _static() {
                this.tryMakeDraggable();
                this.tryMakeResizable();
              },
              draggable: function draggable() {
                this.tryMakeDraggable();
              },
              isResizable: function isResizable() {
                this.resizable = this.isResizable;
              },
              resizable: function resizable2() {
                this.tryMakeResizable();
              },
              rowHeight: function rowHeight() {
                this.createStyle();
                this.emitContainerResized();
              },
              cols: function cols() {
                this.tryMakeResizable();
                this.createStyle();
                this.emitContainerResized();
              },
              containerWidth: function containerWidth() {
                this.tryMakeResizable();
                this.createStyle();
                this.emitContainerResized();
              },
              x: function x(newVal) {
                this.innerX = newVal;
                this.createStyle();
              },
              y: function y(newVal) {
                this.innerY = newVal;
                this.createStyle();
              },
              h: function h(newVal) {
                this.innerH = newVal;
                this.createStyle();
              },
              w: function w(newVal) {
                this.innerW = newVal;
                this.createStyle();
              },
              renderRtl: function renderRtl() {
                this.tryMakeResizable();
                this.createStyle();
              },
              minH: function minH() {
                this.tryMakeResizable();
              },
              maxH: function maxH() {
                this.tryMakeResizable();
              },
              minW: function minW() {
                this.tryMakeResizable();
              },
              maxW: function maxW() {
                this.tryMakeResizable();
              },
              "$parent.margin": function $parentMargin(margin) {
                if (!margin || margin[0] == this.margin[0] && margin[1] == this.margin[1]) {
                  return;
                }
                this.margin = margin.map(function(m) {
                  return Number(m);
                });
                this.createStyle();
                this.emitContainerResized();
              }
            },
            computed: {
              classObj: function classObj() {
                return {
                  "vue-resizable": this.resizableAndNotStatic,
                  "static": this.static,
                  "resizing": this.isResizing,
                  "vue-draggable-dragging": this.isDragging,
                  "cssTransforms": this.useCssTransforms,
                  "render-rtl": this.renderRtl,
                  "disable-userselect": this.isDragging,
                  "no-touch": this.isAndroid && this.draggableOrResizableAndNotStatic
                };
              },
              resizableAndNotStatic: function resizableAndNotStatic() {
                return this.resizable && !this.static;
              },
              draggableOrResizableAndNotStatic: function draggableOrResizableAndNotStatic() {
                return (this.draggable || this.resizable) && !this.static;
              },
              isAndroid: function isAndroid() {
                return navigator.userAgent.toLowerCase().indexOf("android") !== -1;
              },
              renderRtl: function renderRtl() {
                return this.layout.isMirrored ? !this.rtl : this.rtl;
              },
              resizableHandleClass: function resizableHandleClass() {
                if (this.renderRtl) {
                  return "vue-resizable-handle vue-rtl-resizable-handle";
                } else {
                  return "vue-resizable-handle";
                }
              }
            },
            methods: {
              createStyle: function createStyle() {
                if (this.x + this.w > this.cols) {
                  this.innerX = 0;
                  this.innerW = this.w > this.cols ? this.cols : this.w;
                } else {
                  this.innerX = this.x;
                  this.innerW = this.w;
                }
                var pos = this.calcPosition(this.innerX, this.innerY, this.innerW, this.innerH);
                if (this.isDragging) {
                  pos.top = this.dragging.top;
                  if (this.renderRtl) {
                    pos.right = this.dragging.left;
                  } else {
                    pos.left = this.dragging.left;
                  }
                }
                if (this.isResizing) {
                  pos.width = this.resizing.width;
                  pos.height = this.resizing.height;
                }
                var style;
                if (this.useCssTransforms) {
                  if (this.renderRtl) {
                    style = Object(utils[
                      "k"
                      /* setTransformRtl */
                    ])(pos.top, pos.right, pos.width, pos.height);
                  } else {
                    style = Object(utils[
                      "j"
                      /* setTransform */
                    ])(pos.top, pos.left, pos.width, pos.height);
                  }
                } else {
                  if (this.renderRtl) {
                    style = Object(utils[
                      "i"
                      /* setTopRight */
                    ])(pos.top, pos.right, pos.width, pos.height);
                  } else {
                    style = Object(utils[
                      "h"
                      /* setTopLeft */
                    ])(pos.top, pos.left, pos.width, pos.height);
                  }
                }
                this.style = style;
              },
              emitContainerResized: function emitContainerResized() {
                var styleProps = {};
                for (var _i = 0, _arr = ["width", "height"]; _i < _arr.length; _i++) {
                  var prop = _arr[_i];
                  var val = this.style[prop];
                  var matches = val.match(/^(\d+)px$/);
                  if (!matches) return;
                  styleProps[prop] = matches[1];
                }
                this.$emit("container-resized", this.i, this.h, this.w, styleProps.height, styleProps.width);
              },
              handleResize: function handleResize(event) {
                if (this.static) return;
                var position = getControlPosition(event);
                if (position == null) return;
                var x = position.x, y = position.y;
                var newSize = {
                  width: 0,
                  height: 0
                };
                var pos;
                switch (event.type) {
                  case "resizestart": {
                    this.previousW = this.innerW;
                    this.previousH = this.innerH;
                    pos = this.calcPosition(this.innerX, this.innerY, this.innerW, this.innerH);
                    newSize.width = pos.width;
                    newSize.height = pos.height;
                    this.resizing = newSize;
                    this.isResizing = true;
                    break;
                  }
                  case "resizemove": {
                    var coreEvent = createCoreData(this.lastW, this.lastH, x, y);
                    if (this.renderRtl) {
                      newSize.width = this.resizing.width - coreEvent.deltaX;
                    } else {
                      newSize.width = this.resizing.width + coreEvent.deltaX;
                    }
                    newSize.height = this.resizing.height + coreEvent.deltaY;
                    this.resizing = newSize;
                    break;
                  }
                  case "resizeend": {
                    pos = this.calcPosition(this.innerX, this.innerY, this.innerW, this.innerH);
                    newSize.width = pos.width;
                    newSize.height = pos.height;
                    this.resizing = null;
                    this.isResizing = false;
                    break;
                  }
                }
                pos = this.calcWH(newSize.height, newSize.width);
                if (pos.w < this.minW) {
                  pos.w = this.minW;
                }
                if (pos.w > this.maxW) {
                  pos.w = this.maxW;
                }
                if (pos.h < this.minH) {
                  pos.h = this.minH;
                }
                if (pos.h > this.maxH) {
                  pos.h = this.maxH;
                }
                if (pos.h < 1) {
                  pos.h = 1;
                }
                if (pos.w < 1) {
                  pos.w = 1;
                }
                this.lastW = x;
                this.lastH = y;
                if (this.innerW !== pos.w || this.innerH !== pos.h) {
                  this.$emit("resize", this.i, pos.h, pos.w, newSize.height, newSize.width);
                }
                if (event.type === "resizeend" && (this.previousW !== this.innerW || this.previousH !== this.innerH)) {
                  this.$emit("resized", this.i, pos.h, pos.w, newSize.height, newSize.width);
                }
                mitt[
                  "a"
                  /* default */
                ].$emit("resizeEvent", event.type, this.i, this.innerX, this.innerY, pos.h, pos.w);
              },
              handleDrag: function handleDrag(event) {
                if (this.static) return;
                if (this.isResizing) return;
                var position = getControlPosition(event);
                if (position === null) return;
                var x = position.x, y = position.y;
                var newPosition = {
                  top: 0,
                  left: 0
                };
                switch (event.type) {
                  case "dragstart": {
                    this.previousX = this.innerX;
                    this.previousY = this.innerY;
                    var parentRect = event.target.offsetParent.getBoundingClientRect();
                    var clientRect = event.target.getBoundingClientRect();
                    if (this.renderRtl) {
                      newPosition.left = (clientRect.right - parentRect.right) * -1;
                    } else {
                      newPosition.left = clientRect.left - parentRect.left;
                    }
                    newPosition.top = clientRect.top - parentRect.top;
                    this.dragging = newPosition;
                    this.isDragging = true;
                    break;
                  }
                  case "dragend": {
                    if (!this.isDragging) return;
                    var _parentRect = event.target.offsetParent.getBoundingClientRect();
                    var _clientRect = event.target.getBoundingClientRect();
                    if (this.renderRtl) {
                      newPosition.left = (_clientRect.right - _parentRect.right) * -1;
                    } else {
                      newPosition.left = _clientRect.left - _parentRect.left;
                    }
                    newPosition.top = _clientRect.top - _parentRect.top;
                    this.dragging = null;
                    this.isDragging = false;
                    break;
                  }
                  case "dragmove": {
                    var coreEvent = createCoreData(this.lastX, this.lastY, x, y);
                    if (this.renderRtl) {
                      newPosition.left = this.dragging.left - coreEvent.deltaX;
                    } else {
                      newPosition.left = this.dragging.left + coreEvent.deltaX;
                    }
                    newPosition.top = this.dragging.top + coreEvent.deltaY;
                    this.dragging = newPosition;
                    break;
                  }
                }
                var pos;
                if (this.renderRtl) {
                  pos = this.calcXY(newPosition.top, newPosition.left);
                } else {
                  pos = this.calcXY(newPosition.top, newPosition.left);
                }
                this.lastX = x;
                this.lastY = y;
                if (this.innerX !== pos.x || this.innerY !== pos.y) {
                  this.$emit("move", this.i, pos.x, pos.y);
                }
                if (event.type === "dragend" && (this.previousX !== this.innerX || this.previousY !== this.innerY)) {
                  this.$emit("moved", this.i, pos.x, pos.y);
                }
                mitt[
                  "a"
                  /* default */
                ].$emit("dragEvent", event.type, this.i, pos.x, pos.y, this.innerH, this.innerW);
              },
              calcPosition: function calcPosition(x, y, w, h) {
                var colWidth = this.calcColWidth();
                var out;
                if (this.renderRtl) {
                  out = {
                    right: Math.round(colWidth * x + (x + 1) * this.margin[0]),
                    top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),
                    // 0 * Infinity === NaN, which causes problems with resize constriants;
                    // Fix this if it occurs.
                    // Note we do it here rather than later because Math.round(Infinity) causes deopt
                    width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),
                    height: h === Infinity ? h : Math.round(this.rowHeight * h + Math.max(0, h - 1) * this.margin[1])
                  };
                } else {
                  out = {
                    left: Math.round(colWidth * x + (x + 1) * this.margin[0]),
                    top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),
                    // 0 * Infinity === NaN, which causes problems with resize constriants;
                    // Fix this if it occurs.
                    // Note we do it here rather than later because Math.round(Infinity) causes deopt
                    width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),
                    height: h === Infinity ? h : Math.round(this.rowHeight * h + Math.max(0, h - 1) * this.margin[1])
                  };
                }
                return out;
              },
              /**
               * Translate x and y coordinates from pixels to grid units.
               * @param  {Number} top  Top position (relative to parent) in pixels.
               * @param  {Number} left Left position (relative to parent) in pixels.
               * @return {Object} x and y in grid units.
               */
              // TODO check if this function needs change in order to support rtl.
              calcXY: function calcXY(top, left) {
                var colWidth = this.calcColWidth();
                var x = Math.round((left - this.margin[0]) / (colWidth + this.margin[0]));
                var y = Math.round((top - this.margin[1]) / (this.rowHeight + this.margin[1]));
                x = Math.max(Math.min(x, this.cols - this.innerW), 0);
                y = Math.max(Math.min(y, this.maxRows - this.innerH), 0);
                return {
                  x,
                  y
                };
              },
              // Helper for generating column width
              calcColWidth: function calcColWidth() {
                var colWidth = (this.containerWidth - this.margin[0] * (this.cols + 1)) / this.cols;
                return colWidth;
              },
              /**
               * Given a height and width in pixel values, calculate grid units.
               * @param  {Number} height Height in pixels.
               * @param  {Number} width  Width in pixels.
               * @return {Object} w, h as grid units.
               */
              calcWH: function calcWH(height, width) {
                var colWidth = this.calcColWidth();
                var w = Math.round((width + this.margin[0]) / (colWidth + this.margin[0]));
                var h = Math.round((height + this.margin[1]) / (this.rowHeight + this.margin[1]));
                w = Math.max(Math.min(w, this.cols - this.innerX), 0);
                h = Math.max(Math.min(h, this.maxRows - this.innerY), 0);
                return {
                  w,
                  h
                };
              },
              updateWidth: function updateWidth(width, colNum) {
                this.containerWidth = width;
                if (colNum !== void 0 && colNum !== null) {
                  this.cols = colNum;
                }
              },
              compact: function compact() {
                this.createStyle();
              },
              tryMakeDraggable: function tryMakeDraggable() {
                var self2 = this;
                if (this.interactObj === null || this.interactObj === void 0) {
                  this.interactObj = _interactjs_interact(this.$refs.item);
                  if (!this.useStyleCursor) {
                    this.interactObj.styleCursor(false);
                  }
                }
                if (this.draggable && !this.static) {
                  var opts = {
                    ignoreFrom: this.dragIgnoreFrom,
                    allowFrom: this.dragAllowFrom
                  };
                  this.interactObj.draggable(opts);
                  if (!this.dragEventSet) {
                    this.dragEventSet = true;
                    this.interactObj.on("dragstart dragmove dragend", function(event) {
                      self2.handleDrag(event);
                    });
                  }
                } else {
                  this.interactObj.draggable({
                    enabled: false
                  });
                }
              },
              tryMakeResizable: function tryMakeResizable() {
                var self2 = this;
                if (this.interactObj === null || this.interactObj === void 0) {
                  this.interactObj = _interactjs_interact(this.$refs.item);
                  if (!this.useStyleCursor) {
                    this.interactObj.styleCursor(false);
                  }
                }
                if (this.resizable && !this.static) {
                  var maximum = this.calcPosition(0, 0, this.maxW, this.maxH);
                  var minimum = this.calcPosition(0, 0, this.minW, this.minH);
                  var opts = {
                    // allowFrom: "." + this.resizableHandleClass.trim().replace(" ", "."),
                    edges: {
                      left: false,
                      right: "." + this.resizableHandleClass.trim().replace(" ", "."),
                      bottom: "." + this.resizableHandleClass.trim().replace(" ", "."),
                      top: false
                    },
                    ignoreFrom: this.resizeIgnoreFrom,
                    restrictSize: {
                      min: {
                        height: minimum.height,
                        width: minimum.width
                      },
                      max: {
                        height: maximum.height,
                        width: maximum.width
                      }
                    }
                  };
                  if (this.preserveAspectRatio) {
                    opts.modifiers = [_interactjs_interact.modifiers.aspectRatio({
                      ratio: "preserve"
                    })];
                  }
                  this.interactObj.resizable(opts);
                  if (!this.resizeEventSet) {
                    this.resizeEventSet = true;
                    this.interactObj.on("resizestart resizemove resizeend", function(event) {
                      self2.handleResize(event);
                    });
                  }
                } else {
                  this.interactObj.resizable({
                    enabled: false
                  });
                }
              },
              autoSize: function autoSize() {
                this.previousW = this.innerW;
                this.previousH = this.innerH;
                var newSize = this.$refs.item.getBoundingClientRect();
                var pos = this.calcWH(newSize.height, newSize.width);
                if (pos.w < this.minW) {
                  pos.w = this.minW;
                }
                if (pos.w > this.maxW) {
                  pos.w = this.maxW;
                }
                if (pos.h < this.minH) {
                  pos.h = this.minH;
                }
                if (pos.h > this.maxH) {
                  pos.h = this.maxH;
                }
                if (pos.h < 1) {
                  pos.h = 1;
                }
                if (pos.w < 1) {
                  pos.w = 1;
                }
                if (this.innerW !== pos.w || this.innerH !== pos.h) {
                  this.$emit("resize", this.i, pos.h, pos.w, newSize.height, newSize.width);
                }
                if (this.previousW !== pos.w || this.previousH !== pos.h) {
                  this.$emit("resized", this.i, pos.h, pos.w, newSize.height, newSize.width);
                  mitt[
                    "a"
                    /* default */
                  ].$emit("resizeEvent", "resizeend", this.i, this.innerX, this.innerY, pos.h, pos.w);
                }
              }
            }
          };
          var GridItemvue_type_style_index_0_id_bf5dd244_lang_css = __webpack_require__("fdec");
          GridItemvue_type_script_lang_js.render = render;
          var GridItem = __webpack_exports__["a"] = GridItemvue_type_script_lang_js;
        }
      ),
      /***/
      "c04e": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("861d");
          module2.exports = function(input, PREFERRED_STRING) {
            if (!isObject2(input)) return input;
            var fn, val;
            if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input))) return val;
            if (typeof (fn = input.valueOf) == "function" && !isObject2(val = fn.call(input))) return val;
            if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input))) return val;
            throw TypeError("Can't convert object to primitive value");
          };
        }
      ),
      /***/
      "c274": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var utils = __webpack_require__("50bf");
          module2.exports = function batchProcessorMaker(options) {
            options = options || {};
            var reporter = options.reporter;
            var asyncProcess = utils.getOption(options, "async", true);
            var autoProcess = utils.getOption(options, "auto", true);
            if (autoProcess && !asyncProcess) {
              reporter && reporter.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true.");
              asyncProcess = true;
            }
            var batch = Batch();
            var asyncFrameHandler;
            var isProcessing = false;
            function addFunction(level, fn) {
              if (!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {
                processBatchAsync();
              }
              batch.add(level, fn);
            }
            function processBatch() {
              isProcessing = true;
              while (batch.size()) {
                var processingBatch = batch;
                batch = Batch();
                processingBatch.process();
              }
              isProcessing = false;
            }
            function forceProcessBatch(localAsyncProcess) {
              if (isProcessing) {
                return;
              }
              if (localAsyncProcess === void 0) {
                localAsyncProcess = asyncProcess;
              }
              if (asyncFrameHandler) {
                cancelFrame(asyncFrameHandler);
                asyncFrameHandler = null;
              }
              if (localAsyncProcess) {
                processBatchAsync();
              } else {
                processBatch();
              }
            }
            function processBatchAsync() {
              asyncFrameHandler = requestFrame(processBatch);
            }
            function clearBatch() {
              batch = {};
              batchSize = 0;
              topLevel = 0;
              bottomLevel = 0;
            }
            function cancelFrame(listener) {
              var cancel = clearTimeout;
              return cancel(listener);
            }
            function requestFrame(callback) {
              var raf = function(fn) {
                return setTimeout(fn, 0);
              };
              return raf(callback);
            }
            return {
              add: addFunction,
              force: forceProcessBatch
            };
          };
          function Batch() {
            var batch = {};
            var size = 0;
            var topLevel2 = 0;
            var bottomLevel2 = 0;
            function add(level, fn) {
              if (!fn) {
                fn = level;
                level = 0;
              }
              if (level > topLevel2) {
                topLevel2 = level;
              } else if (level < bottomLevel2) {
                bottomLevel2 = level;
              }
              if (!batch[level]) {
                batch[level] = [];
              }
              batch[level].push(fn);
              size++;
            }
            function process2() {
              for (var level = bottomLevel2; level <= topLevel2; level++) {
                var fns = batch[level];
                for (var i = 0; i < fns.length; i++) {
                  var fn = fns[i];
                  fn();
                }
              }
            }
            function getSize() {
              return size;
            }
            return {
              add,
              process: process2,
              size: getSize
            };
          }
        }
      ),
      /***/
      "c430": (
        /***/
        function(module2, exports2) {
          module2.exports = false;
        }
      ),
      /***/
      "c6b6": (
        /***/
        function(module2, exports2) {
          var toString = {}.toString;
          module2.exports = function(it) {
            return toString.call(it).slice(8, -1);
          };
        }
      ),
      /***/
      "c6cd": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var setGlobal = __webpack_require__("ce4e");
          var SHARED = "__core-js_shared__";
          var store = global[SHARED] || setGlobal(SHARED, {});
          module2.exports = store;
        }
      ),
      /***/
      "c8ba": (
        /***/
        function(module2, exports2) {
          var g;
          g = /* @__PURE__ */ function() {
            return this;
          }();
          try {
            g = g || new Function("return this")();
          } catch (e) {
            if (typeof window === "object") g = window;
          }
          module2.exports = g;
        }
      ),
      /***/
      "c8d2": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var fails = __webpack_require__("d039");
          var whitespaces = __webpack_require__("5899");
          var non = "";
          module2.exports = function(METHOD_NAME) {
            return fails(function() {
              return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
            });
          };
        }
      ),
      /***/
      "c946": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var forEach = __webpack_require__("b770").forEach;
          module2.exports = function(options) {
            options = options || {};
            var reporter = options.reporter;
            var batchProcessor = options.batchProcessor;
            var getState = options.stateHandler.getState;
            var hasState = options.stateHandler.hasState;
            var idHandler = options.idHandler;
            if (!batchProcessor) {
              throw new Error("Missing required dependency: batchProcessor");
            }
            if (!reporter) {
              throw new Error("Missing required dependency: reporter.");
            }
            var scrollbarSizes = getScrollbarSizes();
            var styleId = "erd_scroll_detection_scrollbar_style";
            var detectionContainerClass = "erd_scroll_detection_container";
            function initDocument(targetDocument) {
              injectScrollStyle(targetDocument, styleId, detectionContainerClass);
            }
            initDocument(window.document);
            function buildCssTextString(rules) {
              var seperator = options.important ? " !important; " : "; ";
              return (rules.join(seperator) + seperator).trim();
            }
            function getScrollbarSizes() {
              var width = 500;
              var height = 500;
              var child = document.createElement("div");
              child.style.cssText = buildCssTextString(["position: absolute", "width: " + width * 2 + "px", "height: " + height * 2 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
              var container = document.createElement("div");
              container.style.cssText = buildCssTextString(["position: absolute", "width: " + width + "px", "height: " + height + "px", "overflow: scroll", "visibility: none", "top: " + -width * 3 + "px", "left: " + -height * 3 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
              container.appendChild(child);
              document.body.insertBefore(container, document.body.firstChild);
              var widthSize = width - container.clientWidth;
              var heightSize = height - container.clientHeight;
              document.body.removeChild(container);
              return {
                width: widthSize,
                height: heightSize
              };
            }
            function injectScrollStyle(targetDocument, styleId2, containerClass) {
              function injectStyle(style2, method) {
                method = method || function(element) {
                  targetDocument.head.appendChild(element);
                };
                var styleElement = targetDocument.createElement("style");
                styleElement.innerHTML = style2;
                styleElement.id = styleId2;
                method(styleElement);
                return styleElement;
              }
              if (!targetDocument.getElementById(styleId2)) {
                var containerAnimationClass = containerClass + "_animation";
                var containerAnimationActiveClass = containerClass + "_animation_active";
                var style = "/* Created by the element-resize-detector library. */\n";
                style += "." + containerClass + " > div::-webkit-scrollbar { " + buildCssTextString(["display: none"]) + " }\n\n";
                style += "." + containerAnimationActiveClass + " { " + buildCssTextString(["-webkit-animation-duration: 0.1s", "animation-duration: 0.1s", "-webkit-animation-name: " + containerAnimationClass, "animation-name: " + containerAnimationClass]) + " }\n";
                style += "@-webkit-keyframes " + containerAnimationClass + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\n";
                style += "@keyframes " + containerAnimationClass + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }";
                injectStyle(style);
              }
            }
            function addAnimationClass(element) {
              element.className += " " + detectionContainerClass + "_animation_active";
            }
            function addEvent(el, name, cb) {
              if (el.addEventListener) {
                el.addEventListener(name, cb);
              } else if (el.attachEvent) {
                el.attachEvent("on" + name, cb);
              } else {
                return reporter.error("[scroll] Don't know how to add event listeners.");
              }
            }
            function removeEvent(el, name, cb) {
              if (el.removeEventListener) {
                el.removeEventListener(name, cb);
              } else if (el.detachEvent) {
                el.detachEvent("on" + name, cb);
              } else {
                return reporter.error("[scroll] Don't know how to remove event listeners.");
              }
            }
            function getExpandElement(element) {
              return getState(element).container.childNodes[0].childNodes[0].childNodes[0];
            }
            function getShrinkElement(element) {
              return getState(element).container.childNodes[0].childNodes[0].childNodes[1];
            }
            function addListener(element, listener) {
              var listeners = getState(element).listeners;
              if (!listeners.push) {
                throw new Error("Cannot add listener to an element that is not detectable.");
              }
              getState(element).listeners.push(listener);
            }
            function makeDetectable(options2, element, callback) {
              if (!callback) {
                callback = element;
                element = options2;
                options2 = null;
              }
              options2 = options2 || {};
              function debug() {
                if (options2.debug) {
                  var args = Array.prototype.slice.call(arguments);
                  args.unshift(idHandler.get(element), "Scroll: ");
                  if (reporter.log.apply) {
                    reporter.log.apply(null, args);
                  } else {
                    for (var i = 0; i < args.length; i++) {
                      reporter.log(args[i]);
                    }
                  }
                }
              }
              function isDetached(element2) {
                function isInDocument(element3) {
                  var isInShadowRoot = element3.getRootNode && element3.getRootNode().contains(element3);
                  return element3 === element3.ownerDocument.body || element3.ownerDocument.body.contains(element3) || isInShadowRoot;
                }
                if (!isInDocument(element2)) {
                  return true;
                }
                if (window.getComputedStyle(element2) === null) {
                  return true;
                }
                return false;
              }
              function isUnrendered(element2) {
                var container = getState(element2).container.childNodes[0];
                var style = window.getComputedStyle(container);
                return !style.width || style.width.indexOf("px") === -1;
              }
              function getStyle() {
                var elementStyle = window.getComputedStyle(element);
                var style = {};
                style.position = elementStyle.position;
                style.width = element.offsetWidth;
                style.height = element.offsetHeight;
                style.top = elementStyle.top;
                style.right = elementStyle.right;
                style.bottom = elementStyle.bottom;
                style.left = elementStyle.left;
                style.widthCSS = elementStyle.width;
                style.heightCSS = elementStyle.height;
                return style;
              }
              function storeStartSize() {
                var style = getStyle();
                getState(element).startSize = {
                  width: style.width,
                  height: style.height
                };
                debug("Element start size", getState(element).startSize);
              }
              function initListeners() {
                getState(element).listeners = [];
              }
              function storeStyle() {
                debug("storeStyle invoked.");
                if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
                }
                var style = getStyle();
                getState(element).style = style;
              }
              function storeCurrentSize(element2, width, height) {
                getState(element2).lastWidth = width;
                getState(element2).lastHeight = height;
              }
              function getExpandChildElement(element2) {
                return getExpandElement(element2).childNodes[0];
              }
              function getWidthOffset() {
                return 2 * scrollbarSizes.width + 1;
              }
              function getHeightOffset() {
                return 2 * scrollbarSizes.height + 1;
              }
              function getExpandWidth(width) {
                return width + 10 + getWidthOffset();
              }
              function getExpandHeight(height) {
                return height + 10 + getHeightOffset();
              }
              function getShrinkWidth(width) {
                return width * 2 + getWidthOffset();
              }
              function getShrinkHeight(height) {
                return height * 2 + getHeightOffset();
              }
              function positionScrollbars(element2, width, height) {
                var expand = getExpandElement(element2);
                var shrink = getShrinkElement(element2);
                var expandWidth = getExpandWidth(width);
                var expandHeight = getExpandHeight(height);
                var shrinkWidth = getShrinkWidth(width);
                var shrinkHeight = getShrinkHeight(height);
                expand.scrollLeft = expandWidth;
                expand.scrollTop = expandHeight;
                shrink.scrollLeft = shrinkWidth;
                shrink.scrollTop = shrinkHeight;
              }
              function injectContainerElement() {
                var container = getState(element).container;
                if (!container) {
                  container = document.createElement("div");
                  container.className = detectionContainerClass;
                  container.style.cssText = buildCssTextString(["visibility: hidden", "display: inline", "width: 0px", "height: 0px", "z-index: -1", "overflow: hidden", "margin: 0", "padding: 0"]);
                  getState(element).container = container;
                  addAnimationClass(container);
                  element.appendChild(container);
                  var onAnimationStart = function() {
                    getState(element).onRendered && getState(element).onRendered();
                  };
                  addEvent(container, "animationstart", onAnimationStart);
                  getState(element).onAnimationStart = onAnimationStart;
                }
                return container;
              }
              function injectScrollElements() {
                function alterPositionStyles() {
                  var style = getState(element).style;
                  if (style.position === "static") {
                    element.style.setProperty("position", "relative", options2.important ? "important" : "");
                    var removeRelativeStyles = function(reporter2, element2, style2, property) {
                      function getNumericalValue(value2) {
                        return value2.replace(/[^-\d\.]/g, "");
                      }
                      var value = style2[property];
                      if (value !== "auto" && getNumericalValue(value) !== "0") {
                        reporter2.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element2);
                        element2.style[property] = 0;
                      }
                    };
                    removeRelativeStyles(reporter, element, style, "top");
                    removeRelativeStyles(reporter, element, style, "right");
                    removeRelativeStyles(reporter, element, style, "bottom");
                    removeRelativeStyles(reporter, element, style, "left");
                  }
                }
                function getLeftTopBottomRightCssText(left, top, bottom, right) {
                  left = !left ? "0" : left + "px";
                  top = !top ? "0" : top + "px";
                  bottom = !bottom ? "0" : bottom + "px";
                  right = !right ? "0" : right + "px";
                  return ["left: " + left, "top: " + top, "right: " + right, "bottom: " + bottom];
                }
                debug("Injecting elements");
                if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
                }
                alterPositionStyles();
                var rootContainer = getState(element).container;
                if (!rootContainer) {
                  rootContainer = injectContainerElement();
                }
                var scrollbarWidth = scrollbarSizes.width;
                var scrollbarHeight = scrollbarSizes.height;
                var containerContainerStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%", "left: 0px", "top: 0px"]);
                var containerStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden"].concat(getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth)));
                var expandStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
                var shrinkStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
                var expandChildStyle = buildCssTextString(["position: absolute", "left: 0", "top: 0"]);
                var shrinkChildStyle = buildCssTextString(["position: absolute", "width: 200%", "height: 200%"]);
                var containerContainer = document.createElement("div");
                var container = document.createElement("div");
                var expand = document.createElement("div");
                var expandChild = document.createElement("div");
                var shrink = document.createElement("div");
                var shrinkChild = document.createElement("div");
                containerContainer.dir = "ltr";
                containerContainer.style.cssText = containerContainerStyle;
                containerContainer.className = detectionContainerClass;
                container.className = detectionContainerClass;
                container.style.cssText = containerStyle;
                expand.style.cssText = expandStyle;
                expandChild.style.cssText = expandChildStyle;
                shrink.style.cssText = shrinkStyle;
                shrinkChild.style.cssText = shrinkChildStyle;
                expand.appendChild(expandChild);
                shrink.appendChild(shrinkChild);
                container.appendChild(expand);
                container.appendChild(shrink);
                containerContainer.appendChild(container);
                rootContainer.appendChild(containerContainer);
                function onExpandScroll() {
                  getState(element).onExpand && getState(element).onExpand();
                }
                function onShrinkScroll() {
                  getState(element).onShrink && getState(element).onShrink();
                }
                addEvent(expand, "scroll", onExpandScroll);
                addEvent(shrink, "scroll", onShrinkScroll);
                getState(element).onExpandScroll = onExpandScroll;
                getState(element).onShrinkScroll = onShrinkScroll;
              }
              function registerListenersAndPositionElements() {
                function updateChildSizes(element2, width, height) {
                  var expandChild = getExpandChildElement(element2);
                  var expandWidth = getExpandWidth(width);
                  var expandHeight = getExpandHeight(height);
                  expandChild.style.setProperty("width", expandWidth + "px", options2.important ? "important" : "");
                  expandChild.style.setProperty("height", expandHeight + "px", options2.important ? "important" : "");
                }
                function updateDetectorElements(done) {
                  var width = element.offsetWidth;
                  var height = element.offsetHeight;
                  var sizeChanged = width !== getState(element).lastWidth || height !== getState(element).lastHeight;
                  debug("Storing current size", width, height);
                  storeCurrentSize(element, width, height);
                  batchProcessor.add(0, function performUpdateChildSizes() {
                    if (!sizeChanged) {
                      return;
                    }
                    if (!getState(element)) {
                      debug("Aborting because element has been uninstalled");
                      return;
                    }
                    if (!areElementsInjected()) {
                      debug("Aborting because element container has not been initialized");
                      return;
                    }
                    if (options2.debug) {
                      var w = element.offsetWidth;
                      var h = element.offsetHeight;
                      if (w !== width || h !== height) {
                        reporter.warn(idHandler.get(element), "Scroll: Size changed before updating detector elements.");
                      }
                    }
                    updateChildSizes(element, width, height);
                  });
                  batchProcessor.add(1, function updateScrollbars() {
                    if (!getState(element)) {
                      debug("Aborting because element has been uninstalled");
                      return;
                    }
                    if (!areElementsInjected()) {
                      debug("Aborting because element container has not been initialized");
                      return;
                    }
                    positionScrollbars(element, width, height);
                  });
                  if (sizeChanged && done) {
                    batchProcessor.add(2, function() {
                      if (!getState(element)) {
                        debug("Aborting because element has been uninstalled");
                        return;
                      }
                      if (!areElementsInjected()) {
                        debug("Aborting because element container has not been initialized");
                        return;
                      }
                      done();
                    });
                  }
                }
                function areElementsInjected() {
                  return !!getState(element).container;
                }
                function notifyListenersIfNeeded() {
                  function isFirstNotify() {
                    return getState(element).lastNotifiedWidth === void 0;
                  }
                  debug("notifyListenersIfNeeded invoked");
                  var state = getState(element);
                  if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {
                    return debug("Not notifying: Size is the same as the start size, and there has been no notification yet.");
                  }
                  if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {
                    return debug("Not notifying: Size already notified");
                  }
                  debug("Current size not notified, notifying...");
                  state.lastNotifiedWidth = state.lastWidth;
                  state.lastNotifiedHeight = state.lastHeight;
                  forEach(getState(element).listeners, function(listener) {
                    listener(element);
                  });
                }
                function handleRender() {
                  debug("startanimation triggered.");
                  if (isUnrendered(element)) {
                    debug("Ignoring since element is still unrendered...");
                    return;
                  }
                  debug("Element rendered.");
                  var expand = getExpandElement(element);
                  var shrink = getShrinkElement(element);
                  if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {
                    debug("Scrollbars out of sync. Updating detector elements...");
                    updateDetectorElements(notifyListenersIfNeeded);
                  }
                }
                function handleScroll() {
                  debug("Scroll detected.");
                  if (isUnrendered(element)) {
                    debug("Scroll event fired while unrendered. Ignoring...");
                    return;
                  }
                  updateDetectorElements(notifyListenersIfNeeded);
                }
                debug("registerListenersAndPositionElements invoked.");
                if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
                }
                getState(element).onRendered = handleRender;
                getState(element).onExpand = handleScroll;
                getState(element).onShrink = handleScroll;
                var style = getState(element).style;
                updateChildSizes(element, style.width, style.height);
              }
              function finalizeDomMutation() {
                debug("finalizeDomMutation invoked.");
                if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
                }
                var style = getState(element).style;
                storeCurrentSize(element, style.width, style.height);
                positionScrollbars(element, style.width, style.height);
              }
              function ready() {
                callback(element);
              }
              function install() {
                debug("Installing...");
                initListeners();
                storeStartSize();
                batchProcessor.add(0, storeStyle);
                batchProcessor.add(1, injectScrollElements);
                batchProcessor.add(2, registerListenersAndPositionElements);
                batchProcessor.add(3, finalizeDomMutation);
                batchProcessor.add(4, ready);
              }
              debug("Making detectable...");
              if (isDetached(element)) {
                debug("Element is detached");
                injectContainerElement();
                debug("Waiting until element is attached...");
                getState(element).onRendered = function() {
                  debug("Element is now attached");
                  install();
                };
              } else {
                install();
              }
            }
            function uninstall(element) {
              var state = getState(element);
              if (!state) {
                return;
              }
              state.onExpandScroll && removeEvent(getExpandElement(element), "scroll", state.onExpandScroll);
              state.onShrinkScroll && removeEvent(getShrinkElement(element), "scroll", state.onShrinkScroll);
              state.onAnimationStart && removeEvent(state.container, "animationstart", state.onAnimationStart);
              state.container && element.removeChild(state.container);
            }
            return {
              makeDetectable,
              addListener,
              uninstall,
              initDocument
            };
          };
        }
      ),
      /***/
      "ca84": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var has = __webpack_require__("5135");
          var toIndexedObject = __webpack_require__("fc6a");
          var indexOf = __webpack_require__("4d64").indexOf;
          var hiddenKeys = __webpack_require__("d012");
          module2.exports = function(object, names) {
            var O = toIndexedObject(object);
            var i = 0;
            var result = [];
            var key;
            for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
            while (names.length > i) if (has(O, key = names[i++])) {
              ~indexOf(result, key) || result.push(key);
            }
            return result;
          };
        }
      ),
      /***/
      "cc12": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var isObject2 = __webpack_require__("861d");
          var document2 = global.document;
          var EXISTS = isObject2(document2) && isObject2(document2.createElement);
          module2.exports = function(it) {
            return EXISTS ? document2.createElement(it) : {};
          };
        }
      ),
      /***/
      "cca6": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var assign = __webpack_require__("60da");
          $({ target: "Object", stat: true, forced: Object.assign !== assign }, {
            assign
          });
        }
      ),
      /***/
      "ce4e": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var createNonEnumerableProperty = __webpack_require__("9112");
          module2.exports = function(key, value) {
            try {
              createNonEnumerableProperty(global, key, value);
            } catch (error) {
              global[key] = value;
            }
            return value;
          };
        }
      ),
      /***/
      "cfb9": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          var es_array_slice = __webpack_require__("fb6a");
          var es_reflect_apply = __webpack_require__("a6fd");
          var mitt_es = function(n) {
            return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
              var i = n.get(t);
              i && i.push(e) || n.set(t, [e]);
            }, off: function(t, e) {
              var i = n.get(t);
              i && i.splice(i.indexOf(e) >>> 0, 1);
            }, emit: function(t, e) {
              (n.get(t) || []).slice().map(function(n2) {
                n2(e);
              }), (n.get("*") || []).slice().map(function(n2) {
                n2(t, e);
              });
            } };
          };
          var lodash = __webpack_require__("2ef0");
          var lodash_default = __webpack_require__.n(lodash);
          var eventBus = {};
          var emitter = mitt_es();
          eventBus.$emit = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            emitter.emit(lodash_default.a.head(args), args.slice(1));
          };
          eventBus.$on = function() {
            Reflect.apply(emitter.on, emitter, lodash_default.a.toArray(arguments));
          };
          eventBus.$off = function() {
            Reflect.apply(emitter.off, emitter, lodash_default.a.toArray(arguments));
          };
          var mitt = __webpack_exports__["a"] = eventBus;
        }
      ),
      /***/
      "d012": (
        /***/
        function(module2, exports2) {
          module2.exports = {};
        }
      ),
      /***/
      "d039": (
        /***/
        function(module2, exports2) {
          module2.exports = function(exec) {
            try {
              return !!exec();
            } catch (error) {
              return true;
            }
          };
        }
      ),
      /***/
      "d066": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var path = __webpack_require__("428f");
          var global = __webpack_require__("da84");
          var aFunction = function(variable) {
            return typeof variable == "function" ? variable : void 0;
          };
          module2.exports = function(namespace, method) {
            return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
          };
        }
      ),
      /***/
      "d1e7": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
          exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
            var descriptor = getOwnPropertyDescriptor(this, V);
            return !!descriptor && descriptor.enumerable;
          } : nativePropertyIsEnumerable;
        }
      ),
      /***/
      "d2bb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var anObject = __webpack_require__("825a");
          var aPossiblePrototype = __webpack_require__("3bbe");
          module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var CORRECT_SETTER = false;
            var test = {};
            var setter;
            try {
              setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
              setter.call(test, []);
              CORRECT_SETTER = test instanceof Array;
            } catch (error) {
            }
            return function setPrototypeOf(O, proto) {
              anObject(O);
              aPossiblePrototype(proto);
              if (CORRECT_SETTER) setter.call(O, proto);
              else O.__proto__ = proto;
              return O;
            };
          }() : void 0);
        }
      ),
      /***/
      "d44e": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var defineProperty = __webpack_require__("9bf2").f;
          var has = __webpack_require__("5135");
          var wellKnownSymbol = __webpack_require__("b622");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          module2.exports = function(it, TAG, STATIC) {
            if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
              defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
            }
          };
        }
      ),
      /***/
      "d6eb": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var prop = "_erd";
          function initState(element) {
            element[prop] = {};
            return getState(element);
          }
          function getState(element) {
            return element[prop];
          }
          function cleanState(element) {
            delete element[prop];
          }
          module2.exports = {
            initState,
            getState,
            cleanState
          };
        }
      ),
      /***/
      "d784": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          __webpack_require__("ac1f");
          var redefine = __webpack_require__("6eeb");
          var fails = __webpack_require__("d039");
          var wellKnownSymbol = __webpack_require__("b622");
          var regexpExec = __webpack_require__("9263");
          var createNonEnumerableProperty = __webpack_require__("9112");
          var SPECIES = wellKnownSymbol("species");
          var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
            var re = /./;
            re.exec = function() {
              var result = [];
              result.groups = { a: "7" };
              return result;
            };
            return "".replace(re, "$<a>") !== "7";
          });
          var REPLACE_KEEPS_$0 = function() {
            return "a".replace(/./, "$0") === "$0";
          }();
          var REPLACE = wellKnownSymbol("replace");
          var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
            if (/./[REPLACE]) {
              return /./[REPLACE]("a", "$0") === "";
            }
            return false;
          }();
          var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
            var re = /(?:)/;
            var originalExec = re.exec;
            re.exec = function() {
              return originalExec.apply(this, arguments);
            };
            var result = "ab".split(re);
            return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
          });
          module2.exports = function(KEY, length, exec, sham) {
            var SYMBOL = wellKnownSymbol(KEY);
            var DELEGATES_TO_SYMBOL = !fails(function() {
              var O = {};
              O[SYMBOL] = function() {
                return 7;
              };
              return ""[KEY](O) != 7;
            });
            var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
              var execCalled = false;
              var re = /a/;
              if (KEY === "split") {
                re = {};
                re.constructor = {};
                re.constructor[SPECIES] = function() {
                  return re;
                };
                re.flags = "";
                re[SYMBOL] = /./[SYMBOL];
              }
              re.exec = function() {
                execCalled = true;
                return null;
              };
              re[SYMBOL]("");
              return !execCalled;
            });
            if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
              var nativeRegExpMethod = /./[SYMBOL];
              var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                if (regexp.exec === regexpExec) {
                  if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                    return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                  }
                  return { done: true, value: nativeMethod.call(str, regexp, arg2) };
                }
                return { done: false };
              }, {
                REPLACE_KEEPS_$0,
                REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
              });
              var stringMethod = methods[0];
              var regexMethod = methods[1];
              redefine(String.prototype, KEY, stringMethod);
              redefine(
                RegExp.prototype,
                SYMBOL,
                length == 2 ? function(string, arg) {
                  return regexMethod.call(string, this, arg);
                } : function(string) {
                  return regexMethod.call(string, this);
                }
              );
            }
            if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
          };
        }
      ),
      /***/
      "d81d": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var $map = __webpack_require__("b727").map;
          var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
          $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            map: function map(callbackfn) {
              return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            }
          });
        }
      ),
      /***/
      "da84": (
        /***/
        function(module2, exports2, __webpack_require__) {
          (function(global) {
            var check = function(it) {
              return it && it.Math == Math && it;
            };
            module2.exports = /* global globalThis -- safe */
            check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || // eslint-disable-next-line no-new-func -- fallback
            /* @__PURE__ */ function() {
              return this;
            }() || Function("return this")();
          }).call(this, __webpack_require__("c8ba"));
        }
      ),
      /***/
      "dbb4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var DESCRIPTORS = __webpack_require__("83ab");
          var ownKeys = __webpack_require__("56ef");
          var toIndexedObject = __webpack_require__("fc6a");
          var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
          var createProperty = __webpack_require__("8418");
          $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
            getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
              var O = toIndexedObject(object);
              var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
              var keys = ownKeys(O);
              var result = {};
              var index = 0;
              var key, descriptor;
              while (keys.length > index) {
                descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
                if (descriptor !== void 0) createProperty(result, key, descriptor);
              }
              return result;
            }
          });
        }
      ),
      /***/
      "dc59": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_v16_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_v16_dist_index_js_ref_0_1_GridLayout_vue_vue_type_style_index_0_id_ecf32d88_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("58d5");
          var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_v16_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_v16_dist_index_js_ref_0_1_GridLayout_vue_vue_type_style_index_0_id_ecf32d88_lang_css__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_v16_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_v16_dist_index_js_ref_0_1_GridLayout_vue_vue_type_style_index_0_id_ecf32d88_lang_css__WEBPACK_IMPORTED_MODULE_0__);
        }
      ),
      /***/
      "df75": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var internalObjectKeys = __webpack_require__("ca84");
          var enumBugKeys = __webpack_require__("7839");
          module2.exports = Object.keys || function keys(O) {
            return internalObjectKeys(O, enumBugKeys);
          };
        }
      ),
      /***/
      "e285": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var global = __webpack_require__("da84");
          var globalIsFinite = global.isFinite;
          module2.exports = Number.isFinite || function isFinite(it) {
            return typeof it == "number" && globalIsFinite(it);
          };
        }
      ),
      /***/
      "e439": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var fails = __webpack_require__("d039");
          var toIndexedObject = __webpack_require__("fc6a");
          var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
          var DESCRIPTORS = __webpack_require__("83ab");
          var FAILS_ON_PRIMITIVES = fails(function() {
            nativeGetOwnPropertyDescriptor(1);
          });
          var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
          $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
            getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
              return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
            }
          });
        }
      ),
      /***/
      "e538": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("b622");
          exports2.f = wellKnownSymbol;
        }
      ),
      /***/
      "e893": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var has = __webpack_require__("5135");
          var ownKeys = __webpack_require__("56ef");
          var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
          var definePropertyModule = __webpack_require__("9bf2");
          module2.exports = function(target, source) {
            var keys = ownKeys(source);
            var defineProperty = definePropertyModule.f;
            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          };
        }
      ),
      /***/
      "e8b5": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var classof = __webpack_require__("c6b6");
          module2.exports = Array.isArray || function isArray2(arg) {
            return classof(arg) == "Array";
          };
        }
      ),
      /***/
      "eec4": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var forEach = __webpack_require__("b770").forEach;
          var elementUtilsMaker = __webpack_require__("5be5");
          var listenerHandlerMaker = __webpack_require__("49ad");
          var idGeneratorMaker = __webpack_require__("2cef");
          var idHandlerMaker = __webpack_require__("5058");
          var reporterMaker = __webpack_require__("abb4");
          var browserDetector = __webpack_require__("18e9");
          var batchProcessorMaker = __webpack_require__("c274");
          var stateHandler = __webpack_require__("d6eb");
          var objectStrategyMaker = __webpack_require__("18d2");
          var scrollStrategyMaker = __webpack_require__("c946");
          function isCollection(obj) {
            return Array.isArray(obj) || obj.length !== void 0;
          }
          function toArray(collection) {
            if (!Array.isArray(collection)) {
              var array = [];
              forEach(collection, function(obj) {
                array.push(obj);
              });
              return array;
            } else {
              return collection;
            }
          }
          function isElement(obj) {
            return obj && obj.nodeType === 1;
          }
          module2.exports = function(options) {
            options = options || {};
            var idHandler;
            if (options.idHandler) {
              idHandler = {
                get: function(element) {
                  return options.idHandler.get(element, true);
                },
                set: options.idHandler.set
              };
            } else {
              var idGenerator = idGeneratorMaker();
              var defaultIdHandler = idHandlerMaker({
                idGenerator,
                stateHandler
              });
              idHandler = defaultIdHandler;
            }
            var reporter = options.reporter;
            if (!reporter) {
              var quiet = reporter === false;
              reporter = reporterMaker(quiet);
            }
            var batchProcessor = getOption(options, "batchProcessor", batchProcessorMaker({ reporter }));
            var globalOptions = {};
            globalOptions.callOnAdd = !!getOption(options, "callOnAdd", true);
            globalOptions.debug = !!getOption(options, "debug", false);
            var eventListenerHandler = listenerHandlerMaker(idHandler);
            var elementUtils = elementUtilsMaker({
              stateHandler
            });
            var detectionStrategy;
            var desiredStrategy = getOption(options, "strategy", "object");
            var importantCssRules = getOption(options, "important", false);
            var strategyOptions = {
              reporter,
              batchProcessor,
              stateHandler,
              idHandler,
              important: importantCssRules
            };
            if (desiredStrategy === "scroll") {
              if (browserDetector.isLegacyOpera()) {
                reporter.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy.");
                desiredStrategy = "object";
              } else if (browserDetector.isIE(9)) {
                reporter.warn("Scroll strategy is not supported on IE9. Changing to object strategy.");
                desiredStrategy = "object";
              }
            }
            if (desiredStrategy === "scroll") {
              detectionStrategy = scrollStrategyMaker(strategyOptions);
            } else if (desiredStrategy === "object") {
              detectionStrategy = objectStrategyMaker(strategyOptions);
            } else {
              throw new Error("Invalid strategy name: " + desiredStrategy);
            }
            var onReadyCallbacks = {};
            function listenTo(options2, elements, listener) {
              function onResizeCallback(element) {
                var listeners = eventListenerHandler.get(element);
                forEach(listeners, function callListenerProxy(listener2) {
                  listener2(element);
                });
              }
              function addListener(callOnAdd2, element, listener2) {
                eventListenerHandler.add(element, listener2);
                if (callOnAdd2) {
                  listener2(element);
                }
              }
              if (!listener) {
                listener = elements;
                elements = options2;
                options2 = {};
              }
              if (!elements) {
                throw new Error("At least one element required.");
              }
              if (!listener) {
                throw new Error("Listener required.");
              }
              if (isElement(elements)) {
                elements = [elements];
              } else if (isCollection(elements)) {
                elements = toArray(elements);
              } else {
                return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
              }
              var elementsReady = 0;
              var callOnAdd = getOption(options2, "callOnAdd", globalOptions.callOnAdd);
              var onReadyCallback = getOption(options2, "onReady", function noop() {
              });
              var debug = getOption(options2, "debug", globalOptions.debug);
              forEach(elements, function attachListenerToElement(element) {
                if (!stateHandler.getState(element)) {
                  stateHandler.initState(element);
                  idHandler.set(element);
                }
                var id = idHandler.get(element);
                debug && reporter.log("Attaching listener to element", id, element);
                if (!elementUtils.isDetectable(element)) {
                  debug && reporter.log(id, "Not detectable.");
                  if (elementUtils.isBusy(element)) {
                    debug && reporter.log(id, "System busy making it detectable");
                    addListener(callOnAdd, element, listener);
                    onReadyCallbacks[id] = onReadyCallbacks[id] || [];
                    onReadyCallbacks[id].push(function onReady() {
                      elementsReady++;
                      if (elementsReady === elements.length) {
                        onReadyCallback();
                      }
                    });
                    return;
                  }
                  debug && reporter.log(id, "Making detectable...");
                  elementUtils.markBusy(element, true);
                  return detectionStrategy.makeDetectable({ debug, important: importantCssRules }, element, function onElementDetectable(element2) {
                    debug && reporter.log(id, "onElementDetectable");
                    if (stateHandler.getState(element2)) {
                      elementUtils.markAsDetectable(element2);
                      elementUtils.markBusy(element2, false);
                      detectionStrategy.addListener(element2, onResizeCallback);
                      addListener(callOnAdd, element2, listener);
                      var state = stateHandler.getState(element2);
                      if (state && state.startSize) {
                        var width = element2.offsetWidth;
                        var height = element2.offsetHeight;
                        if (state.startSize.width !== width || state.startSize.height !== height) {
                          onResizeCallback(element2);
                        }
                      }
                      if (onReadyCallbacks[id]) {
                        forEach(onReadyCallbacks[id], function(callback) {
                          callback();
                        });
                      }
                    } else {
                      debug && reporter.log(id, "Element uninstalled before being detectable.");
                    }
                    delete onReadyCallbacks[id];
                    elementsReady++;
                    if (elementsReady === elements.length) {
                      onReadyCallback();
                    }
                  });
                }
                debug && reporter.log(id, "Already detecable, adding listener.");
                addListener(callOnAdd, element, listener);
                elementsReady++;
              });
              if (elementsReady === elements.length) {
                onReadyCallback();
              }
            }
            function uninstall(elements) {
              if (!elements) {
                return reporter.error("At least one element is required.");
              }
              if (isElement(elements)) {
                elements = [elements];
              } else if (isCollection(elements)) {
                elements = toArray(elements);
              } else {
                return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
              }
              forEach(elements, function(element) {
                eventListenerHandler.removeAllListeners(element);
                detectionStrategy.uninstall(element);
                stateHandler.cleanState(element);
              });
            }
            function initDocument(targetDocument) {
              detectionStrategy.initDocument && detectionStrategy.initDocument(targetDocument);
            }
            return {
              listenTo,
              removeListener: eventListenerHandler.removeListener,
              removeAllListeners: eventListenerHandler.removeAllListeners,
              uninstall,
              initDocument
            };
          };
          function getOption(options, name, defaultValue) {
            var value = options[name];
            if ((value === void 0 || value === null) && defaultValue !== void 0) {
              return defaultValue;
            }
            return value;
          }
        }
      ),
      /***/
      "f00c": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var $ = __webpack_require__("23e7");
          var numberIsFinite = __webpack_require__("e285");
          $({ target: "Number", stat: true }, { isFinite: numberIsFinite });
        }
      ),
      /***/
      "f772": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var shared = __webpack_require__("5692");
          var uid = __webpack_require__("90e3");
          var keys = shared("keys");
          module2.exports = function(key) {
            return keys[key] || (keys[key] = uid(key));
          };
        }
      ),
      /***/
      "fb15": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, "install", function() {
            return (
              /* reexport */
              components[
                "d"
                /* install */
              ]
            );
          });
          __webpack_require__.d(__webpack_exports__, "GridLayout", function() {
            return (
              /* reexport */
              components[
                "b"
                /* GridLayout */
              ]
            );
          });
          __webpack_require__.d(__webpack_exports__, "GridItem", function() {
            return (
              /* reexport */
              components[
                "a"
                /* GridItem */
              ]
            );
          });
          if (typeof window !== "undefined") {
            var currentScript = window.document.currentScript;
            if (true) {
              var getCurrentScript = __webpack_require__("8875");
              currentScript = getCurrentScript();
              if (!("currentScript" in document)) {
                Object.defineProperty(document, "currentScript", { get: getCurrentScript });
              }
            }
            var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
            if (src) {
              __webpack_require__.p = src[1];
            }
          }
          var setPublicPath = null;
          var components = __webpack_require__("2af9");
          var entry_lib = __webpack_exports__["default"] = components[
            "c"
            /* default */
          ];
        }
      ),
      /***/
      "fb6a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("23e7");
          var isObject2 = __webpack_require__("861d");
          var isArray2 = __webpack_require__("e8b5");
          var toAbsoluteIndex = __webpack_require__("23cb");
          var toLength = __webpack_require__("50c4");
          var toIndexedObject = __webpack_require__("fc6a");
          var createProperty = __webpack_require__("8418");
          var wellKnownSymbol = __webpack_require__("b622");
          var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
          var SPECIES = wellKnownSymbol("species");
          var nativeSlice = [].slice;
          var max = Math.max;
          $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            slice: function slice(start, end) {
              var O = toIndexedObject(this);
              var length = toLength(O.length);
              var k = toAbsoluteIndex(start, length);
              var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
              var Constructor, result, n;
              if (isArray2(O)) {
                Constructor = O.constructor;
                if (typeof Constructor == "function" && (Constructor === Array || isArray2(Constructor.prototype))) {
                  Constructor = void 0;
                } else if (isObject2(Constructor)) {
                  Constructor = Constructor[SPECIES];
                  if (Constructor === null) Constructor = void 0;
                }
                if (Constructor === Array || Constructor === void 0) {
                  return nativeSlice.call(O, k, fin);
                }
              }
              result = new (Constructor === void 0 ? Array : Constructor)(max(fin - k, 0));
              for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
              result.length = n;
              return result;
            }
          });
        }
      ),
      /***/
      "fc6a": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var IndexedObject = __webpack_require__("44ad");
          var requireObjectCoercible = __webpack_require__("1d80");
          module2.exports = function(it) {
            return IndexedObject(requireObjectCoercible(it));
          };
        }
      ),
      /***/
      "fdbc": (
        /***/
        function(module2, exports2) {
          module2.exports = {
            CSSRuleList: 0,
            CSSStyleDeclaration: 0,
            CSSValueList: 0,
            ClientRectList: 0,
            DOMRectList: 0,
            DOMStringList: 0,
            DOMTokenList: 1,
            DataTransferItemList: 0,
            FileList: 0,
            HTMLAllCollection: 0,
            HTMLCollection: 0,
            HTMLFormElement: 0,
            HTMLSelectElement: 0,
            MediaList: 0,
            MimeTypeArray: 0,
            NamedNodeMap: 0,
            NodeList: 1,
            PaintRequestList: 0,
            Plugin: 0,
            PluginArray: 0,
            SVGLengthList: 0,
            SVGNumberList: 0,
            SVGPathSegList: 0,
            SVGPointList: 0,
            SVGStringList: 0,
            SVGTransformList: 0,
            SourceBufferList: 0,
            StyleSheetList: 0,
            TextTrackCueList: 0,
            TextTrackList: 0,
            TouchList: 0
          };
        }
      ),
      /***/
      "fdbf": (
        /***/
        function(module2, exports2, __webpack_require__) {
          var NATIVE_SYMBOL = __webpack_require__("4930");
          module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
        }
      ),
      /***/
      "fdec": (
        /***/
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_v16_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_v16_dist_index_js_ref_0_1_GridItem_vue_vue_type_style_index_0_id_bf5dd244_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a221");
          var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_v16_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_v16_dist_index_js_ref_0_1_GridItem_vue_vue_type_style_index_0_id_bf5dd244_lang_css__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_v16_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_v16_dist_index_js_ref_0_1_GridItem_vue_vue_type_style_index_0_id_bf5dd244_lang_css__WEBPACK_IMPORTED_MODULE_0__);
        }
      )
      /******/
    })["default"];
  }
});
export default require_vue_grid_layout_common();
/*! Bundled license information:

@vue/compiler-core/dist/compiler-core.esm-bundler.js:
  (**
  * @vue/compiler-core v3.5.25
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/compiler-dom/dist/compiler-dom.esm-bundler.js:
  (**
  * @vue/compiler-dom v3.5.25
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue/dist/vue.cjs.js:
  (**
  * vue v3.5.25
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue3-grid-layout/dist/vue-grid-layout.common.js:
  (*! vue-grid-layout - 2.3.12 | (c) 2015, 2021  undefined | undefined *)
  (**
  * @license
  * Lodash <https://lodash.com/>
  * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
  * Released under MIT license <https://lodash.com/license>
  * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
  * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *)
*/
//# sourceMappingURL=vue3-grid-layout.js.map
